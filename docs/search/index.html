<!DOCTYPE html>
<html lang="ja">
<head>





<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>サイト内全文検索 - InTheDayDream</title>
<meta name="description" content="">

<meta name="author" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">
<link rel="alternate" href="/index.xml?c=213e5ef15ae65780180e8fc581ca0b9011dedf65" type="application/rss+xml" title="RSS" />
<meta property="og:title" content="サイト内全文検索 - InTheDayDream">
<meta property="og:url" content="https://inthebloom.github.io/search/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="InTheDayDream">
<meta property="og:description" content="">

<meta property="og:image" content="https://inthebloom.github.io//images/featured_image.jpg">

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@UU9782wsEdANDhp">
<meta name="twitter:creator" content="@UU9782wsEdANDhp">
<meta name="twitter:title" content="サイト内全文検索 - InTheDayDream">
<meta name="twitter:url" content="https://inthebloom.github.io/search/">
<meta name="twitter:description" content="">

<meta property="og:image" content="https://inthebloom.github.io//images/featured_image.jpg">


<link rel="stylesheet" href="/css/main.css?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">
<link rel="stylesheet" href="/css/color.css?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">


<link rel="stylesheet" href="/css/custom.css?c=213e5ef15ae65780180e8fc581ca0b9011dedf65">



</head>

<body class="theme-default">






<div id="content-header" class="title">
  
  <a class="site-title" href="/">InTheDayDream</a>
  
  <span class="site-sub-title"></span>

  

  <div id="main-menu-nav">
    <div id="main-menu-nav-items">
      
        <div class="nav-item"><a href="/">Home</a></div>
      
        <div class="nav-item"><a href="/tags/">Tags</a></div>
      
        <div class="nav-item"><a href="/archives/">Archives</a></div>
      
        <div class="nav-item"><a href="/about/">About</a></div>
      
        <div class="nav-item"><a href="/search/">Search</a></div>
      
    </div>
  </div>
</div>
<div id="content" class="main">




<h1>サイト内全文検索</h1>








<p>サイト内の文章からインクリメント検索が可能です。
下の入力欄に入力することで検索ができます。</p>
<p>本ページは検索の対象外になっています。</p>

<head>
  <meta charset="UTF-8">
  <style>
    body {
      background: #fafafa;
    }
    input {
      color: deeppink;
      font-size: 1.2em;
      font-weight: bolder;
    }
    input::-webkit-input-placeholder {
      color: pink;
    }
    #result {
      margin: 1em;
    }
    .item_title {
      text-decoration: none;
      color: #36f;
      font-weight: bolder;
    }
    .item_excerpt {
      background: white;
      margin: 0.5em 2em 1em;
      padding: 0.5em;
      border: dashed 1px lightgray;
      font-size: smaller;
    }
    .item_excerpt b {
      background: pink;
    }
  </style>
</head>
<body>

<input onkeyup="search(this.value)" size="15" autocomplete="off" autofocus placeholder="検索ワード" />
<span id="inputWord"></span> <span id="resultCount"></span>
<div id="result"></div>

<script>

const data = [
  {
    url: "/post/abc396/",
    title: "ABC396 A-F",
    date: "2025-03-12T00:00:00+09:00",
    body: "ABC396 A-F A - Triple Four 問題 問題文の通り$A _ i = A _ {i + 1} = A _ {i + 2}$を判定していけば良い。各$i$について$O(1)$個の項を見れば良いので、全体で$O(N)$時間。 import std; void main () { int N = readln.chomp.to!int; auto A = readln.split.to!(int[]); bool ok = false; foreach (i; 0 .. N - 2) { if (A[i] == A[i + 1] \u0026amp;\u0026amp; A[i + 1] == A[i + 2]) { ok = true; } } if (ok) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Card Pile 問題 明らかにカードの山はFirst In Last Outによりシミュレーションできる。 よって、stackを用いれば良い。 実装上は、動的配列の末尾への操作によりstackを実現するのが最も簡単だと思う。 import std; void main () { int Q = readln.chomp.to!int; auto que = new int[](0); foreach (i; 0 .. 100) que ~= 0; auto ans = new int[](0); foreach (i; 0 .. Q) { auto query = readln.split.to!(int[]); int t = query[0]; if (t == 1) { int x = query[1]; que ~= x; } if (t == 2) { ans ~= que[$ - 1]; que.length--; } } writefln(\u0026#34;%(%s\\n%)\u0026#34;, ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Buy Balls 問題 できるだけ頭を使わずにできるならそれに越したことはないので、全探索を考える。 黒を$i$個取ったとして、最適な白のとり方を考える。（このとき、黒は降順に$i$個取るのが最適なことに注意。） 「まだ取れる余裕があるのに取らないほうが得になる場合」がいつになるのか考えると、それは負の項しか残っていないときになる。これを踏まえよう。 白のうち正の項が$x$個あったとする。最適なとり方は $i \\leq x$のとき、白の降順$i$個。$x \u0026lt; i$のとき、白の降順$x$個となる。 白、黒どちらも降順にソートした上で累積和を取っておくことで必要な値を$O(1)$時間で取得できる。 import std; void main () { int N, M; readln.read(N, M); auto B = readln.split.to!(int[]); auto W = readln.split.to!(int[]); B.sort!\u0026#34;a \u0026gt; b\u0026#34;; W.sort!\u0026#34;a \u0026gt; b\u0026#34;; auto bcc = new long[](N + 1); foreach (i; 0 .. N) bcc[i + 1] = bcc[i] + B[i]; auto wcc = new long[](M + 1); foreach (i; 0 .. M) wcc[i + 1] = wcc[i] + W[i]; int wp = 0; foreach (w; W) if (0 \u0026lt; w) wp++; long ans = -long.max; foreach (i; 0 .. N + 1) { long candi = bcc[i]; if (wp \u0026lt;= i) { candi += wcc[wp]; } else { candi += wcc[i]; } ans = max(ans, candi); } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Minimum XOR Path 問題 一般に、XORの最小値を考えようとしても、dpのようなことをするのが難しい。（部分最適性が多くの場合成り立たないので） なので、全探索をベースに考える。 $N \\leq 10$なので、十分パスの列挙ができそうな感じがするので、それを書くと通る。 visited配列を持ちながらdfsをすると効率的に列挙できるが、同じ頂点を二度通らないという制約から、順列全探索によるパス列挙を行うこともできる。 import std; void main () { int N, M; readln.read(N, M); auto graph = new long[][](N, N); foreach (g; graph) g[] = -1; foreach (i; 0 .. M) { int u, v; long w; readln.read(u, v, w); u--, v--; graph[u][v] = graph[v][u] = w; } auto ord = iota(N).array; long ans = long.max; void f () { if (ord[0] != 0) return; bool ok = true; long res = 0; foreach (i; 0 .. N - 1) { if (graph[ord[i]][ord[i + 1]] == -1) { ok = false; break; } res ^= graph[ord[i]][ord[i + 1]]; // 頂点Nに到着 if (ord[i + 1] == N - 1) break; } if (!ok) return; if (res \u0026lt; ans) { ans = res; } } do { f(); } while (nextPermutation(ord)); writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Min of Restricted Sum いくつかのモノ同士の「関係性」が与えられたときに、グラフに関する問題に帰着することで見通しが良くなるケースがある。今回もそのような問題になっている。 思考の流れとしては次のような感じだった。 可能不可能のサンプルを書き下して眺める。連立方程式を解くみたいなことをするのはどう考えても厳しいので、グラフに帰着させると良さそうだと思う。 サンプル2が不可能なことから、木であれば可能、木でなくても色々都合が良ければ可能になりそうだと思う。 サンプル1を眺めて、最小値を達成する方法を考える。この例だと頂点1に100がないと明らかに最小値の達成は不可能になる。ここで桁ごとに独立に考えて良いことに気がつく。また、適当に取った全域木を満たしていくみたいなことは無理そうだと考える。 桁ごとに考えたとき、各XORの条件は「隣接頂点の桁が同じか異なるか」の指示になっていることが見えてくる。この条件を満たしたときに最小にするためには、より少ない方に1を割り当てるだけで良いことがわかる。 二部グラフの判定の問題に似ているので、それをやる。 桁が同じでなければいけない頂点集合を一つに潰してしまえば、完全に二部グラフ判定と等価の問題になる。あとは各連結成分について頑張って集計し、より少ない方に1を割り当てるようにすれば通る。 import std; void main () { int N, M; readln.read(N, M); auto X = new int[](M); auto Y = new int[](M); auto Z = new int[](M); foreach (i; 0 .. M) { readln.read(X[i], Y[i], Z[i]); X[i]--, Y[i]--; } // グラフみたいな方向で考えるのがよさそう。 // 各連結成分が木なら可能。サイクルを持っていたとしても都合が合えば可能。 // 桁ごとに独立に考えてよくて、そうするとXORの条件は頂点ラベルが等しいかどうか // -\u0026gt; 二部グラフが作れるかどうか // -\u0026gt; 少ない方に1を割り当ててやればよい。 bool ok = true; auto ans = new int[](N); foreach (b; 0 .. 30) { // 同じ色をまとめる auto group = UnionFind(N); foreach (i; 0 .. M) { if ((Z[i] \u0026amp; (1 \u0026lt;\u0026lt; b)) == 0) { group.unite(X[i], Y[i]); } } // 二部グラフ判定 auto graph = new int[][](N); auto color = new int[](N); color[] = -1; foreach (i; 0 .. M) { if ((Z[i] \u0026amp; (1 \u0026lt;\u0026lt; b)) == 0) continue; graph[group.root(X[i])] ~= group.root(Y[i]); graph[group.root(Y[i])] ~= group.root(X[i]); } auto que = new Tuple!(int, int)[](0); auto paint = new int[](N); void dfs (int pos, int c) { foreach (to; graph[pos]) { // 未訪問 if (color[to] == -1) { que ~= tuple(to, c ^ 1); color[to] = c ^ 1; dfs(to, c ^ 1); } else { if (color[to] == c) { ok = false; } } } } foreach (i; 0 .. N) { if (color[i] == -1) { que.length = 0; color[i] = 0; que ~= tuple(i, 0); dfs(i, 0); // queに入ってるのが連結成分 // 根が?である頂点がどちらになるかをここで決定しておく int[2] count; foreach (j; 0 .. que.length) { count[que[j][1]] += group.GroupSize(que[j][0]); } if (count[0] \u0026lt;= count[1]) { foreach (v; que) { int cc = 0; if (v[1] == 0) cc = 1; paint[v[0]] = cc; } } else { foreach (v; que) { int cc = 0; if (v[1] == 1) cc = 1; paint[v[0]] = cc; } } } } foreach (i; 0 .. N) { ans[i] |= paint[group.root(i)] \u0026lt;\u0026lt; b; } } if (ok) { writefln(\u0026#34;%(%s %)\u0026#34;, ans); } else { writeln(-1); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } /* UnionFind */ 実は二部グラフにこだわる必要はなく、二部グラフ判定の途中に「色が同じ条件の辺があって、実際に色が同じような隣接頂点」の存在を許容するように改造することで、途中の頂点集合を潰すフェーズがまるごといらなくなり、集計と解への01割り当てが非常に容易になる。 import std; void main () { int N, M; readln.read(N, M); auto graph = new Tuple!(int, int)[][](N); foreach (i; 0 .. M) { int X, Y, Z; readln.read(X, Y, Z); X--, Y--; graph[X] ~= tuple(Y, Z); graph[Y] ~= tuple(X, Z); } // 二部グラフのアルゴリズムにこだわらなくても、整合性が取れていればスルーするようにすれば頂点集合の圧縮が必要ない上、実際の彩色の集計が非常に簡単になる。 auto q = DList!(Tuple!(int, int))(); auto color = new int[](N); auto ans = new int[](N); bool ok = true; auto buf = new int[][](2); foreach (b; 0 .. 30) { color[] = -1; foreach (i; 0 .. N) { if (color[i] != -1) continue; buf[0].length = buf[1].length = 0; color[i] = 0; q.insertBack(tuple(i, 0)); buf[0] ~= i; while (!q.empty()) { auto pos = q.front(); q.removeFront(); foreach (to; graph[pos[0]]) { bool same = (to[1] \u0026amp; (1 \u0026lt;\u0026lt; b)) == 0; if (color[to[0]] == -1) { int nex = pos[1] ^ 1; if (same) nex = pos[1]; color[to[0]] = nex; q.insertBack(tuple(to[0], nex)); buf[nex] ~= to[0]; } else { if (same \u0026amp;\u0026amp; color[to[0]] == (pos[1] ^ 1)) ok = false; if (!same \u0026amp;\u0026amp; color[to[0]] == pos[1]) ok = false; } } } // 集計 if (buf[0].length \u0026lt; buf[1].length) { foreach (v; buf[0].chain(buf[1])) color[v] ^= 1; } } // 反映 foreach (i; 0 .. N) { ans[i] |= color[i] \u0026lt;\u0026lt; b; } } if (ok) { writefln(\u0026#34;%(%s %)\u0026#34;, ans); } else { writeln(-1); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } F - Rotated Inversions 本番解けなかった。 仮にMODを取らなかったとすると、転倒数は変化しない。これは任意に二項取ってきたとき、その大小関係が保たれるからである。 逆に言うと、転倒数の変化と$M - 1$から$0$への変化は密接に結びついている。 ある数の変化でどのように変わるかを観察してみよう。 以後、数が$M - 1$から$0$に変化することを「flipする」と呼ぶ。 位置$i$にある項がflipしたとすると、$i$より前にある$0$超過の要素との寄与が+0から+1に変化し、$i$より後ろにある$0$超過の要素との寄与が+1から+0に変化する。 この観察を用いて、各項からの寄与の配列（$i$番目の項が、ペア$(*, i)$による転倒数への寄与を表す配列）をシミュレーションすることができる。 具体的には、前者は位置$i$より前にある、$A _ i$と等しくない要素がすべて+1寄与になるということなので、同じタイミングでflipするインデクスを事前に列挙しておけば$O(1)$時間で計算可能。 後者は区間$[i + 1, N)$へ-1寄与を行うとみなすことができる。 これら2つの寄与の変化は区間加算、区間和取得ができれば素直に表現可能で、遅延セグメント木を用いて計算可能。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;atcoder/segtree\u0026gt; #include \u0026lt;atcoder/lazysegtree\u0026gt; using namespace std; using namespace atcoder; using ll = long long; // https://betrue12.hateblo.jp/entry/2020/09/23/005940 struct S{ long long value; int size; }; using F = long long; S op(S a, S b){ return {a.value+b.value, a.size+b.size}; } S e(){ return {0, 0}; } S mapping(F f, S x){ return {x.value + f*x.size, x.size}; } F composition(F f, F g){ return f+g; } F id(){ return 0; } int seg_op (int x, int y) { return x + y; } int seg_e () { return 0; } int main () { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;int\u0026gt; A(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; lazy_segtree\u0026lt;S, op, e, F, mapping, composition, id\u0026gt; seg(N + 10); segtree\u0026lt;int, seg_op, seg_e\u0026gt; rsq(M + 10); for (int i = 0; i \u0026lt; N; i++) { seg.set(i, S{rsq.prod(A[i] + 1, M + 10), 1}); rsq.set(A[i], rsq.get(A[i]) + 1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; flip(M + 1); for (int i = 0; i \u0026lt; N; i++) { flip[M - A[i]].push_back(i); } vector\u0026lt;ll\u0026gt; ans(M); ans[0] = seg.prod(0, N).value; vector\u0026lt;int\u0026gt; buf(N); for (int i = 1; i \u0026lt; M; i++) { for (int j = 0; j \u0026lt; flip[i].size(); j++) { buf[j] = flip[i][j] - j - seg.get(flip[i][j]).value; } for (auto idx : flip[i]) { seg.apply(idx + 1, N, -1); } for (int j = 0; j \u0026lt; flip[i].size(); j++) { seg.set(flip[i][j], S{buf[j], 1}); } ans[i] = seg.prod(0, N).value; } for (auto v : ans) { cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } さて、上記解法のすべてにおいて、「寄与の配列の総和」のみをが必要であることがわかる。 実は配列全体をシミュレーションする必要はなく、総和だけ保持しておけば十分。 import std; void main () { int N, M; readln.read(N, M); auto A = readln.split.to!(int[]); auto ans = new long[](M); auto rsq = new SegmentTree!(int, (int a, int b) =\u0026gt; a + b, () =\u0026gt; 0)(M + 10); foreach (i; 0 .. N) { ans[0] += rsq.prod(A[i] + 1, M); rsq.set(A[i], rsq.get(A[i]) + 1); } auto flip = new int[][](M + 1); foreach (i; 0 .. N) { flip[M - A[i]] ~= i; } foreach (i; 1 .. M) { long plus = 0, minus = 0; // 増える分はflip場所のみ0の転倒数 // 減る分はflip場所のみ1の転倒数 // これらは特殊ケースなのでO(|flip[i]|)で計算可能 foreach (j; 0 .. flip[i].length) { plus += flip[i][j] - j; int nex = N; if (j + 1 \u0026lt; flip[i].length) nex = flip[i][j + 1]; minus += 1L * (j + 1) * (nex - flip[i][j] - 1); } ans[i] = ans[i - 1] + plus - minus; } writefln(\u0026#34;%(%s\\n%)\u0026#34;, ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } /* SegmentTree */ もう一つアプローチがある。 ある値の異なる二項に注目したとき、それらの関係性は常に「転倒数に+1寄与」か「転倒数に+0寄与」のどちらかになり、$k$を$M - 1$まで増やしていく過程でこの関係性は$O(1)$回しか変化しない。 そこで、長さ$M$の解を入れる配列を用意して、その上ですべての二項の寄与を区間加算することでも解くことができる。 すべての二項のペアは$O(N ^ 2)$個あるが、すべてのペアを見ずともうまく区間加算を行うことができる。 ここから$o(N ^ 2)$回の区間加算で正確にシミュレートするため主客転倒を行う。そのために、元の区間加算が実際どのようになるのかを考える必要がある。 以下、$i \u0026lt; j$を仮定 $A _ i \u0026lt; A _ j$ この場合、$A _ j$がflipしてから$A _ i$がflipするまで（タイプ1）加算を行えば良い。 $A _ i \u0026gt; A _ j$ この場合、最初から$A _ i$がflipするまで（タイプ2）と、$A _ j$がflipしてから最後まで（タイプ3）加算を行えばよい。 ここからタイプごとに固定する頂点を定め、集客転倒をし、区間加算に落とし込む。 以下の議論では、「ある区間に+1をする」ではなく、「はみ出した区間を-1で打ち消す」ことを念頭に置くと理解しやすい。 タイプ1 まず終点を考えずに+1を積もう。これは$j$側を固定して考えるとよい。 $A _ j$がflipするタイミング、つまり$\\mathrm{ans} _ {M - A _ j}$に「$j$より前にあって、$A _ j$未満の項の数」を積む。 次に-1の区間加算で終点を作ろう。こちらは$i$側を固定する。 $\\mathrm{ans} _ {M - A _ i}$から「$i$より後ろにあって、$A _ i$より大きな項の数」を引く。 タイプ2 始点は$k = 0$における転倒数そのものである。これを$\\mathrm{ans} _ 0$に積む。 終点は$A _ i$を固定する。$\\mathrm{ans} _ {M - A _ i}$から「$i$より後ろにあって、$A _ i$より小さいもの」を引く。 タイプ3 始点は$A _ j$を固定。$\\mathrm{ans} _ {M - A _ j}$に「$j$より前にあって$A _ j$より大きなもの」を積む。 終点は考えなくてよい。 これらは値ベースのセグメント木などで計算できる。 import std; void main () { int N, M; readln.read(N, M); auto A = readln.split.to!(int[]); // ある添字組に着目し、転倒数への寄与を考える。 // 寄与を与えるタイミングと寄与が消えるタイミングを切り離して考える。 // つまり、寄与は一旦onになったらその後ずっとonのままと考えて計算し、寄与のoffを-1寄与とみなして計算することで最後に辻褄を合わせる。 // 寄与は2通り。 // 1. 最初から転倒数に寄与するペア // 2. M - 1 -\u0026gt; 0のflip時に寄与し始めるペア // 1は転倒数そのもの。k = 0から後ろに寄与。ただし、途中で一度無効化されたあとまた寄与することができるので注意。 // 2は後ろの項を固定して数え上げることにすると、自分より前の自分より小さい値の個数。これは値ベースのセグメント木で数えられる。 // それぞれに対して打ち消しがどうなるのか考える。 // 1に対する打ち消しは、値の大きい方が0にflipした瞬間を考えると都合が良い。これは自分より後ろにいるより小さいものの個数 // 2に対する打ち消しは、小さい方がflipするタイミングを考えると都合が良い。これは自分より後ろにいるより大きいものの個数 // これらをすべて区間加算として積んで、点取得をするとOK auto rsq = new SegmentTree!(int, (int a, int b) =\u0026gt; a + b, () =\u0026gt; 0)(M + 1); auto ans = new long[](M + 1); // 寄与 foreach (i; 0 .. N) { ans[0] += rsq.prod(A[i] + 1, M); ans[M - A[i]] += rsq.prod(0, A[i]); ans[M - A[i]] += rsq.prod(A[i] + 1, M); rsq.set(A[i], rsq.get(A[i]) + 1); } // 打ち消し auto count = new int[](M); foreach_reverse (i; 0 .. N) { ans[M - A[i]] -= N - i - 1 - count[A[i]]; count[A[i]]++; } foreach (i; 0 .. M) { ans[i + 1] += ans[i]; } writefln(\u0026#34;%(%s\\n%)\u0026#34;, ans[0 .. M]); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } /* SegmentTree */"
  },
  {
    url: "/",
    title: "InTheDayDream",
    date: "2025-03-12T00:00:00+09:00",
    body: "InTheDayDream"
  },
  {
    url: "/post/",
    title: "Posts",
    date: "2025-03-12T00:00:00+09:00",
    body: "Posts"
  },
  {
    url: "/post/uniquevision-lt-2025-01-15/",
    title: "ユニークビジョンLT会に登壇してきた",
    date: "2025-02-07T00:00:00+09:00",
    body: "ユニークビジョンLT会に登壇してきた 概要 ユニークビジョンプログラミングコンテスト2024クリスマス(AtCoder Beginner Contest 385) に参加し、参加者限定イベントの、ユニークビジョンオフィスにて行われるLT会に登壇者として参加しました。 半月ほど時間がたってしまっていますが、これは単にさぼっていたのが半分、ユニークビジョンのイベント開催記事みたいなのが出てから出そうと思っていたというのがもう半分です。(出そうにないので諦めました。) 登壇資料 台本 実は台本を読んでいました。だから、話が詰まらなかったんですね。(弱メガトン構文) 皆さんこんにちは。私からは、「ダブリングの定数倍を救いたい」というテーマで発表させていただきます。よろしくお願いします。 まずはダブリングについて軽く説明をします。ダブリングとは、すべての頂点の出次数が1の有向グラフにおいて、K回進んだ先がどこになるかを高速に求める手法のことです。 異なるものを指してダブリングと呼ぶこともあるかと思いますが、ここでは触れません。 解法としましては、dp[i][j]を「頂点iから2^j回進んだ頂点」と定義したテーブルを用意して、これを利用してクエリに解答するのが一般的です。 「2^j回進んだ」という少々変わった定義を使っていますが、こうするといろいろと都合が良いです。これ以上細かいアルゴリズムはここでは説明を省略します。 さて、少し前にPermute K timesという問題がありました。この問題はまさにダブリングを用いて解ける問題の例になっています。 考察すると、頂点iから頂点Xiに辺をはったグラフにおいてダブリングを行えばよいことがわかります。計算量は、O(NlogK)です。 競技プログラマの皆さんなら、logは「定数」ということで、logKの部分は問題にならないと考える場合が多いかと思います。果たして、本当にそうでしょうか。実際に試してみましょう。 細かいコードは後で見てほしいのですが、こんな感じのプログラムをD、pypy、C++の三つで提出して、かかった時間を見ていきます。 こちらが結果になります。 なんと、D言語とpypyがTLEしてしまいました。C++も1200msかかってしまっていて、あまり良い感じではないですね。一応断っておきますが、極端に定数倍を悪くする恣意的な操作はしていません。気になる方は後でコードを見てください。 今日はこの問題に対する定数倍改善を2種類紹介します。まずは弱い方です。dpテーブルの添え字の順番を変えます。先ほどと逆に、dp[i][j]を「頂点jから2^i回進んだ頂点」としてあげましょう。改善前のコードでは、長さ60程度の配列をN本持つ実装になっていましたが、こちらは長さNの配列を60本程度持つ形になっています。 結果です。本当に添え字を入れ替えただけなんですが、なんと全言語TLEを回避することに成功しました。pypyは7ケースくらいTLEしていたんですが、全部通りました。驚きですね。 さて、もう一方の改善も紹介します。 こちらは問題にもう一つ仮定を入れなければいけません。仮定は、クエリをオフラインで見れることです。 アイデアとしては、クエリごとにダブリングをするのではなく、ある桁に対するダブリングを全クエリ一斉に処理してしまおうというものです。next dpをダブリングに適用するといった表現が適切かもしれません。一旦使った桁のテーブルはもう捨ててよいので、副産物として、空間計算量からlogKが落ちます。データを捨てようとすると、自動的に弱い改善を利用する必要があるため、二重にお得です。 口頭の説明だけだとかなり厳しいと思ったので、実装のイメージも載せておきました。興味のある方は後で見てみてください。 結果です。劇的に早くなったことがわかるかと思います。なんと、全言語500msを切ることができました。地味に空間計算量が落ちるのもうれしいポイントです。 まとめです。 今回提案する定数倍改善は「添え字入れ替え」と、「クエリ処理のオフライン化」です。添え字入れ替えは既存のコードを少し変えるだけで入れることができます。原理が謎というデメリットはあります。オフライン化は、かなり効果がありますが、オンライン必須のときは使えませんし、実装も少し変える必要があります。 おや？駄々っ子が「オンラインアルゴがいい」と言っているようですね。 おっと、どこかで見たことのあるロボットがアドバイスをくれています。 はい、しょうもないネタを入れてしまいましたが、実はダブリングしなくてもこの問題は解くことができます。 Kに依存せず、オンラインで、クエリlogNで、それなりに手軽に解くアルゴがあります。 第三の定数倍改善「ダブリングをしない」に関して、私のブログの方で解説を書いていますので、興味のある方は是非ご覧ください。 以上、InTheBloomの発表でした。ご清聴、ありがとうございました。 スライドは私のXで公開しています。 その他 ユニークビジョンの写真を撮りました。Belugaって書いてあるのが現地です。 場所は新宿駅から近いものの、微妙に行き方がわからない場所だったので地図片手にウロウロしてました。寒かったです。 登壇は私以外にも数人いました。 あまり知らない分野の話が聞けました。 LT会がひと段落したらピザと銀の皿の寿司が出てきました。 醤油をつけるのが面倒だったので、寿司を全てプレーンで食べました。プレーンで食べてもおいしかったです。 宅配ピザ食べたの多分数年ぶりです。 パソコンポチポチしてたらおいしいご飯にありつけたので、こんなの許されて良いのか\u0026hellip;？って気持ちでした。 2、3人ほど知っている方がいたので、お話していました。会話スキルなさ過ぎて苦しかった。お互いあまり知らない状況で会話をするのって難しいなと毎度思います。 一番の収穫はD言語Language owner上位の方(名前は伏せます)とお話しすることができたことです。 D言語に関して話をすることって普段ないので、とても楽しかったです。 writeflnに%(%s%)を渡すことで配列の出力ができるという仕様を教えてもらいました。 全体的に楽しかったです。 あと、登壇を通してXのフォロワーが結構増えました。 フォローしてもらえるのはうれしいのですが、あのアカウントはあまり大きくしたくないのでちょっと困ってます。"
  },
  {
    url: "/post/2024-final/",
    title: "2024年を振り返ろう + 怪文書",
    date: "2025-01-01T00:00:00+09:00",
    body: "2024年を振り返ろう + 怪文書 まえがき 2024年も終わりがやってきました。 昨年に引き続き、振り返りとポエムを書こうかなと思います。 見やすい感じにまとめたかったんですが、markdownから変換している都合上、割と見にくい感じになりました。許してほしいです。 あと後ろの方のしょうもないやつを書いていたら2025年になってしまいました。まあ良いということにしておきます。 今年の出来事 自分のTwitterの投稿を見返して思い出したこと限定です。多分色々漏れています。 1月 streak365日達成 ツイート 正直結構嬉しいです。 もう少し続けます。 pic.twitter.com/6D0AqeNXGV \u0026mdash; In (@UU9782wsEdANDhp) January 2, 2024 OUPCにオンラインチームで参加(with dyktr_06さん) めちゃくちゃキャリーしてもらった ツイート OUPCやきとりさんと出てました。 606点54位。 AとC以外の100点は全部解いてもらいました... 部分点拾い楽しかったです。 pic.twitter.com/1V6lm1eXdr \u0026mdash; In (@UU9782wsEdANDhp) January 6, 2024 1000+AC達成 ツイート solved 1003 problems! 引き続き頑張ります～ pic.twitter.com/sKDpfPNjrL \u0026mdash; In (@UU9782wsEdANDhp) January 20, 2024 2月 まちカドまぞく一気見+散財 ツイート まちカドまぞく、コミックス全巻+アンソロジーコミック+アニメ24話全部見てしまいました。 なんだかんだ7000円くらいぶっこんでしまった。 近いうちに感想エントリを生成したい。 \u0026mdash; In (@UU9782wsEdANDhp) February 15, 2024 debianを使い始める 尺取り法を学ぶ 3月 20歳になった ツイート 20歳になりました。https://t.co/uvPuHnlKWH \u0026mdash; In (@UU9782wsEdANDhp) March 1, 2024 水以下コンテストオンサイト参加(with kariafluoridoさん) キャリーしてもらった2 カスみたいなオーバーフローで1問落としたのと、当時は桁dpが解けなかった。 ツイート(kariafluoridoさん) 水以下コンテスト@UU9782wsEdANDhp さんと現地でチームを組み全体35位でした。自分はE,I,J,Kを担当しました。 pic.twitter.com/Kihimecnez \u0026mdash; kaliafluorido (カリア) (@kaliafluorido) March 30, 2024 4月 MMA Contest 018オンサイト参加 coindarwさん、話しかけてくれてありがとうございました。 暇だったので最後までいました。居残りは実験Aを思い出すなと思った。 ツイート MMA Contest 018参加記録 + 怪文書https://t.co/i1eRJdcMOk \u0026mdash; In (@UU9782wsEdANDhp) April 3, 2024 UECバチャ発足 初回は席が足りなくて膝立ちで参加しました。膝なくなるかと思った。 5月 dynamic segment treeという多機能binary trieみたいなものを作った かなり振り回せる。おすすめです。 ツイート ここ数日ずっとDynamic Segment Treeをこしらえているのですが、どうやってもC++実装より大幅に遅い + メモリ使用量デカいになります。 D言語/動的セグ木に詳しい方、アドバイスいただければ非常に助かります。https://t.co/6gSVMm3Fts \u0026mdash; In (@UU9782wsEdANDhp) May 3, 2024 入青チャレンジ#1(失敗) ここから約半年の間水色にとらわれることになります。(なりました。) ツイート 水-\u0026gt;青の昇格戦でしたが、-52食らいました😱😱😱 数学ができません... \u0026mdash; In (@UU9782wsEdANDhp) May 19, 2024 寿司打高級コース1万円お得達成 テキトーに遊んでたら達成してしまって、マジか！？って感じだった。 結局寿司打はミス率ゲーだということにようやく気がつく。 ツイート 折角cedに来たんだからHHKBを堪能しておくか...と思って適当に寿司打を遊んだらまさかの自己ベスト + 10000お得達成してしまった！ タイピングを集中的に練習していた時期に達成できなかったというのに... HHKB買えというお告げなんだろうか？ pic.twitter.com/XjFy0J0Vm8 \u0026mdash; In (@UU9782wsEdANDhp) May 24, 2024 Interactive Sortingを通す ムズすぎです。本番はこれ出さないでください。 ツイート Interactive Sortingやっと通した... (N,Q)=(5,7)のケースで最悪8手からどうやっても減らせなくて kyopro_friendsさんの解説https://t.co/OMVF99mXrJ をガン見したけどそれでも相当しんどかった。 一般のNに対して真に最適な手順を構成するアルゴってどうなるんだろう。(何もわかりません。) pic.twitter.com/1aC3vlFrmQ \u0026mdash; In (@UU9782wsEdANDhp) May 30, 2024 6月 Tech Circle Expo2に潜入 ryotaさんに誘われたので行ったけど、技術系サークルに所属していないのでガチの不審者だった。 ツイート 技術系サークルと一切接点がない人間がTech Circle Expo 2に行ってきました。農工大、看板が少なくて困りました。 漢字の話が印象的でした。JIS2級水準まではサポートすると良いそうです。 ryotaさんとvim話をするのも面白かったです。 \u0026mdash; In (@UU9782wsEdANDhp) June 15, 2024 ICPC国内模擬予選出場 何もできなかった。俺は弱い\u0026hellip; 過去問を共有する問題と長方形の数え上げが解けなかったのが印象的。 7月 ICPC予選(チーム: A Certain Array Index) 4ACで予選落ちした。結構悲しかった。 参加記書くって言ったんだけど、どうしてもやる気がなくて結局やらなかった。 交流してくれた方、ありがとうございます。夕食をご一緒させていただきました。よければまた誘ってください。 友人(参加者)にお前有名だなみたいなこと言われてちょっと気恥ずかしかった。有名ではないです。(断言) ツイート ICPCお疲れさまでした。チームA Certain Array Indexで出ました。土日中には参加記録を書こうと思います。 \u0026mdash; In (@UU9782wsEdANDhp) July 5, 2024 8月 UECバチャシーズン1終幕 ARCに嫌気が差しはじめる 負け続きでかなり精神的に参っていた。 MMA Contest 019オンサイト参加 コミュ力低過ぎて話しかけに行けず、やきとりさんのストーカーをしていた。 参加記サボりました。すみません\u0026hellip; 行列累乗解けて良かった。45度回転は未だに納得いっていません。 ツイート MMA Contest 019行きます。がんばります。 \u0026mdash; In (@UU9782wsEdANDhp) August 24, 2024 Maximum Cup 2024オンサイト参加(チーム: Miles、with manabeaiさん, KA37RIさん) 謎の最短経路問題を解いたのが印象深い。 ツイート #MaximumCup2024 チームMiles(KA37RI、InTheBloom、manabeai)で戦いました。全員一問以上満点を出すことが出来て、すごく良かったのではないかなと思います。 運営ありがとうございました。 \u0026mdash; In (@UU9782wsEdANDhp) August 31, 2024 9月 原神、魔神任務のムービーまとめ動画に感動(未プレイ勢) こういうのに弱いです。誰かおすすめ教えてください。 ツイート 原神やったこと無いんですが、youtubeで流れてきた魔人任務？みたいなやつのムービーまとめ動画がめちゃくちゃよくてびっくりした。 \u0026mdash; In (@UU9782wsEdANDhp) September 12, 2024 CodeForces 1600達成 正直あまり思い入れがない\u0026hellip; ツイート 今見たらCodeforcesのレートついに1600乗っていた。うれしい～ \u0026mdash; In (@UU9782wsEdANDhp) September 14, 2024 まんがタイムきらら展に行く(池袋) すごく人多くて疲れた。 桃シャミを見に行くついでに他のまんがも見てきた。 伊藤いづも先生の描き下ろしまんがはシャミ子が桃の家にご飯を作りに行くというやつだった。めしたきまぞく ぼっち・ざ・ろっくがきらら漫画だということを初めて知った。 グッズほしかったけどありえないくらい並んでたので帰った(涙) まちカド次の単行本待ってます。アニメ3丁目も頼みます。マジで。 ツイートと写真 まんがタイムきらら展に行ってきました。 まちカドまぞくしか知らんマンだけど楽しかったです。 グッズ販売の列がありえん長かったので諦めて退散しました。(悲しい) \u0026mdash; In (@UU9782wsEdANDhp) September 21, 2024 10月 メルカリ主催コンテストオンサイト参加 建物がすごく立派だった。 E問題、解法は合っていたのによくわからない2WAが出てしまった。 やきとりさんのストーカーをしていた2(いつもありがとうございます。) ツイート メルカリコン行きます。 登録した情報を忘れたので受付でバトルが発生しないか非常に心配... \u0026mdash; In (@UU9782wsEdANDhp) October 5, 2024 緑以下コンテストオンサイト参加 全ACを狙っていたんですが、少し力及ばずという感じでした。 \u0026lt;=\u0026gt;を潰していく問題が難しかった。ランレングス圧縮が見えなかったのでかなり強引に探索で通した。 演算子でfoldしていくみたいなやつは楽しかった。経路探索みたいなやつは変なケースにハマって最悪だった。 人への話しかけに成功した。やってみるもんですね。 ツイート 緑以下コンテスト 9AC + 1AC(2分遅刻)でした。 全完にはまだ実力が足りないみたいです。 ありがとうございました。 \u0026mdash; In (@UU9782wsEdANDhp) October 12, 2024 functional graphのトレスを\u0026lt;NlogN, logN\u0026gt;でやるやつを作った オススメです。 ツイート 新作です。これ、地味だけど割と良くないですか？https://t.co/7SeHxywpt2 \u0026mdash; In (@UU9782wsEdANDhp) October 19, 2024 11月 筑波大学プログラミングコンテストオンサイト参加(チーム: MM_In_gori、with MMさん, ごりちゃんさん) マジで何もできなくて、かなり落ち込んだ。(一番簡単なやつを任せてもらった。) とにかく遠かった。交通費もヤバかった。 ツイート 筑波コン行きます。筑波遠いよ〜 \u0026mdash; In (@UU9782wsEdANDhp) November 16, 2024 AtCoder(Algorithm)でレート1600達成 青色は自分が思っていたよりも何倍も遠かった。決して楽ではなかった。 ツイート ついに...1600到達です...！https://t.co/sCpKOHxIcv \u0026mdash; In (@UU9782wsEdANDhp) November 22, 2024 12月 UEC Advent Calendar 2024でY-Fast Trieを書いた 何気にtreapも書いたしハッシュマップも書いた。このあたりの知見はどこかで書く予定。 ツイート BSTより高速なデータ構造: Y-Fast Trie [UEC Advent Calendar 2024] 12日目https://t.co/IxULVJASPg \u0026mdash; In (@UU9782wsEdANDhp) December 12, 2024 アニメを見た(おにまい、小林さんちのメイドラゴン) 良いですね〜 ツイート おにまいを一気見してしまった。かなり良かった。 誰か私に日常系アニメをオススメしてください。 \u0026mdash; In (@UU9782wsEdANDhp) December 27, 2024 小林さんちのメイドラゴン14話全部見た。 こっちもかなり良かった。数日中にSの方も見ます。 \u0026mdash; In (@UU9782wsEdANDhp) December 30, 2024 総括 全体的に去年よりアクティブに活動した気がします。 2023年の年末にレート1600とICPC予選通過を目標に掲げました。レート1600の方は達成できてよかったです。 ICPCの方は引き続き2025年の目標ということにします。 2025のレート的な目標は、1600以上を維持することです。(2025年中に黄色は無理やろなぁと) 2024年私に関わってくれた皆様、ありがとうございました。 2025年も仲良くしてくれると嬉しいです。 怪文書 真面目なことは全部かいたので、後は普段かけないことを書いてみます。 人によっては不快になるかもしれません。ご了承ください。 思想1 「やるだけ」という単語が嫌いです。 この単語は他人の考察の軽視や問題の軽視を含むと考えるからです。 なので、私の問題の感想には含めたことはありませんし、今後も使うことは無いです。 (思ったとしても、どこかに書くべきでないと思っています。) では私にとって理想的な問題の感想は何であるのかというと、その人の思考の道筋がわかるようなものです。 ただし、思考は理論的である必要はありません。問題を解くときに考えたことを書けばよいのです。 もし自分にとって十分に明らかな事実により解けた場合、「初手で解法が見えた」などと言えばよいのです。決して「やるだけ」と書くべきでありません。代替案に納得がいかない場合、そもそも感想として触れるべきでないのでしょう。 感想として触れるべきでない根拠ははっきりしていて、誰の得にもならないからです。 他人目線: 情報量0なので意味がない。なんなら負の感情を抱かれるかも。 自分目線: 「やるだけ」のせいで全体の情報の密度が落ちるため、データベースとしての価値が減る。 思想2 SNSにアイコンを設定するのが嫌いです。設定するなら自分の写真ないしは自画像にすべきだと思っています。 もちろん私も好きなコンテンツなどをアイコンに設定したいと思うこともあります。しかし、それをやってしまうと(特に知性体のアイコンだと)自分の発言を自分以外に代弁させているように思えるからです。 なので、自分の別人格としてオリジナルキャラクターを用いるか、完全ななりきりを目指す場合はこの限りでは無いと思っています。 なぜこれが嫌いなのかについて、はっきり理由があるわけではありませんが、他人に自分の人格を被せようなんて行為がおこがましいと考えているからです。 ただし、これらは見出しに書いてあるとおり、これはただの私の思想なので、好きにすると良いと思います。 ARCについて 2年ほどやってきて、私が好きなのは天才パズルを解くことではなく、きっちりネタが割れている(できれば)難しい問題を体系的に理解し、サクサク倒すことであると気が付きました。 ARCに出なくなったのはこれが理由です。今の知識レベルのままでは解法にたどり着くまで運ゲー or 三捻りくらい必要で、これはやりたいことでは無いと思いました。(今のままではupsolveすらおぼつかないため、多分意味がない) 当分はABCやARC、それらに類する問題で知識や実装力を蓄える予定です。 ARC-AやARC-Bの一手目が見えるようになるか、ABCのrated帯を外れるまではARCでratedはやりません。(unratedはやるかも) 競技プログラミングを初めたときは、ARCもいずれ見えるようになると思っていましたが、2年やってきて未だに一ミリも見えないので結構絶望感があります。ARC訓練を重ねれば見えるようになるんでしょうか。 思うこと 2024年は電通大競プロサーバというdiscordでそこそこ精力的に活動しました。でも、正直結構から回っている気がしてなりません。たまに拗ねてアクティブな活動をやめようかとも思うときがありますが、とりあえずしばらくは活動しようと思います。なんせ暇なので\u0026hellip; あと、今年は競プロ関連で多少人付き合いがありました。そのたびに自分の人付き合いスキルのなさに絶望してしまいます。皆さんは普段どんな会話をしているんでしょうか。競プロ話をしようにも、よく考えると何も話すことがないことに気がついてしまいました。ABC-Eむずかったっすねーと言って、そうですね。と帰ってきて、それで終わりです。わりと困っています。会話の典型90ください。 ここからはアニメ感想を書きます。書く機会無いので。全体的にキモい仕上がりになりました。あんまりバカにしないでくれると助かる。 耐えられない人は見なかったことにしてほしい。 まちカド感想 ほぼ初めてのまともに見たアニメです。 まずすべてが可愛いです。 それだけではなく、妙に語彙力高いところや、急に現実的になるところがギャグとして十分面白いです。 ストーリー間に緩やかなつながりがある一方、前提を踏まえていないとわからないほどでもないゆるい感じが自分好みでした。 シャミ子と周りのキャラクターの絡みも微笑ましい限りです。 また、キャラクターひとりひとりも非常に魅力的に感じます。 桃: 完璧超人でなく、しょうもないところに欠点があるというのがとても刺さりました。(完璧超人は嫌いなので。)書いてて思い出したんですが、闇堕ち設定も厨二心をくすぐられて良いです。あと、桃の過去にも注目だな〜と思います。ついでに貯金額も気になる。魔法少女の給料ってどこから来てるんですか？みかんが大して金持ち感無いところを見ると、ワンチャン討伐カード換金した？あと、おしゃれした回は必ずポシャるのかわいそうですよね。 優子: アホキャラみたいな立ち位置にいますが、謙虚にベストを尽くす姿勢が好きです。逐一行動がかわいいのはズルいと思います。ききかんり〜！は結構お気に入りです。私も危機管理やってみたいです。逮捕されそう。 良子: 色々と真実を知ったらなんて言うんでしょうか。今後小倉枠として活躍してほしいです。あと作中では珍しくパソカタ勢なのが良いですね。aviutilとか触ってそう。(偏見)いまではYMM4なんですかね。 リリス: なんだかんだ頼れる存在ですよね。アニメ版では声がハマっていて良いなと思いました。桃との信頼関係がめっちゃいいですよね。あと、こういう悠久の時を生きる系のキャラクターは大好きなので、リリスさんも大好きです。邪神像(hdmiポート付き)ほしすぎる。本編とは関係ないですが、アンソロジーコミックの最後の方に乗ってるリリスさんの話が大好きです。あれ全人類読んでほしい。 みかん: 実はウガルル関係の話そんなに好きじゃないのでちょっとアレです。今後の展開に期待。でもみかんをみんなで救出するところは割と好き。 リコ: 実はあんまり好きじゃないかも。一回相当痛い目にあってほしい。いや、やっぱり程々で良いです。 キャラクターはこのあたりで.. 桃やシャミ子が少しづつ前に進んでいくという構成がめっちゃ好きです。 桃がシャミ子と関わることを通じて、少しづつシャミ子と町を守りたいという感情が芽生えてきます。シャミ子も桃や町の秘密を知るうちに町を守りたいと思い始めます。このあたりの場面が良いなぁと思います。 思うんですが、現状シャミ子が(ズルイブキ含めて)弱すぎるのと、那由多誰何が危険すぎるという点でメチャクチャヒヤヒヤしています。まぞくが消されている過去回想はガチで作者入れ替わった？と思ったし、「コロチュ」のやつは初見でゾクッとしました。どうにか犠牲者なしで終わってほしいっす。(きららだし、なんなら誰何もこっち側に取り入れるかも？) 全く関係ないですが、聖地巡礼するか〜と思って調布から聖蹟桜ヶ丘までウォーキングしたことがあります。しかし、あまりに遠くて到着したときには瀕死になっていました。またリベンジしたいです。 あと秋葉原のどっかにまちカドグッズが実店舗においてあったので共有しておきます。 なんにせよ新刊とアニメ3期まじでお願いします。1万円くらいなら出します。 おにまい感想 全体的に背徳感ヤバいアニメでした。これ見て良いやつなんですか？？ 作画がかわいくて好みです。目が結構特徴的ですよね。 以下キャラクターに関して まひろ: 私もインドア派なので親近感わきます。まひろが引きこもった原因についてはもう少し深堀してほしかったかなと言う気持ちもあります。(みはりの考えと逆になっているのが悲しいですよね。)TS後のまひろはだいぶかわいいのでずるいなと思いました。これってもとが良いってことなんでしょうか。 みはり: 相当なブラコンだなぁと思いました。私は兄弟がいますが、お互い可能な限り不干渉みたいな感じになっています。あと、結局TS化計画は研究の一環なんでしょうか。TS薬って相当なオーパーツですよね。(見かけだけでなく、完璧なTSを行うのって、人間のクローンなんてレベルじゃないと思うんですが、、ヤバすぎて逆にノーベル賞取れなさそうだし命狙われそう。)まひろだけだと一ミリも話が進まないので、物語的にはかなり都合がいい存在ですよね。でも酔うと人格が変わるという設定はあまり好きではないです。もうちょっと、こう、抑えてほしいっす。 かえで: 本来これ系のキャラクターはそんなに好みではないんですが、結構好きです。みはりとの絡みがいい感じですよね。 あさひ: 優しいなぁ〜と思いました。知らんやつの買い物手伝ってあげたり大量のエロゲなどを片付けるの手伝ってくれるの優しいよね。あと、逆ルカ子(シュタゲ)ですよね。初見男のキャラだと思いました。それはそれとしてまひろの部屋って相当不衛生そうだけど匂いとか大丈夫だったんでしょうか。みはりが掃除していたんですかね？まひろとの絡みを見ていてﾆｺﾆｺしていました。 私はハッピーエンド厨なので、まひろの精神状態が少しづつ改善していくというのがとても好みです。いきなり鬱展開になったりしなさそうなので安心して見れました。ありがとうございます。 序盤のみはりが何から何まで指南していくあたりが結構好きです。髪を5分くらい乾かすそうです。大変だね〜と思うなどしました。おにまいに影響されて身だしなみを少し整えようかなと思いましたが、よく考えるとそんな必要なかったです。ボサボサ頭で許される環境で助かった。 おにまいはアニメしか見ていないのでかなりミーハーなんですが、正直相当刺さったので単行本全部買おうかと画策しています。アニメ二期が出たら必ず見ます。 メイドラゴン感想 これも基本平和だったので安心して見ていました。 個人的に「アニメ声」みたいなやつ苦手だったんですが、トールなら全然許せました。チョロゴン 小林さん: python使いなんですねというのが第一感想です。importで例外キャッチ書いていたのが印象的です。どうやらImportErrorってのがあるみたいですね。python知識を手に入れる羽目になるとは思いませんでした。個人的には酔ったときに豹変するという設定はあまり好きではないんですが、アレがないとトールが来なかったという事情を加味するとまあ許さなくもないという気持ちです。小林さんも完璧超人からは遠い部分があり、好みだったりします。(一人で暮らしてたら多分生活習慣病になってただろうなと) トール: かなり好きなキャラです。こちらは完璧超人寄りですが、まあドラゴンなので良いということにします。なんでそんなに小林さんになついているんでしょうか。あの剣抜けなかったら死んでたということなんでしょうか。OPのフラクタルトールがお気に入りです。 カンナ: ガチでやったらメチャクチャ強いはずなのに、小学校にいるときはガチっぽく手を抜くのでどっちが本当かよくわからなくなります。かわいいです。 エルマ: なんか、もうちょっと活躍してほしかった。ずっと食べてるな〜という印象。OOPの本を読んでいるシーンがありましたが、エルマもpython使いなんでしょうか？さすがは調和勢と言ったところで、トールのサポートなしに順応していてスゲーという感じです。タッチタイピング私は半年くらい練習が必要だったんですが、エルマは爆速で習得していましたね。 ルコア: 結局、どういう身分のドラゴンなのかよくわからなかったんですがなんなのでしょうか。とりあえずエライっぽい？ちょい苦手キャラ。 ファフニール: 一日21時間ゲームしているそうです。ヤバすぎる。AtCoderやらせたらありえない速度で赤コーダーになりそう。んでもってWTFに出なさそう。よかったら競技プログラミングやりませんか？という感じ。相当人間嫌いなようで、滝谷はよくこいつと同居できるなと思う。あと、呪いの同人誌買う人いそうだけどなぁと思いました。 滝谷: メガネどこから出てきてるんでしょうか。あと歯はどこに消えてるんでしょうか。滝谷は食になんのこだわりもなさそうなのでトールのしっぽ肉も普通に食べそう。(トールがメチャクチャ嫌がりそう。)いい人そうなので結構お気に入りです。 正直トールとカンナと小林さんが絡んでるの永遠に見てられる。結構気に入りました。アニメもう一つあるみたいなので、数日中に見る予定です。漫画も買おうかな。そこそこ巻数ありそうだからちょっと置き場所に困るかも。 終わりに 2024年は結構波乱の年でした。2025年も引き続きそんな感じになりそうなので、程々に頑張りたいです。 あんまり校正とかしていないので、誤字脱字等あればこっそり教えてください。"
  },
  {
    url: "/post/uec-advent2024/",
    title: "BSTより高速なデータ構造: Y-Fast Trie [UEC Advent Calendar 2024] 12日目",
    date: "2024-12-12T00:00:00+09:00",
    body: "BSTより高速なデータ構造: Y-Fast Trie [UEC Advent Calendar 2024] 12日目 まえがき こんにちは、 InTheBloom です。 今年もUECアドカレの季節がやってきましたね。Twitterでカレンダーが生えたのを観測したので、これ幸いと枠をいただきました。これで3年目になります。 このエントリはUEC Advent Calendar 2024の12日目を担当します。 遅刻しました。すみません！ また、今年もUEC2が建っています。こちらもぜひどうぞ。 11日目はえぐちさんの Proxmoxの運用Tips【自宅鯖】 でした。 自宅鯖という単語、非常に魅力的に感じます。とは言いつつ、前提知識がなさすぎて大半が呪文に見えました。勉強が必要そうです。 UEC2ははんかくさんが担当ですが、まだアップされていないみたいです。 今年も力作ぞろいです。これからのエントリも楽しみですね！ はじめに このエントリでは、Y-Fast Trie(ワイ-ファスト トライ)と呼ばれるデータ構造の動作原理を説明し、実際に組んだものを示します。 Y-Fast Trieの美しさ、ロマンを体感してください！ 誤りの指摘は随時募集しています。指摘いただいたものは随時修正していきますので、お気軽にどうぞ。 一部、厳密性にかける部分があるかもしれません。 このエントリの情報は裏を取ってから使用することをお勧めします。 Y-Fast Trieの概要 Y-Fast Trieは非負整数値に対して各種操作を提供するデータ構造です。 データ構造とは何かについて厳密に定義を与えるのは難しいです。 ここでは、大まかに、できる操作の集合と、操作を実現する具体的なアルゴリズムをひとまとめにしたものをデータ構造と呼ぶことにしましょう。 前者をインターフェース、後者を内部実装と呼ぶことにします。 性能を議論する上で、各種操作をどれくらい効率よく、どれくらい省メモリで行えるかが知りたいです。 そこで、本文書内ではインターフェースを考えるとき、同時に各種操作の時間計算量と、データ構造全体が必要とする空間計算量に言及します。 計算量というのは、かかる時間や必要な領域を定量的に評価するための概念です。 詳細は 計算量について(外部リンク) を参照してください。 例えば、C++のstd::vectorは $i$番目の要素への読み書き: $O(1)$時間 要素を末尾へ挿入: 平均して$O(1)$時間 というインターフェースを提供するデータ構造です。空間計算量は、確保した列の長さ$N$に対して、$O(N)$です。 空間計算量が$O(N)$であるとは、格納した値や補助のデータを含めて$O(N)$byteしか必要としないことを表します。 Y-Fast Trieのインターフェース Y-Fast Trieは、扱う整数の範囲を$\\lbrack 0, 2 ^ w - 1 \\rbrack$としたとき、以下のインターフェースを提供します。 操作 内容 時間計算量 $\\mathrm{insert}(x)$ 集合に$x$を追加する $\\text{expected } O(\\log(w))$ $\\mathrm{remove}(x)$ 集合から$x$を削除する $\\text{expected } O(\\log(w))$ $\\mathrm{successor}(x)$ 集合に含まれる$x$以上最小の値を返す $\\text{expected } O(\\log(w))$ $\\mathrm{predecessor}(x)$ 集合に含まれる$x$以下最大の値を返す $\\text{expected } O(\\log(w))$ $\\text{expected}$という表記はその操作にかかる時間が確率変数で表現されることを表します。値はその期待値です。 このインターフェースは predecessor problem と呼ばれる有名な問題そのものです。 通常、内部実装として 赤黒木 や AVL木 といった二分探索木が使用されます。二分探索木を使用する場合、各操作は全体の操作回数を$N$として、$O(\\log(N))$時間になります。 一方、Y-Fast Trieは$N$に依存することなく、常に$O(\\log(w))$時間を保ちます。 $w$は整数を表現するのに必要なビット数であり、ほとんどのケースで$w \\leq 64$になります。自然な仮定の元ではY-Fast Trieは二分探索木よりも理論的に高速です。 驚くべきことに、Y-Fast Trie空間計算量は$O(N)$です。 扱う値を非負整数に絞ることにより、二分探索木と同等レベルに省メモリかつ、確率的な平均計算量として見たときに、二分探索木より高速な操作を提供します。 前置きはここまでです。次の章からはY-Fast Trieの動作原理を見ていきましょう。 Binary Trieとsuccessorの探索 グラフ Y-Fast Trieの仕組みを理解するためには、trie木を知る必要があります。 trieはグラフの一種です。グラフとは、頂点集合$V$と頂点間を結ぶ辺集合$E$の組のことで、ものともののつながりかただけを抜き出した数学モデルです。 これがグラフです。この場合、頂点数が6で、辺数が8です。 Graph Editor でビジュアライザを試すことができます。 プログラム上でグラフを表現するときは通常、隣接リストを用いた表現を使います。 これは、各頂点に対応する構造体をつくり、辺を別の構造体へのポインタで表すものです。 以下に疑似コードを示します。 struct vertex { // vertex: 「頂点」の意 Data data; // 頂点番号や、それ以外の値をもたせることもある vertex *[] adj; // 自分から辺がある頂点へのポインタ // その他、辺に重みをつけることもある } うまく実装すると、$O(\\vert V \\vert + \\vert E \\vert)$の空間でグラフを表現することができます。 trie木 trieは、文字列の集合を表現する木です。 これがtrie木です。この木の場合、\u0026ldquo;A\u0026rdquo;, \u0026ldquo;to\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;ted\u0026rdquo;, \u0026ldquo;ten\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;in\u0026rdquo;, \u0026ldquo;inn\u0026quot;から構築されています。 wikipediaの トライ からパブリックドメインの画像をお借りしました。( source ) trie木は常に次のルールに従っています。 根と呼ばれる「スタート地点」をもつ。 各辺には文字が割り当てられる。 根は空文字列を表現する。他の頂点は、根からそこまでたどったときに通った辺の文字を連結した文字列を表現する。 trieに文字列を追加するときは、根から出来るだけ既存の頂点を経由して文字を伸ばしていけばよいです。(図A) 図A: \u0026ldquo;int\u0026quot;と\u0026quot;teny\u0026quot;の追加 削除するときは、その文字列を表現する頂点からはじめて、他の文字列に影響しない部分の頂点を削除しながら根までのぼっていけばよいです。(図B) 図B: \u0026ldquo;inn\u0026quot;と\u0026quot;ten\u0026quot;の削除 これらの操作は文字列$S$に対して$O(\\vert S \\vert)$時間で行うことができます。したがって、trieは文字列の集合に対して次の操作が可能です。 $\\mathrm{insert}(S)$: 文字列$S$を集合に追加する。$O(\\vert S \\vert)$時間 $\\mathrm{remove}(S)$: 文字列$S$を集合から削除する。$O(\\vert S \\vert)$時間 $\\mathrm{find}(S)$: 文字列$S$が集合に含まれるか確認する。$O(\\vert S \\vert)$時間 また、数を任意の進数で表現すると、文字列としてみなせるため、数に対しても$\\mathrm{insert}, \\mathrm{remove}, \\mathrm{find}$を行うことができます。 jumpポインタと葉ノードの連結によるsuccessorへの対応 この先はtrieで数を扱うことを前提とします。留意してください。 簡単のため、trieで扱う数の基数を2に固定します。 これによりtrieの各ノードは高々2本の辺を持つことになります。これを特にbinary trieと呼びます。 また、扱う数を高々$w$文字で表現できると仮定し、最上位bitが1文字目に来るようにします。$w$文字に満たない場合はleading zeroをつけて対応します。 つまり、$w = 5$のとき、0は00000、3は00011、5は00101という文字列として扱います。 今導入した最上位bitから順に並べるルールにより、次の性質が保たれます。 すべての葉は同じ高さにある。 任意のノードについて、$(\\text{左に進んでからたどり着く任意の葉の値}) \u0026lt; (\\text{右に進んでからたどり着く任意の葉})$が成立 binary trieの例 だんだん二分探索木っぽくなってきました。 葉を左から見たときに値の昇順になるため、$\\mathrm{successor}(x)$や$\\mathrm{predecessor}(x)$は$x$を表す葉のすぐそばに存在します。 ここにさらにもう一工夫を行うと、ようやく$\\mathrm{successor}, \\mathrm{predecessor}$に対応できるようになります。 葉ノード間に辺をはり、連結リストのようにする。 子をひとつしか持たない中間ノードから、successorやpredecessorのすぐ近くになるはずの葉にジャンプ辺をはる。 左右辺とジャンプ辺をはったbinary trie 一つ目についてはわかりやすいと思います。つまり、葉ノードだけ特別に「左右方向」の辺を持たせて、ひとつ大きい要素とひとつ小さい要素に飛べるようにするということです。 二つ目は、それそのものとしてはそこまで役に立ちません。葉の連結リスト化を動的に行うための補助データという役割が大きいです。「すぐ近くになるはずの葉にジャンプ辺をはる」というのは、具体的には、次の二つのどちらかを行います。 左の子を持たない場合: 右部分木最小の葉へジャンプできるようにする 右の子を持たない場合: 左部分木最大の葉へジャンプできるようにする これで$\\mathrm{successor}(x)$と$\\mathrm{predecessor}(x)$に答える準備ができました。 このジャンプ辺と連結リストを利用して、次のように解答します。(両者ほぼ同じなので、successorのみ説明します。) $x$を2進表示した文字列を用いて、すでにある頂点をできるだけたどる。 葉にたどり着くことができれば、$x$を返却して終了。 左方向に進めない場合、$\\mathrm{successor}(x)$はその頂点のジャンプ辺でたどり着く頂点である。右方向の場合、ジャンプ辺でたどり着く頂点よりひとつ大きい頂点である。 例として、上図のtrieにおいて$\\mathrm{successor}(6)$を呼び出すとどうなるか見てみましょう。 6は0110なので、根から左、右と進みます。次に右に進むべきですが、辺がありません。そこで、ジャンプ辺を利用して左部分木最大の0101(5)にジャンプします。ここから連結リストで一つ右に移動し、1101(13)を手に入れることができます。図より、正しい解が返ってきていることがわかると思います。 計算量はやはり検索文字列の長さに依存し、$O(w)$時間です。 残る問題はどうやって要素の追加/削除時に連結リスト及びジャンプ辺を正しく保つかとなります。 追加 まず、通常のtrieと同様に頂点を追加します。今までなかった値を追加するわけなので、辺のない方向に進む瞬間が必ずあります。 そのタイミングでジャンプ辺を利用し、追加する頂点のsuccessorまたはpredecessorを取得します。これを用いて連結リストを繋ぎかえます。 ジャンプ辺の更新も行います。ジャンプ辺は自身の部分木の頂点に飛ぶことになっていました。 逆に言うと、新しく追加した頂点から根まで登っていく際に通る頂点を更新できれば十分です。 新しく頂点を追加したことで子が2になった頂点はジャンプ辺を外します。 そうでない場合、ジャンプ辺が未登録であるか、または新しい頂点のほうが今よりジャンプ先として適切かを判定すればよいです。 1010の追加。紫のジャンプ辺を利用して連結リストに組み込む。(このジャンプ辺は追加後削除される。) 削除 まず、葉を連結リストから外します。 あとは通常のtrie同様に、葉からはじめて、もともと子が2だった頂点に出会うまで頂点を消していきます。(葉だけはまだ使うので、まだメモリ解放はしません。) 最後にジャンプ辺の更新を行います。これも追加のときと同様に、根までさかのぼる道中にいる頂点のみ更新すればよいです。 そのような頂点であって、もともと自分をジャンプ先に登録していた頂点に出会ったとき、新しくジャンプ先になりうるのは葉のひとつ前かひとつ後ろになります。 したがって、消さずにとっておいた葉の連結リストを用いて適切に更新すればよいです。 1101の削除。1のジャンプ辺が1101から1110へ更新される。 少々雑な紹介になってしまいましたが、基本的には登って下って以上の操作を必要としません。これらも$O(w)$時間で行うことができます。 まとめ 数を固定長さで最上位桁からみる文字列として扱い、葉ノード間の連結リスト、ジャンプ辺の概念を導入することで、binary trieは$\\mathrm{insert}, \\mathrm{remove}, \\mathrm{successor}, \\mathrm{predecessor}$を$O(w)$時間で行うことができる。 使用する領域は、ひとつの数あたり$O(w)$個の頂点が必要なため、$O(Nw)$となる。($N$が大きくなるほど新しく追加する頂点が減る傾向があることに注意。$N \\ll 2 ^ w$であるときは$O(Nw)$より厳しく評価するのが難しいはず。) X-Fast Trie 前章では、binary trieを用いた$\\mathrm{insert}, \\mathrm{remove}, \\mathrm{successor}, \\mathrm{predecessor}$への対応方法を説明しました。 基本的なアイデアはそのままに、少し拡張を加えることで、$\\mathrm{successor}, \\mathrm{predecessor}$の計算量を$\\text{expected } O(\\log(w))$時間に改善したデータ構造がX-Fast Trieです。 アイデア binary trieでは、検索を行う中ではじめて進めなくなる頂点を見つけ、その頂点のジャンプ辺を用いてクエリにうまく解答していました。 この「はじめて進めなくなる頂点」を高速に見つけられるようにします。 具体的には、各階層にハッシュマップを持って、今その階層にある頂点をすべて登録し、深さに対して二分探索を行います。 ハッシュマップとは、大雑把に言えば 要素の追加と削除 ある要素が今含まれているかどうか を$\\text{expected } O(1)$時間で判定するデータ構造です。より詳しいことはほかの情報源を参照してください。 X-Fast Trie。各階層の頂点を登録している。 二分探索について少し補足します。 ある検索キー$x$を与えられたとき、$x$の上位$k$bitがtrieに含まれているか？という問題を考えます。これは$k$について単調です。 すなわち、$k = 0$は必ず真ですが、ある$k = a$で偽になったとすると、以降真になることはありえません。この境界点を二分探索で探します。 境界点さえ見つかってしまえば、あとは$O(1)$回の移動で目的の葉を見つけることができます。 したがって、計算量は木の高さ$w$を$\\log$にしたものになります。binary trieからさらに減って$\\text{expected } O(\\log(w))$時間です。(ハッシュマップの$\\text{expected}$がこちらに影響してしまいます。) 例として、上図において1100を探すことにします。 まず、根を高さ0として、高さ2のハッシュマップを見ます。 高さ2のハッシュマップに11が含まれているので、より下の高さのみを考えればよいことがわかります。 次に高さ3に110が含まれているかを見ます。ここにもまだ含まれています。 最後に高さ4に1100が含まれているかを見ます。ここではもう含まれていません。 この時点で高さ3に含まれ、高さ4に含まれないことがわかっています。差が1なので、境界が見つかったことになります。 よって、最後に含まれていた高さ3のハッシュマップに、キー110で登録されている頂点からジャンプ辺で飛ぶとよいです。 各種操作 追加削除はbinary trieとほとんど同じです。ひとつ異なるのが、 追加操作で新しい頂点を作る 削除操作で頂点を削除する これらのタイミングでハッシュマップにも登録、削除を行う必要があります。 検索は上述したとおりです。 まとめ X-Fast Trieはbinary trieの各層にハッシュマップを導入したデータ構造である。 この工夫により、$\\mathrm{insert}, \\mathrm{remove}$を$O(w)$時間、$\\mathrm{successor}, \\mathrm{predecessor}$を$\\text{expected } O(\\log(w))$時間で行うことができる。 使用する領域は変わらず$O(Nw)$となる。(ハッシュマップはうまく実装されていれば$N$個のキー挿入時に$O(N)$領域しか必要ないため、binary trieと比較して定数倍しか膨らまない。) (補足: ハッシュマップは償却計算量が入ることがあると思いますが、このあたりを$\\text{expected}$などと合わせたときにどう扱うのかについて、文献を探しても見つかりませんでした。なので、基本的には期待計算量に含まれるという体で書いています。) Y-Fast Trie とうとうメインディッシュがやってきました。 X-Fast Trieは検索こそ早いものの、追加と削除が低速でした。また、使用する領域も二分探索木に比べて$w$倍大きいです。 この二つの問題は密接にかかわっています。trieへの要素の追加削除にかかる時間や使用する領域の大きさは、真面目にすべてのノードをtrieで扱うとすると高さが減らない限り減りません。 そこで、Y-Fast Trieでは、trie部分で扱うノードを効率的に間引き、残りの要素の管理を別のデータ構造に委託する戦略をとります。 アイデア Y-Fast Trieの性能が二分探索木の性能より良い理由は、$w \\ll N$であるからでした。 逆に言うと、$N$が十分小さいことが保証できる状況であれば、二分探索木を利用することができます。 また、二分探索木はtrie系のデータ構造と異なり、一つの要素のために$O(w)$領域を必要としません。 そこで、本来trie側で扱う頂点集合をいくつかのグループに分けて、ひとつのグループをひとつの二分探索木に管理させることにします。 こうすることで、二分探索木のメリットを全て享受することを狙います。 つまり、どうにかして下図の状況が常に成立するようにします。(三角形は二分探索木、上はX-Fast Trieです。) Y-Fast Trie。二次構造として、二分探索木を利用する。 X-Fast Trieに登録されている$O(N / w)$個のデータを昇順に$x _ 0, x _ 1, \\dots$とし、$x _ i$の場所にある二分探索木は、区間$\\lbrack x _ {i - 1}, x _ i \\rbrack$に含まれる数を管理するとします。 もし、挿入されるデータがあらかじめわかっていれば、$x _ i$としてどれを選べばよいかがわかります。 しかし、今回の問題ではどんな値が来るか先に知ることができません。 そこで、ランダム性を用いて解決します。 新しくキーを挿入するとき、確率$1 / w$でX-Fast Trieに新しい二分探索木を登録し、そうでないときにはおとなしく既存の二分探索木で管理することにします。 たったこれだけで、ある時点での二分探索木が管理するデータの数の期待値を$O(w)$個にすることができます。 二分探索木のサイズ解析の概要 簡単に概要を説明します。 ある時点において、Y-Fast Trie全体が管理するデータを昇順に$y _ 0, y _ 1, \\dots$とします。 ここで、$y _ i$を含む二分探索木の大きさは、$i$以前/以降ではじめて$1 / w$を引いた場所の二つで確定します。$i$より前を$p$、後を$q$とします。 これは、$i$からスタートして、確率$1 / w$でストップ、確率$1 - 1 / w$で次に進むという試行を右方向と左方向に行っていると考えることができます。 このようにして、$y _ i$を含む二分探索木が大きさ$k$をとるときの確率$p _ k$が算出することができます。各事象における確率がわかったので、大きさの期待値も計算できます。 そしてその期待値は$O(w)$になっています。 二分探索木のサイズがiから左右に伸ばした2点で確定することの視覚的イメージ 性能の解析 $\\mathrm{insert}$について考えます。確率$1 / w$でX-Fast Trieへの追加を行い、$O(w)$時間がかかります。 確率$1 - 1 / w$で対応する二分探索木に追加を行います。対応する二分探索木を探すのはX-Fast Trieの検索によって行うので、$O(\\log(w))$時間、二分探索木は大きさ$O(w)$程度であることが期待されるので、こちらも$O(\\log(w))$時間です。 よって、これらの期待値は$O(\\log(w))$時間になります。 $\\mathrm{remove}$を考えます。キーが含まれる二分探索木の検索、その二分探索木からの削除はともに$O(\\log(w))$時間です。 確率$1 / w$でX-Fast Trie側に登録しているキーを削除するケースを引きます。この場合、ひとつ右の二分探索木へ、自分の二分探索木をマージします。 ひとつ右の取得はX-Fast Trieの葉にある隣接リストを用いて$O(1)$時間で行うことができます。 二分探索木は$O(w)$個程度の要素を含むことが期待されるので、二分探索木のマージは$O(\\log(w))$時間、X-Fast Trie側のノードの削除は$O(w)$時間になります。 よって、こちらも期待値は$O(\\log(w))$時間です。 検索についてはすでに説明した通りです。 まとめ Y-Fast TrieはX-Fast Trieに$O(N / w)$個の二分探索木を持たせたデータ構造である。この二分探索木を追加するとき、それぞれが管理する要素の期待値が$O(w)$となるように工夫を行う。これらにより、$\\mathrm{insert}, \\mathrm{remove}, \\mathrm{successor}, \\mathrm{predecessor}$を$\\text{expected } O(\\log(w))$時間で行うことができる。 実装例 + 実測 ここまで、動作原理の説明に終始してきました。 しかし、実際に動作するように組み上げるのは原理を理解する以上に大変です。 今回、机上の空論で終わらせないために、実装にチャレンジしました。(想定通りものすごく苦戦して、アドベントカレンダーに遅刻してしまいましたorz) https://github.com/InTheBloom/YFastTrie 今回説明しきれなかったハッシュマップの実装や、二分探索木の実装もすべて含んでいます。 ある程度新しいD言語処理系をインストールした環境であれば実際に動かすことができます。 興味のある方は是非ご覧ください。 また、このような複雑なデータ構造は定数倍が悪いという話があります。そのあたりも検証するため、 Library Checker の問題で検証を行いました。 以下に、いくつかの提出リンクを示します。 (注意として、今回の実装は細かい最適化などをほとんど行っていません。かなり遅い実装なはずです。) Treap (6485ms) Binary Trie (メモリ超過によるRE | 4280ms) X-Fast Trie (メモリ超過によるRE | 6293ms) Y-Fast Trie (細かいチューニングによりギリギリMLEを回避 | 5896ms) 結論としては、存外Y-Fast Trieも悪くない感じでした。Binary TrieやX-Fast Trieに比べて明らかに空間使用量が減っていますし、Treapより速いのは驚きました。 参考資料 (あなたもY-Fast Trie組みませんか？) みんなのデータ構造、Pat Morin著、堀江慧、陣内佑、田中康隆訳、ラムダノート 5章、6章、7章、13章が特に関係します。本エントリの主情報源です。 なんと、 ここで 無料で読めます。知らなかったので2000円払って買いました。(存外紙ベースのほうも悪くないです。) プログラミングコンテストでのデータ構造2 ～平衡二分探索木編～、秋葉拓哉著、 https://www.slideshare.net/slideshow/2-12188757/12188757 さっくりと解説されているので、初めての人はこれだけ見て組むのはしんどいです。(1敗) 他のリソースも活用することをお勧めします。 Predecessorを高速に解くデータ構造: Y-Fast Trie、goonew著、 https://qiita.com/goonew/items/6ffac4b5e48dc05ca884 たくさんの図があり、丁寧に解説されています。binary trieでsuccessorクエリをサポートする方法が特にわかりやすいです。 Predecessor Problem、 https://judge.yosupo.jp/problem/predecessor_problem 自力で行うより信頼性が高いテストを行うことができます。 Associative Array、 https://judge.yosupo.jp/problem/associative_array 上に同様です。 終わりに アドベントカレンダーに寄せるエントリということで、かなり気合が入ってしまい、超長文を生成してしまいました。 ここまで見ていただいた方、本当にありがとうございました。 Y-Fast Trieの動作原理を自分なりにできる限りかみ砕いて説明したつもりです。皆さんはどう感じましたか？ 私のささやかな願いとして、このエントリをみて、調布駅のTrieを「トライ」と読んでしまう人が増えるといいなと思っています。 感想、質問などを寄せていただけると非常に喜びます。私の twitter までどうぞ。 さて、アドベントカレンダーは続きます。 12月13日はAmiciiさんの担当です。 また、UEC2はazarasingさんによる Youtube プレイヤーのサイドに出てくる動画群が気に入らないので常に「関連動画」が出てくるようにする拡張機能を雑に作った。 です。 次のエントリも是非ご覧ください！"
  },
  {
    url: "/post/subsequences-by-delimiter/",
    title: "区切り文字による連続部分列の切り出し",
    date: "2024-12-03T00:00:00+09:00",
    body: "区切り文字による連続部分列の切り出し 概要 次の問題を解くアルゴリズムを考えます。 問題 数列$A = (a _ 1, a _ 2, \\dots, a _ N)$と数$D$が与えられる。 次の条件を満たす$A$の連続部分列をすべて列挙せよ。 非空 数$D$を含まない その連続部分列をすべて含み、かつ数$D$を含まないようなものが存在しない 例 $A = (1, 2, 2, 2, 1, 1, 3, 1, 4, 4), D = 1$のとき、 $(2, 2, 2), (3), (4, 4)$ 解法 $a _ i = D$なる$i$を事前にすべて列挙するのでもよいですが、$O(1)$ extra spaceでよりスマートに解けます。 尺取りベースで解きます。 まず$l = 1, r = 1$とします。これは、今見ている区間が$[l, r)$ということです。 次に、$r = N + 1$または$a _ r = D$となるまで$r$を1づつ増加させます。 まず、これで最も左の連続部分列が切り出せます。ただし、$a _ l = D$であるとき、$[l, r)$が空になるので、必要に応じて無視します。 次に、$l, r$をともに$r + 1$で置き換えます。これは、極大な連続部分列を切り出すという制約から、一つ前の$[l, r]$中の数が新しい$l$になることはありえないからです。極大でなくてよいのであれば、$l$を1増やすことになります。 $l = N + 1$であれば終了、そうでなければ最初に戻ります。 実装例 void main () { const int N = 10; const auto A = [1, 2, 2, 2, 1, 1, 3, 1, 4, 4]; const int D = 1; int l = 0, r = 0; while (l \u0026lt; N) { // rの修正 if (r \u0026lt; l) r = l; // 右端の探索 while (r \u0026lt; N) { if (A[r] == D) break; r++; } // 空でなければ採用 if (l \u0026lt; r) { foreach (i; l..r) { import std.stdio; write(A[i], i == r - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } // lの更新 l = r + 1; } } wandbox 例題 解法については省略します。 ABC33C ABC116C 終わりに 通常の尺取りと違って、区切りが数と数の隙間にあるのではなく、数そのものになるような場合を考えました。 この制約においては、通常のように$l = r$で更新すると、区切りの数の部分で無限ループすることになります。 空区間を許容してしまえば、$l = r + 1$で更新するだけでこの問題を回避することができます。 この区切りが数そのものであるのか、それともその隙間にあるのかという問題はより普遍的なものです。 最も有名な例は二分探索でしょう。二分探索のoff-by-oneで苦しむ現象の裏には大体この問題が隠れていると私は考えています。"
  },
  {
    url: "/post/reached-1600/",
    title: "AtCoder Algorithm 1600達成！",
    date: "2024-11-22T00:00:00+09:00",
    body: "AtCoder Algorithm 1600達成！ 喜び 2024-11-22のABC381でついにrating 1600+を達成しました！ 競技プログラミングを始めた頃、自分がここまでこれるとは思っていませんでした。嬉しいです！ 今後 まずは1600+を保てるくらいの実力をつけていきたいです。 向こう数年くらいで黄色に到達できたらなお嬉しいです。 がんばります！"
  },
  {
    url: "/post/unifying-segments-with-unionfind/",
    title: "UnionFindによる区間の統合",
    date: "2024-11-19T00:00:00+09:00",
    body: "UnionFindによる区間の統合 概要 $N$個の区間を考えて、$i$個目の区間を$[i, i + 1)$とします。 $O(N)$くらいが許されるとき、隣り合う区間を統合するクエリをUnionFindで処理することができます。 より具体的には、次の操作をならし$O(\\alpha (n))$時間で行うことができます。 $u$が属する区間を$R$とする。$R$と、$R$に(左右どちらかに)隣接する区間を統合する。 $u$が属する区間の最左と最右の点を答える。 方法 $N$頂点のUnionFindと、補助のデータとして2要素タプルの長さ$N$の配列$\\mathrm{range}$を持ちます。ここで、$\\mathrm{range[i]}$は$i$を根とする連結成分が表す区間です。 auto uf = new UnionFind(N); auto range = new Tuple!(int, int)[](N); foreach (i; 0..N) range[i] = tuple(i, i); 初期状態では$\\mathrm{range}[i]$は$(i, i)$を持ちます。$i$個目の区間は$[i, i + 1)$を表すので、閉区間で表現するなら$(i, i)$というわけです。 区間取得 まず、$u$が属する区間の取得を考えます。これは単にUnionFindの代表元を用いて操作すればよいです。 int r = uf.root(u); とします。$\\mathrm{range}$の定義から、$\\mathrm{range}[r]$が$u$の属する区間です。 騙されている気がしますが、初期状態では明らかに正しいです。じゃあ初期状態以外はどうなのかというと、区間マージの際にこれらの不変条件を壊さないように操作をすることで正しさを常に保つので大丈夫です。 区間統合 $u$の属する区間と、一つ右の区間を統合することを考えます。 二つの区間で代表元を取得して、それぞれ$\\mathrm{cur}, \\mathrm{right}$とします。$\\mathrm{cur}$は$\\mathrm{u}$から取得できます。$\\mathrm{right}$は$\\mathrm{range}[u]$を用いて取得できます。具体的には、 int cur = uf.root(u); int right = uf.root(range[cur][1] + 1); です。 これらをUnionFindで統合します。新しく決まった根を$r$とします。 $\\mathrm{range}[r]$を$\\mathrm{range}$の定義が壊れないように修正します。 つまり、$\\mathrm{range}[r] = (\\mathrm{range}[\\mathrm{cur}][0], \\mathrm{range}[\\mathrm{right}][1])$にします。 int r = uf.unite(cur, right); range[r] = tuple(range[cur][0], range[right][1]); ここで、$\\mathrm{range}[\\mathrm{cur}]$や$\\mathrm{range}[\\mathrm{right}]$の修正を行わないことに注意してください。この操作以降、区間を取りまとめて管理するのは$r$の仕事であり、もはや$\\mathrm{cur}$や$\\mathrm{right}$は根にはなりえません。なので、無視してもよいのです。 もう少しかみ砕くと、$\\mathrm{range}[\\mathrm{cur}][0] \\leq x \\leq \\mathrm{range}[\\mathrm{right}][1]$を満たすすべての数$x$に対して、その代表元は$r$になっています。 例題 ABC380E - 1D Bucket Tool 問題文 $1$から$N$の番号がついた$N$個のマスが一列に並んでいます。 $1 \\leq i \u0026lt; N$について、マス$i$とマス$i + 1$は隣接しています。 最初、マス$i$は色$i$で塗られています。 クエリが$Q$個与えられるので、順に処理してください。クエリは次の2種類のいずれかです。 1 x c: マス$x$から始めて「いまいるマスと同じ色に塗られている隣接するマス」への移動を繰り返すことで到達可能なマスを全て色$c$に塗り替える 2 c: 色$c$で塗られているマスの個数を答える 制約 $1 \\leq N \\leq 5 \\times 10 ^ 5$ $1 \\leq Q \\leq 2 \\times 10 ^ 5$ 解法 さっくりと説明します。 まず、重要な考察として、一度くっついてしまったらそれ以降分離しません。つまり、区間のマージができればよさそうです。 上記で説明した情報のほかに、「連結成分の色」と、「色ごとのカウント」を用意します。 マージクエリが来たら、一旦今の連結成分の色をカウントの減らして、色を変え、変えた先の色のカウントを増やします。 最後に隣接領域と色が同じであればマージを行います。 細かい部分は自力で詰めるのがよいと思います。ぜひチャレンジしてみてください。 import std; void main () { int N, Q; readln.read(N, Q); auto uf = UnionFind(N); /* range[i] := 根をiとする連結成分が管理する区間 */ auto range = iota(N).map!((i) =\u0026gt; tuple(i, i)).array; /* color[i] := 根をiとする連結成分の色 */ auto color = iota(N).array; /* count[i] := 色iの現在の数 */ auto count = generate!(() =\u0026gt; 1).take(N).array; auto ans = new int[](0); foreach (i; 0..Q) { auto query = readln.split.to!(int[]); int t = query[0]; if (t == 1) { int x = query[1] - 1, c = query[2] - 1; int r = uf.root(x); /* xの属する連結成分のカウントを取り消し */ count[color[r]] -= uf.GroupSize(r); /* 色の変更 + カウント */ color[r] = c; count[color[r]] += uf.GroupSize(r); /* 同じ色で隣接している連結成分をマージする */ if (0 \u0026lt;= range[r][0] - 1) { int left = uf.root(range[r][0] - 1); if (color[left] == color[r]) { // 左側マージ成功 + 新しい区間の範囲を正しくして、今見てる根を新しいほうにする int nr = uf.unite(left, r); range[nr][0] = range[left][0]; range[nr][1] = range[r][1]; r = nr; } } if (range[r][1] + 1 \u0026lt; N) { int right = uf.root(range[r][1] + 1); if (color[right] == color[r]) { // 右側マージ成功 int nr = uf.unite(r, right); range[nr][0] = range[r][0]; range[nr][1] = range[right][1]; r = nr; } } } if (t == 2) { int c = query[1] - 1; ans ~= count[c]; } } foreach (v; ans) { writeln(v); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } // UnionFind省略 終わりに 一回実装しないとやり方がよくわからないシリーズかなと思います。ミソは、別に配列を持って、現在の根の場所に連結成分の情報を書き込むことです。 初めて見たときは少し混乱しましたが、UnionFindで扱える問題が広くなるよいアイデアだと思います。"
  },
  {
    url: "/post/apple-emoji-on-mintty/",
    title: "失われしappleスタイルのemojiを召喚 on mintty",
    date: "2024-11-09T00:00:00+09:00",
    body: "失われしappleスタイルのemojiを召喚 on mintty はじめに mintty という端末エミュレータがあります。 msysやcygwinやgitbashにくっついてインストールされるようで、私のwindows環境にもいつの間にかありました。 私は基本的にターミナル暮らしをしており、最近はgitbashにくっついてきたminttyを常用しています。 さて、そんなminttyですが、デフォルトでemojiを描画出来ません。具体的には次のようになります。 これはCold Face🥶(U+1F976)です。なんの趣もありません。ちゃんとemojiを表示したいですね？？？ 今回、minttyでappleスタイルのemojiを描画することに成功したので、その方法を書きます。 emoji導入を試みる 当然先人は居るわけで、「mintty emoji」でググると二番目に出てくるこのページが非常に参考になりました。 mr/minttyやwslttyでカラー絵文字 結論としては、スクリプト一発で出来るようです。以下に上記ページのスクリプトを少し改造したものを掲載します。実際に私の環境で動いたやつです。(改造はwgetをcurlに置き換えた部分だけです。) # MSYS2(mintty)の場合 emojis_dir=\u0026#34;$(echo \u0026#34;$APPDATA/mintty\u0026#34; | sed -re \u0026#39;s;^(.).;/\\L\\1;\u0026#39; -e \u0026#39;s;\\\\;/;g\u0026#39;)/emojis\u0026#34; getemojis_url=\u0026#39;https://raw.githubusercontent.com/mintty/mintty/master/tools/getemojis\u0026#39; getemojis_script=\u0026#34;${getemojis_url##*/}\u0026#34; # 絵文字png用ディレクトリ作成 mkdir -p \u0026#34;$emojis_dir\u0026#34; || true cd \u0026#34;$emojis_dir\u0026#34; || exit 1 echo \u0026#34;created $emojis_dir\u0026#34; # 絵文字pngダウンロードスクリプトの準備 [ -e \u0026#34;$getemojis_script\u0026#34; ] \u0026amp;\u0026amp; rm -rf \u0026#34;$getemojis_script\u0026#34; curl -o \u0026#34;$getemojis_script\u0026#34; \u0026#34;$getemojis_url\u0026#34; sed -i \u0026#39;/postproc=sh/s;sh;bash;\u0026#39; \u0026#34;${getemojis_script}\u0026#34; # sh -\u0026gt; bash に修正 # 絵文字pngダウンロード（そこそこ時間が掛かります） bash \u0026#34;${getemojis_script}\u0026#34; -d これでminttyの設定画面からgoogleスタイルのemojiを選択できるようになるはずです。 でも上記ページにはいろんなスタイルを選択できると書いてありましたが、googleしかありません。私はappleスタイルが使いたいんですが！ 調査 上記スクリプトはhttps://raw.githubusercontent.com/mintty/mintty/master/tools/getemojisをダウンロードしてきて実行するといった内容のようです。(普通に何も見ずに実行しました。セキュリティさん\u0026hellip;) そこで、ダウンロード + 実行されたスクリプトを見に行きましょう。 私の場合は、~/AppData/Roaming/mintty/emojisにgetemojisというスクリプトが生成されていました。 ソースコードを見ていると、不穏な一文を発見\u0026hellip; echo \u0026#34; $emojisurl1\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;for the selected emoji style sets, or (if none selected) all of them:\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34; google\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;and always extracts common emoji graphics.\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;Other styles are no longer provided at unicode.org:\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34; [apple facebook windows twitter emojione samsung]\u0026#34; \u0026gt;\u0026amp;2 echo \u0026gt;\u0026amp;2 Other styles are no longer provided at unicode.org: つまり、unicode.orgがgoogle以外のemojiスタイルの画像を提供するのをやめてしまったのが原因のようでした。 ということは、画像さえ用意できれば別スタイルのemojiを表示できる\u0026hellip;？ 実際、~/AppData/Roaming/mintty/emojis/google/以下はこんな感じでした。 名前をそのemojiの16進数表現にした透過pngを用意できれば良いっぽいですね。 appleスタイルのインストール というわけで、appleスタイルのemoji画像が集まっているwebページからpngを取得して、~/AppData/Roaming/mintty/emojis/apple/に入れるスクリプトを書きました。 ソースコードが酷いのは見逃してください。 requestsモジュールを要求しますが、複雑なことは何一つしていないので標準の範囲でも書き直せそうです。 注意: saved_image_pathを書き換えてください。(他にも直すとこあるかも) パス区切り文字を無理やり/にしてます。 実行時間40分くらいです。 gistにもあがっています。 from html.parser import HTMLParser import urllib import requests import re import sys import os class EmojigraphReader(HTMLParser): def __init__ (self): super().__init__() self.is_in_emoji_element = False self.urls = [] def retrive_urls (self): return self.urls.copy() def handle_starttag (self, tag, attrs): def handle (): if tag == \u0026#34;a\u0026#34;: for attr in attrs: if attr[0] == \u0026#34;class\u0026#34; and attr[1] == \u0026#34;pim\u0026#34;: self.is_in_emoji_element = True return if tag == \u0026#34;img\u0026#34;: if not self.is_in_emoji_element: return for attr in attrs: if attr[0] != \u0026#34;src\u0026#34;: continue self.urls.append(attr[1]) handle() def handle_endtag (self, tag): if tag == \u0026#34;a\u0026#34; and self.is_in_emoji_element: self.is_in_emoji_element = False def main (): emojigraph_apple_emojis_url = \u0026#34;https://emojigraph.org/apple/\u0026#34; current_path = \u0026#34;https://emojigraph.org\u0026#34; saved_image_path = \u0026#34;/Users/namah/AppData/Roaming/mintty/emojis/apple\u0026#34; # 対象ディレクトリ作成 if not os.path.isdir(saved_image_path): os.mkdir(saved_image_path) # emojigraph.orgへGETを飛ばす。 print(f\u0026#34;Trying GET {emojigraph_apple_emojis_url}\u0026#34;) emojigraph_response = requests.get(emojigraph_apple_emojis_url) if not 200 \u0026lt;= emojigraph_response.status_code \u0026lt;= 299: print(f\u0026#34;Status code of GET {emojigraph_apple_emojis}: {emojigraph_response.status_code}\u0026#34;, file=sys.stderr) print(\u0026#34;Maybe failed.\u0026#34;, file=sys.stderr) exit(1) print(\u0026#34;Successed!\u0026#34;) sys.stdout.flush() # HTML解析(ガバガバ) reader = EmojigraphReader() reader.feed(emojigraph_response.text) image_urls = reader.retrive_urls() # ダウンロードをする。 # 正規表現書きたかったけど技術力が足りんので普通に末尾を見る実装で for url in image_urls: codepoint_plus_png = url[url.find(\u0026#34;_\u0026#34;) + 1:] res = requests.get(urllib.parse.urljoin(current_path, url)) print(f\u0026#34;Trying GET {urllib.parse.urljoin(current_path, url)}\u0026#34;) if not 200 \u0026lt;= res.status_code \u0026lt;= 299: print(f\u0026#34;Status code of GET {url}: {res.status_code}\u0026#34;, file=sys.stderr) print(\u0026#34;Maybe failed. (continue downloading)\u0026#34;, file=sys.stderr) sys.stdout.flush() continue img_path = os.path.join(saved_image_path, codepoint_plus_png).replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;) with open(img_path, \u0026#34;wb\u0026#34;) as img: img.write(res.content) print(f\u0026#34;Saved image to {img_path}\u0026#34;) sys.stdout.flush() if __name__ == \u0026#34;__main__\u0026#34;: main() これを実行すると、メニューにappleのスタイルが増えました！ 無事にappleスタイルを表示することが出来ました。やったー！ 終わりに 競技プログラミング以外でコード書くことほぼないので、たまに活用できてうれしいね。みたいな話。 mainを肥大化させる癖マジで直したいです。 今回スクレイピングしたhtmlは滅茶苦茶シンプルだったからよかったけど、pythonの標準パーサだと複雑なことは出来なさそうだと思いました。 DOM操作ができる標準ライブラリの普及が待たれる。(需要ないのかな？)"
  },
  {
    url: "/post/icpc-2024-domestic-d/",
    title: "ICPC模擬国内予選D 過去問の共有",
    date: "2024-10-29T00:00:00+09:00",
    body: "ICPC模擬国内予選D 過去問の共有 問題概要 問題へのリンク 問題文 JAG大学ICPC学科には$N$人の学生が在籍しており、それぞれの学生には$1$から$N$までの番号がついている。また、学生の交友関係が$M$個存在する。$i$番目の交友関係は、学生$a _ i$と$b _ i$が友達であり、互いに連絡できることを表す。 学科の期末試験では、$N$教科の試験が行われる予定である。はじめ、学生$i$は教科$i$の過去問を持っている。 あなたは学生$1$である。友達同士で過去問を共有することを繰り返したとき、あなたが過去問の情報を何教科得られるかが気になった。そこで、友達同士で行われる過去問の共有が$K$回行われたときの期待値を調べることにした。 次のイベントが順に$K$回独立に発生することを考える。 $M$個の交友関係のうち一つがランダムに選ばれ、その学生二人が連絡を取りあう。このとき、それぞれが持つ過去問情報をすべて共有しあう。 言い換えると、片方が持つ過去問の教科の集合を$X$、もう片方を$Y$とすると、そのイベントの後、持っている過去問の教科の集合は双方とも$X \\cup Y$になる。 $K$回のイベントの終了後、学生$1$であるあなたが持っている過去問の教科数の期待値を$\\mod 998244353$で求めよ。 なお、この問題において、求める期待値は必ず有理数になることが証明できる。また、この問題の制約のもとでは、その値を既約分数$P/Q$で表したとき、$Q \\neq 0 \\pmod {998244353}$となることも証明できる。よって、$R \\times Q \\equiv P \\pmod {998244353}, \\quad 0 \\leq R \u0026lt; 998244353$を満たす整数$R$が一意に定まる。この$R$が、期待値$\\mod 998244353$である。ここで、$998244353 = 223 \\times 7 \\times 17 + 1$は素数である。 制約 $2 \\leq N \\leq 10$ $1 \\leq M \\leq \\frac{N(N - 1)}{2}$ $1 \\leq K \\leq 50$ 解法 全てのイベント列をシミュレーションすることが出来れば、期待値を直接求めることが出来る。 しかし、全てのイベント列は$M ^ K$回個あるため、現実的でない。 そこで、次の動的計画法を検討する。 $\\mathrm{dp}\\lbrack i \\rbrack \\lbrack S _ 1 \\rbrack \\lbrack S _ 2 \\rbrack \\lbrack \\dots \\rbrack \\lbrack S _ N \\rbrack = (\\text{先頭$i$個のイベントが終わった時点で、学生$j$の持っている過去問の集合が$S _ j$である場合の数})$ 状態数は$K 2 ^ {N ^ 2}$で、依然として現実的でない。 また、次のイベントが発生したとき各学生の持っている教科を求めるためには、現時点で持っている教科を知る必要があるため、これ以上状態を削減する事すら難しい。 期待値を考える時の典型的な手法として、確率変数の分離を行ない、期待値の線形性を利用するというものがある。今回はこの方針がうまくいく。 確率変数を考えるので、必要な情報を考えよう。今回の問題では、 標本空間はイベントを$K$個並べた列、つまり$\\Omega = \\lbrace (e _ 1, e _ 2, \\dots, e _ K) \\mid e _ i \\in \\lbrack 1, M \\rbrack \\rbrace$、確率関数$P$は、任意の根源事象$\\omega \\in \\Omega$に対して、$P(\\lbrace \\omega \\rbrace) = \\frac{1}{\\lvert \\Omega \\rvert}$となる。 今考えている確率変数を$X$とする。 この$X$は$K$回のイベントの列から、「最終的に学生$1$が持つ過去問の教科数」への写像である。 各教科に着目して確率変数を分離してみよう。確率変数$X _ i$を「最終的に学生$1$が過去問$i$を持っていれば$1$、そうでなければ$0$」となる写像であるとする。 この時、任意の$\\omega \\in \\Omega$に対して、$X(\\omega) = \\sum _ {i = 1} ^ N X _ i(\\omega)$が成立する。 ここで、期待値の線形性を適用すると、$E\\lbrack X \\rbrack = \\sum _ {i = 1} ^ N E\\lbrack X _ i \\rbrack$が成立する。 よって、各$i$に対して$E\\lbrack X _ i \\rbrack$を求められれば良いことがわかった。 $E\\lbrack X _ i \\rbrack$について検討しよう。 定義より、$E\\lbrack X _ i \\rbrack = \\sum _ {\\omega \\in \\Omega} P(\\lbrace \\omega \\rbrace) X _ i(\\omega)$である。 イベントを独立に選択するという仮定から、任意の$\\omega \\in \\Omega$に対して$P(\\lbrace \\omega \\rbrace) = \\frac{1}{\\lvert \\Omega \\rvert}$である。 つまりこれを外に出すことが出来て、$E\\lbrack X _ i \\rbrack = \\frac{1}{\\lvert \\Omega \\rvert} \\sum _ {\\omega \\in \\Omega} X _ i(\\omega)$が成立する。 ここで、$X _ i$の定義は「最終的に学生$1$が過去問$i$を持っていれば$1$、そうでなければ$0$となる写像」であった。 つまり、$\\sum _ {\\omega \\in \\Omega} X _ i(\\omega)$は「最終的に学生$1$が過去問$i$を持っているようなイベント列の数」である。 以上より、$E\\lbrack X _ i \\rbrack = \\frac{(\\text{学生$1$が過去問$i$を持っているようなイベント列の数})}{(\\text{イベント列の総数})}$である。 これはランダムに一つイベント列をとったとき、それが学生$1$に過去問$i$が回ってくるようなイベント列である確率ととらえることが出来る。 さて、問題に戻ろう。最初検討した動的計画法は、過去問全種類について一挙に考えようとしていたため、$N$人がそれぞれ$N$ビットの情報を持つ必要があった。しかし、確率変数の分離と期待値の線形性により、過去問の種類ごとに分けて考えてよいことがわかった。 ここで改めて動的計画法を組みなおそう。 欲しい値は、「ある科目について、学生$1$が最終的に過去問を得られるようなイベント列の総数(あるいはそのイベントの全体からの割合)」である。 過去問の伝播は、過去問を既に持っている人からしか発生しないため、$i$回のイベントが終わった時点でその過去問を持っている人の集合がわかれば遷移が出来そうだ。そこで、$\\mathrm{P}\\lbrack i \\rbrack \\lbrack S \\rbrack = (\\text{$i$回のイベントが終わった時点で、ある教科の過去問を持っている人の集合が$S$であるようなイベント列の割合})$ とする。 $i$から$i + 1$の遷移は、$M$個すべての関係を見たとき、 人$a _ j$または$b _ j$が過去問を持っているとき、$\\mathrm{dp}\\lbrack i + 1 \\rbrack \\lbrack S \\cup a _ j \\cup b _ j \\rbrack$に$\\frac{1}{M} \\mathrm{dp}\\lbrack i \\rbrack \\lbrack S \\rbrack$を足しこむ。 そうでない時、$\\mathrm{dp}\\lbrack i + 1 \\rbrack \\lbrack S \\rbrack$に$\\frac{1}{M} \\mathrm{dp}\\lbrack i \\rbrack \\lbrack S \\rbrack$を足しこむ。 という形になる。初期状態は、教科$x$について考えるとき、 $\\mathrm{dp}\\lbrack 0 \\rbrack \\lbrack \\lbrace x \\rbrace \\rbrack = 1$、それ以外は$0$となる。 最終的に、解に$\\mathrm{dp}\\lbrack K \\rbrack \\lbrack S \\rbrack$であって、$S$に$1$が含まれるものを足しこむことになる。 最後にこの解法の計算量を確認しておこう。 $i$を固定した際の状態数が$2 ^ N$で、これら一つあたり$M$個の$O(1)$時間で行なえる遷移を試すことになるので、教科一つについて$O(K 2 ^ N M)$時間である。 $N$教科についてこれを行うと、全体で$O(NK 2 ^ N M)$時間となる。 $NK 2^ N M$は制約下で$NK 2 ^ N M \\leq 23040000 \\approx 2.3 \\times 10 ^ 7$となる。 実装例 c++による解答例を示す。 jagページ にあるすべてのテストケースに対して、10秒以内程度で正しい解を出力することを確認している。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;utility\u0026gt; using namespace std; using ll = long long; ll mod_pow (ll a, ll x, const ll MOD) { assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); a %= MOD; if (a \u0026lt; 0) a += MOD; ll base = a; ll res = 1; while (0 \u0026lt; x) { if (0 \u0026lt; (x \u0026amp; 1)) { res *= base; res %= MOD; } base *= base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return res % MOD; } ll mod_inv (ll a, const ll MOD) { // MOD: 素数を仮定 return mod_pow(a, MOD - 2, MOD); } int main () { // 確率変数Xを試行終了後に1が持っている過去問の種類数とする。 // N個の確率変数Xiを、試行終了後に1が過去問iを持っていれば1、持っていなければ0として定める。 // X = sum(Xi)である。期待値の線形性から、 // E[X] = sum(E[Xi])としてよい。 // 定義から、E[Xi] = (1が過去問iを持っている試行の数) / M^K = (1が過去問iを持っている試行が生起する確率) // が成立。 const ll MOD = 998244353; vector\u0026lt;ll\u0026gt; ans; while (true) { int N, M, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K; if (N == 0 \u0026amp;\u0026amp; M == 0 \u0026amp;\u0026amp; K == 0) break; vector\u0026lt;int\u0026gt; a(M), b(M); for (int i = 0; i \u0026lt; M; i++) { cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i]; a[i]--, b[i]--; } vector\u0026lt;ll\u0026gt; P(1 \u0026lt;\u0026lt; N); vector\u0026lt;ll\u0026gt; NP(1 \u0026lt;\u0026lt; N); // P[i][S] := i回の操作が終わったとき、ある過去問を持っている人の集合がSである確率 ll inv_M = mod_inv(M, MOD); ll res = 0; for (int pid = 0; pid \u0026lt; N; pid++) { // Pのリセット for (int S = 0; S \u0026lt; (1 \u0026lt;\u0026lt; N); S++) { P[S] = 0; } // P初期値 P[1 \u0026lt;\u0026lt; pid] = 1; for (int i = 0; i \u0026lt; K; i++) { // NPのリセット for (int S = 0; S \u0026lt; (1 \u0026lt;\u0026lt; N); S++) { NP[S] = 0; } for (int S = 0; S \u0026lt; (1 \u0026lt;\u0026lt; N); S++) { for (int j = 0; j \u0026lt; M; j++) { int v = 0; if (0 \u0026lt; (S \u0026amp; (1 \u0026lt;\u0026lt; a[j])) || 0 \u0026lt; (S \u0026amp; (1 \u0026lt;\u0026lt; b[j]))) v = 1; NP[S | (v \u0026lt;\u0026lt; a[j]) | (v \u0026lt;\u0026lt; b[j])] += P[S] * inv_M % MOD; NP[S | (v \u0026lt;\u0026lt; a[j]) | (v \u0026lt;\u0026lt; b[j])] %= MOD; } } swap(P, NP); } // 集計 for (int S = 0; S \u0026lt; (1 \u0026lt;\u0026lt; N); S++) { if (0 \u0026lt; (S \u0026amp; 1)) { res += P[S]; res %= MOD; } } } ans.push_back(res); } for (auto\u0026amp; v : ans) { cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 感想 ようやく解法を理解できた。 問題文を誤読していて、期待値の線形性に持ち込んだ後にちょっと悩むパートがあった。 確率変数を分離して、期待値の線形性に持ち込む解法は他にも出題例があるので、この手の議論に慣れていきたい。"
  },
  {
    url: "/post/functional-graph-logn-simulation/",
    title: "Functional GraphでK回進むクエリ in \u003cO(NlogN), O(logN)\u003e",
    date: "2024-10-19T00:00:00+09:00",
    body: "Functional GraphでK回進むクエリ in \u003cO(NlogN), O(logN)\u003e 概要 次の問題を$\\langle O(N\\log N), O(\\log N) \\rangle$で解くアルゴリズムを紹介します。 問題 $N$頂点の有向グラフがあり、頂点$i$を始点とする辺の終点は頂点$f(i)$である。 次のクエリを$Q$個処理せよ。 頂点$u$から$K$回進んだ頂点を出力する。 $N \\leq 2 \\times 10^5$、$K \\leq 10^{18}$ 解法 Functional Graphにおいて、頂点を任意に一つ選んだとします。 この頂点はちょうどひとつのサイクルに含まれるか、あるいはどのサイクルにも含まれません。 すなわち、$i$を始点、$i$を終点とし、$i$をちょうど2個含むようなwalkはどの$i$に対しても一意、または存在しません。 理由\rそのようなwalkを2通り以上とれたとします。これらwalkの中から任意に2つ取ります。\rこの2つで初めて異なる頂点が出現する場所を考えます。(このような場所は、最後が$i$であるという制約から必ず存在します。)\rこの時、その場所の一つ前にある頂点の出次数が少なくとも2である事がわかりますが、これは仮定に反します。\rこの事実により、Functional Graphを互いに交わらないサイクルと、これらサイクルに「突き刺さっている」木に分解できます。 以下はFunctional Graphの例です。頂点7が「突き刺さっている木」で、他はサイクルです。 ( https://hello-world-494ec.firebaseapp.com/ で作成) 事前にこれらのサイクルを列挙することが出来れば、サイクル内の点に対するクエリは$O(1)$で処理可能です。また、サイクル外の点は高々$N$回の移動で必ずサイクルに入るため、移動を行えばサイクル内の点に対するクエリに帰着できます。 移動先は一意なので、ダブリングで高速化することが出来ます。 このアルゴリズムの計算量を見積もります。 サイクルの列挙は$O(N)$時間で出来ます。ダブリングの前計算は$O(N\\log N)$時間で出来ます。 クエリ処理は最悪ケースで$N$回の移動が必要で、これは前計算を用いて$O(\\log N)$時間です。 したがって、$\\langle O(N\\log N), O(\\log N) \\rangle$です。 実装 next[i]を頂点$i$から1回進んだ先とします。 サイクル検出はいろいろやり方があると思います。次に示すコードはあくまで一例です。 auto vis = new bool[](N); vis[] = false; foreach (i; 0..N) { if (vis[i]) continue; work.length = 0; int cur = i; while (!vis[cur]) { vis[cur] = true; work ~= cur; // push_backです。 cur = next[cur]; } foreach (idx, v; work) { if (v == cur) { // work[idx..]にサイクルが入っているので、なんやかんやする。 break; } } } ダブリングは次のような感じです。 // ダブリング構築: O(NlogN)時間 foreach (i; 0..N) { doubling[0][i] = next[i]; } foreach (i; 0..max_table_size - 1) { foreach (j; 0..N) { doubling[i + 1][j] = doubling[i][doubling[i][j]]; } } doubling[i][j]は$j$から$2^i$回進んだ先です。$2^i = 2^{i - 1} + 2^{i - 1}$である事を利用してテーブルを埋めます。 二次元配列は1次元目を指数、2次元目を頂点にした方が圧倒的に高速なので、これに従うほうが良いです。 max_table_sizeは$K$に依存せず、$O(\\log N)$程度でよいことに注意してください。 これらを用いてクエリ処理します。ダブリングで進める時、msb側からほぐすと定数倍有利かもしれません。 通常のダブリングとは進め方が異なるので注意してください。 具体的には、$j$bit目が立っているかを見るのではなく、$2^j$進んで良いか(クエリで聞かれている分を超えないか)を見ます。 実装例 ABC367E - Permute K times (LDC 1.32.2 / 70ms) import std; void main () { int N; long K; readln.read(N, K); auto X = readln.split.to!(int[]); auto A = readln.split.to!(int[]); X[] -= 1; auto fg = new FunctionalGraph(N); foreach (i; 0..N) { fg.add_edge(i, X[i]); } fg.build(); auto B = new int[](N); foreach (i; 0..N) { int j = fg.move_k(i, K); B[i] = A[j]; } foreach (i; 0..N) { write(B[i], i == N - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } class FunctionalGraph { int N; int[] next; int[] roop; int[] roop_start; int[] roop_size; int[] place; int[][] doubling; int max_table_size = 0; bool built = false; this (int N) { this.N = N; roop = new int[](N); roop_start = new int[](N); roop_start[] = -1; roop_size = new int[](N); roop_size[] = -1; place = new int[](N); place[] = -1; next = new int[](N); next[] = -1; import core.bitop : bsr; max_table_size = bsr(N) + 1; doubling = new int[][](max_table_size, N); } void add_edge (int from, int to) in { assert(next[from] == -1); assert(0 \u0026lt;= from \u0026amp;\u0026amp; from \u0026lt; N); assert(0 \u0026lt;= to \u0026amp;\u0026amp; to \u0026lt; N); } do { next[from] = to; } void build () in { foreach (i; 0..N) assert(next[i] != -1); } do { // ループを検出: O(N)時間 auto vis = new bool[](N); auto work = new int[](N); int latest = 0; foreach (i; 0..N) { if (vis[i]) continue; work.length = 0; int cur = i; while (!vis[cur]) { vis[cur] = true; work ~= cur; cur = next[cur]; } int start = -1; foreach (w; 0..work.length) { if (work[w] == cur) { start = w.to!int; break; } } if (start == -1) continue; int rs = latest; int wl = work.length.to!int; foreach (w; work[start..$]) { roop[latest] = w; roop_start[w] = rs; roop_size[w] = wl - start; place[w] = latest - rs; latest++; } } // ダブリング構築: O(NlogN)時間 foreach (i; 0..N) { doubling[0][i] = next[i]; } foreach (i; 0..max_table_size - 1) { foreach (j; 0..N) { auto v = doubling[i][j]; doubling[i + 1][j] = doubling[i][v]; } } built = true; } int move_k (int fr, long K) in { assert(0 \u0026lt;= K); assert(built); } do { // ダブリングしながらループに入った時点でreturn foreach_reverse (i; 0..max_table_size) { if (roop_start[fr] != -1) { break; } if ((1 \u0026lt;\u0026lt; i) \u0026lt;= K) { fr = doubling[i][fr]; K -= (1 \u0026lt;\u0026lt; i); } } if (K == 0) { return fr; } int suc = (K + place[fr]) % roop_size[fr]; return roop[roop_start[fr] + suc]; } } 追加情報 この問題は(自分の知っている限り)最良$\\langle O(N), O(1) \\rangle$で解けます。 本稿においてダブリングで処理した部分は結局 木が与えられる。$K$回遡った先の頂点を答えよ。 という問題がとければよいです。これはLevel Ancestor Problemという名前がついていて、調べるとたくさん解法が出てきます。 それらの一部にリンクしておきます。 \u0026lt;O(N), O(1)\u0026gt;のオンラインアルゴリズム O(N + Q)のオフラインアルゴリズム \u0026lt;O(N), O(log N)\u0026gt;のオンラインアルゴリズム 本アルゴリズムは時間計算量、空間計算量の点でこれらのアルゴリズムに劣ります。 一方、LAを用いる場合、すべての木についてLAを構築する必要があり、実装がさらに大変になることが予想されます。 (LAを用いる場合でもサイクル処理するパートはさぼれないことに注意。) 終わりに いくつか書きたいことがあるので書きます。 ダブリングするときに[bit][x]のレイアウトをmsb側から1次元に直すとキャッシュにのりやすくなる説ある？(msbで貪欲にとるアルゴのために逆順にしている) ほぐすときにアクセスする場所が連続するメモリの位置が小さい順番にアクセスできる気がする。要検証。 \u0026mdash; In (@UU9782wsEdANDhp) October 17, 2024 漠然とこんなことを考えて、いろいろ試行錯誤していました。 なかなかうまくいかないのでfastestあたりを見ていたら、LayCurseさんがクエリ$O(\\log N)$で解いていることに気づきました。 そんなことできるのか？と考えていたら解けたので書くことにしました。多分998回くらい再発明されてますよねこれ。 ちなみにツイートの内容は今のところ「あまり早くならなさそう」という結論です。かなり残念。 それと、ダブリングは書き方次第で速度が大きく変わるようで、いろいろとテクニックがあるようです。 一番わかりやすいのは頂点を2次元目にするテクで、dp[i][x]をdp[x][i]にするだけで2倍くらい早くなります。 さらに、オフラインクエリで良いなら、 foreach (i; 0..N) { int cur = i; foreach (j; 0..BIT) { if (0 \u0026lt; (K \u0026amp; (1L \u0026lt;\u0026lt; i))) cur = dp[j][cur]; } } ではなく、 auto ans = iota(N).array; foreach (i; 0..BIT) { foreach (j; 0..N) { if (0 \u0026lt; (K \u0026amp; (1L \u0026lt;\u0026lt; i))) ans[j] = dp[i][ans[j]]; } } とした方が劇的に早くなるようです。ループアンローリングみたいな原理なのかなと思いつつなんでしょうこれ？ ダブリング、奥が深いと思いました。あとこういう高速化って誰が教えてくれるんですかね？ オンラインかつクエリ$O(\\log N)$でできるシンプルなアルゴリズムとして、今回の手法もそんなに悪くないのではないでしょうか？ ただ、ライブラリ化してしまえば実装コスト0なので、LAで$\\langle O(N), O(1) \\rangle$をやる方も書いてみたいです。 現状、アドベントカレンダーのネタ候補の一つです。 色々見た感じ、オンラインでクエリ$O(\\log K)$の方針を選ぶとどんなに頑張ってもdmdで400msくらいですが、このアルゴリズムなら200msを切れます。 そう考えると実用的かもしれないと思いました。(というか、今後Functional Graphのシミュレーションクエリが来たらこれ貼ります。) ダブリングが重いのとてもわかります。 始点一つに対して計算できればよいのであれば、こちらhttps://t.co/9uM3BWZoJI が定数倍軽めかつ統一的に扱えるのでおすすめです。 \u0026mdash; In (@UU9782wsEdANDhp) February 29, 2024 実際、今年2月の私もダブリング重いよな～と思っていたようです。"
  },
  {
    url: "/post/simple-nlogn-sort/",
    title: "比較的シンプルなクイックソートとマージソートの実装",
    date: "2024-10-10T00:00:00+09:00",
    body: "比較的シンプルなクイックソートとマージソートの実装 はじめに 比較的頭を壊しにくいクイックソートとマージソートの実装方針を共有します。 オーダーも悪化しません。定数倍はわかりませんが、最適実装に比べて高々2倍とかだと思います。(適当) 実装例はすべてC++です。 クイックソート 列を与えられたときに適切にswapしながら境界線を探すパートが最難関です。 この部分を2回に分けて行います。 1回目は前から走査していき、ピボット未満の値が出てきたらその時点での先頭とswapします。 2回目は後ろから走査していき、ピボット超過の値が出てきたらその時点で末尾とswapします。 こうすることで列全体は(ピボット未満)(ピボットと等しい)(ピボット超過)と分けることが出来て、さらにこれら境界線も手に入ります。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;cassert\u0026gt; template\u0026lt;class T\u0026gt; void quick_sort (std::vector\u0026lt;T\u0026gt;\u0026amp; A, size_t L, size_t R) { assert(0 \u0026lt;= L); assert(R \u0026lt;= A.size()); assert(L \u0026lt;= R); if (R - L \u0026lt;= 1) return; int l = static_cast\u0026lt;int\u0026gt; (L), r = static_cast\u0026lt;int\u0026gt; (R); std::random_device rd; T piv = A[l + rd() % (r - l)]; int lb = l, rb = r; // [l, lb)はpiv未満の値が入る。[rb, r)はpiv超過の値が入る。 for (int i = l; i \u0026lt; r; i++) { if (A[i] \u0026lt; piv) std::swap(A[i], A[lb++]); } for (int i = r - 1; l \u0026lt;= i; i--) { if (piv \u0026lt; A[i]) std::swap(A[i], A[--rb]); } quick_sort(A, l, lb); quick_sort(A, rb, r); } int main () { const int N = 10; std::vector\u0026lt;int\u0026gt; A(N); std::random_device rd; for (auto\u0026amp; v : A) v = rd() % 10000; for (int i = 0; i \u0026lt; A.size(); i++) { std::cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; (i == A.size() - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } quick_sort(A, 0, A.size()); for (int i = 0; i \u0026lt; A.size() - 1; i++) { assert(A[i] \u0026lt;= A[i + 1]); } for (int i = 0; i \u0026lt; A.size(); i++) { std::cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; (i == A.size() - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } 実行例: 6469 715 7203 2864 4958 3626 9044 2876 7437 248 248 715 2864 2876 3626 4958 6469 7203 7437 9044 これ実装しているときに普通にバグらせていたのは内緒です。 注意点としては 再帰の打ち切り ピボット値の選択 あたりです。 マージソート 再帰にかけた後に列をマージする部分が面倒です。この部分を工夫します。 列をマージするときに一時的に作業配列を使う部分で、左半分を昇順、右半分を降順に詰めます。 つまり、作業配列に詰めた後に大小関係が(小 大 小)となるようにします。 こうすると、常に右端と左端の大小だけを気にすればよくなり、片方を使い切ったので\u0026hellip;みたいな場合分けが消えます。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;algorithm\u0026gt; template\u0026lt;class T\u0026gt; void merge_sort (std::vector\u0026lt;T\u0026gt;\u0026amp; A, size_t L, size_t R) { assert(0 \u0026lt;= L); assert(R \u0026lt;= A.size()); assert(L \u0026lt;= R); if (R - L \u0026lt;= 1) return; static std::vector\u0026lt;T\u0026gt; tmp; tmp.resize(std::max(R - L, tmp.size())); int l = static_cast\u0026lt;int\u0026gt; (L), r = static_cast\u0026lt;int\u0026gt; (R); int m = (l + r) / 2; merge_sort(A, l, m); merge_sort(A, m, r); for (int i = 0; i \u0026lt; m - l; i++) tmp[l + i] = A[l + i]; for (int i = 0; i \u0026lt; r - m; i++) tmp[r - i - 1] = A[m + i]; // マージ int tl = l, tr = r - 1; for (int i = 0; i \u0026lt; r - l; i++) { if (tmp[tl] \u0026lt; tmp[tr]) { A[l + i] = tmp[tl]; tl++; } else { A[l + i] = tmp[tr]; tr--; } } } int main () { const int N = 10; std::vector\u0026lt;int\u0026gt; A(N); std::random_device rd; for (auto\u0026amp; v : A) v = rd() % 10000; for (int i = 0; i \u0026lt; A.size(); i++) { std::cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; (i == A.size() - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } merge_sort(A, 0, A.size()); for (int i = 0; i \u0026lt; A.size() - 1; i++) { assert(A[i] \u0026lt;= A[i + 1]); } for (int i = 0; i \u0026lt; A.size(); i++) { std::cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; (i == A.size() - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } 実行例: 9033 6639 7992 2387 8486 7967 3180 6807 3361 9980 2387 3180 3361 6639 6807 7967 7992 8486 9033 9980 一時配列に詰める部分でバグりやすいので気を付けてください。そこ以外は変数名が衝突しなければ難しくないはずです。 参考 クイックソート: アルゴリズムイントロダクション(版などは忘れました\u0026hellip;) マージソート: UECの授業資料（一般公開されていないやつ） 終わりに g++でコンパイルオプションとして-D_GLIBCXX_DEBUGをつけると範囲外参照を検出してくれるのですが、何行目で落ちてるとか言ってくれなくてかなりデバッグしにくかったです。 これどうにかなりませんか？ このエントリ7月に100行くらい書いた状態でずっと放置していたのが最近発見されたので完成させました。 みなさんはこの実装方針どう思いますか？意見がある方は Twitter/X までどうぞ。"
  },
  {
    url: "/post/abc288d/",
    title: "ABC288D - Range Add Query",
    date: "2024-09-10T00:00:00+09:00",
    body: "ABC288D - Range Add Query 想定解法と全然異なる怪しい解法で通したので書きます。 問題概要 問題へのリンク 問題文 数列$X = (X _ 1, X _ 2, \\dots, X _ n)$が良い数列であるとは、次の操作を0回以上行ってすべての要素を$0$に出来る事をいう。 長さ$K$の範囲と整数$c$を自由に選んで、選んだ区間にあるすべての数に$c$を加算する。 長さ$N$の数列$A$が与えられる。次の$Q$個のクエリに答えよ。 $A$の$l _ i$番目から$r _ i$番目までを抜き出した長さ$r _ i - l _ i + 1$の数列が良い数列であるか判定する。 制約 $1 \\leq N \\leq 2 \\times 10 ^ 5$ $1 \\leq K \\leq \\min(10, N)$ $-10 ^ 9 \\leq A _ i \\leq 10 ^ 9$ $1 \\leq Q \\leq 2 \\times 10 ^ 5$ $K \\leq r _ i - l _ i + 1$ 解法 まずクエリ$O(N)$の解法を説明する。 与えられた数列$X$に対して、次の貪欲法を行う。 数列の左端から見ていく。今見ている場所が$X _ i$であるとする。そこを左端として区間加算が行えるならば、$c = -X _ i$として区間加算を行う。 この貪欲法を行った後、すべての要素が$0$であればYesである。 区間加算はimos法等で適切に処理することで$O(N)$で出来るため、クエリ$O(N)$の解法を得た。(正当性: 区間加算はどの順序で行っても結果は変わらない。よって、始点が早いものから行うとしてよい。今見ている場所を$0$以外にするような区間加算をしてしまうと、それ以降の区間加算で戻されることはないので、必ず$0$にするような区間加算をするしかない。) この解法をベースに解く。 上記解法では数列$X$の値が非零である場所が$O(N)$個であるせいでクエリ$O(N)$から落とすことが出来ないでいる。もし仮に非零である要素が十分に少なければ、考慮すべき区間加算の数も少なくすることが出来る。 非零要素を絞るための準備として、「元の数列$A$を作るときに必要な長さ$K$の区間加算クエリがどうなるか」を考える。 これを求めるのは簡単で、上記で説明した貪欲法 数列の左端から見ていく。今見ている場所が$X _ i$であるとする。そこを左端として区間加算が行えるならば、$c = -X _ i$として区間加算を行う。 を数列$A$に対して適用してやればよい。(より詳しい方法は実装例を参照せよ。) 例えば、入力例1に対して以下の図のようになる。 図の赤枠はクエリ2で与えられる区間である。 ここで次の事実に注目する。 $[l _ i, r _ i - K - 1]$から始まる区間加算は、必ずキャンセルすることが出来る。 この性質により、クエリ2では-4, -4, -4と+2, +2, +2をそもそも考慮しなくてよいことがわかる。 結果的に、$(3, 3, 0, 0, 0, 5)$が良い数列であるかを判定する問題と等価になる。 整理すると、この状況下で考慮すべき区間加算クエリは、 $l _ i$よりすこし前から始まっていて、区間内に影響するもの。 $r _ i$よりすこし前から始まっていて、区間内で完結しないもの。 だけであることがわかる。これで非零要素を$O(K)$個に絞ることが出来た。 ここからナイーブに操作すると結局$O(N)$時間かかってしまうが、片方の区間加算の影響をもう片方に持っていき、長さ$O(K)$の区間が良い数列であるかを判定するようにすれば良い。 文章のみで説明するのが厳しいので、再び図を用いる。 上記図のように、区間加算クエリ2回で幅$K$だけ影響をずらすことが出来る。最終的な移動位置は$O(1)$で求まるため、これで長さが高々$O(K)$である数列が良い数列であるか判定する問題に帰着できた。 判定はさぼると$O(K ^ 2)$で、いろいろと細かい部分を頑張ると$O(K)$になる。よって全体$O(N + QK)$で解ける。 実装例 $O(N + QK ^ 2)$である。面倒なのであまり説明はしないが、不明点があればTwitter等で聞いてほしい。 提出 import std; void main () { int N, K; readln.read(N, K); auto A = readln.split.to!(int[]); // クエリO(N)かけられないよな～からスタート。 // Kが小さいなぁ～ // じゃあ逆に、最初の列を幅KのRAQで構築したと考えたらどうだろう。 // -\u0026gt; 重要なのは高々O(K)個のRAQだけで、クエリ区間に含まれるRAQはすべて打ち消すことが出来るじゃないか。 // -\u0026gt; じゃあ、片方に寄せ集めてこれを消せればOKではないですかね？ auto acc = new long[](N); auto raq = new long[](N); foreach (i; 0..N) { // もらう if (0 \u0026lt; i) acc[i] += acc[i - 1]; // そこから積む値は？ raq[i] = A[i] - acc[i]; // 実際積んでおく acc[i] += raq[i]; if (i + K \u0026lt; N) acc[i + K] -= raq[i]; } auto buf = new long[](N); auto q = new int[](0); void add (int i, long v) { q ~= i; buf[i] += v; } long get (int i) { return buf[i]; } void reset () { foreach (v; q) buf[v] = 0; q.length = 0; } int Q = readln.chomp.to!int; auto ans = new string[](Q); foreach (z; 0..Q) { int l, r; readln.read(l, r); l--, r--; reset(); // 後ろ側のクエリ foreach (i; 0..K - 1) { add(r - i, raq[r - i]); } // 前側のクエリ foreach (i; 0..K - 1) { if (l - i - 1 \u0026lt; 0) break; int rem = K - i - 1; int d = (r - l + 1) / K; add(l + d * K - 1 - (K - rem - 1), -raq[l - i - 1]); if (l + d * K \u0026lt;= r) add(l + d * K, raq[l - i - 1]); } // 累積 { int cur = r - 2 * K; while (cur \u0026lt;= r) { if (l \u0026lt; cur) add(cur, get(cur - 1)); cur++; } } // 消せるかトライする。 { int cur = r - 2 * K; while (cur \u0026lt;= r) { if (l \u0026lt;= cur \u0026amp;\u0026amp; cur + K - 1 \u0026lt;= r) { foreach (i; 0..K) { add(cur + K - i - 1, -get(cur)); } } cur++; } } bool ok = true; foreach (i; 0..2 * K) { if (r - i \u0026lt; l) break; if (get(r - i) != 0) ok = false; } if (ok) { ans[z] = \u0026#34;Yes\u0026#34;; } else { ans[z] = \u0026#34;No\u0026#34;; } } foreach (i; 0..Q) { writeln(ans[i]); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 終わりに 今日2時間くらい眺めてたら天啓が降ってきたので解いた。 天才以外お断りパズルみたいなやつから得られる知見が無さ過ぎて苦しい。 こういうのから共通点や思考のテクを抽出できる人が強いんだろうなって気持ちになって、すごく不快だった。 それはそれとして、配列の使用した場所だけを戻すことで計算量を下げるテクいいですよね。"
  },
  {
    url: "/post/range-kth-smallest/",
    title: "Range Kth Smallestに対する4つの解法と2つの実装例",
    date: "2024-09-07T00:00:00+09:00",
    body: "Range Kth Smallestに対する4つの解法と2つの実装例 問題 $N$要素の数列$A$が与えられる。$Q$個のクエリに解答せよ。 $A$の$[l _ i, r _ i)$内にある要素の中で$k _ i + 1$番目に小さい値を答える。 $1 \\leq N \\leq 2 \\times 10 ^ 5, \\quad 1 \\leq Q \\leq 2 \\times 10 ^ 5, \\quad 1 \\leq A _ i \\leq 10 ^ 9$ ジャッジ(library checker) 解法1 rectangle sumに帰着させる。 横軸に数列のインデックス、縦軸に値の大きさをとる二次元平面を考え、各$A _ i$に対応する場所に+1を積んでおく。 各クエリでは、x座標$[l _ i, r _ i)$に対してy軸方向$[-\\infty, v]$の総和をとる。この値は$v$に対して広義単調増加であるから、ちょうど$k _ i + 1$以上になる最小の$v$は二分探索で求まる。 クエリ$O(\\log N \\log N \\log (\\max A _ i))$程度(使うデータ構造によって多少揺れると思われる。なんかいい感じにやるとlog一つくらい落ちるかも) やりようによってはonlineクエリかつ列の変更クエリありでも動く。 rectangle sumの良い感じのやつをまだ持っていないので実装例なし。 解法2 wavelet matrixを用いる。wavelet matrixはこのクエリをサポートしているので、やるだけになる。 クエリ$O(\\log (\\max A _ i))$ onlineクエリでできるが、列の変更クエリなしのみ対応。dynamic wavelet matrixを用いればlogが付く代わりに変更クエリをさばける。(多分) 当然持っていないので実装例なし。 dynamic wavelet matrixってこんなやつ ちなみに現在のlibrary checker最速実行時間はこの方針に改造を加えたものだと思われる。 解法3 並列二分探索を用いる。 並列二分探索のことはいったん忘れて、クエリ$[l _ i, r _ i)$を考えることにする。 配列$B = (0, 0, \\dots, 0)$を用意して、$A _ i$が小さい$i$から順番に$B _ i = 1$としていくことにする。 上記操作を進めていく中で、配列$B$の$[l _ i, r _ i)$におけるRange Sum Queryの値がはじめて$k _ i + 1$以上になったときの$A _ i$がRange Kth Smallestの解である。 そして、クエリ結果が$k _ i + 1$以上になるかどうかは操作の進度に対して単調であるから、二分探索ができる。 各クエリの二分探索は並列化することで計算量を均す。 具体的には、$B _ i = 1$にしていく$N$回の操作1セットを行う途中に、すべてのクエリの二分探索を一段階進めることにする。 セグメント木を用いると、Range Sum Queryの更新1セット分が$O(N \\log N)$で、二分探索更新1セット分が$O(Q \\log N)$になる。 $O(\\log N)$セット行えばすべての二分探索が終わるので、全体$O((N + Q) \\log ^ 2 N)$ offlineかつ変更クエリなしのみ対応。 AC(879ms) 参考元 /// Range Kth Smallest (offlineかつstatic) /// 並列二分探索による解法 /// aの昇順に配列を構築していくと考える。aをどこまで使えば区間[li, ri]にki以上の要素が入るかを考えると、これは単調である。 /// よって、どこまで使うかを二分探索で求めることが出来る。その境界にある要素がまさにRange Kth Smallestの解である。 import std; void main () { int N, Q; readln.read(N, Q); auto a = readln.split.to!(int[]); auto l = new int[](Q); auto r = new int[](Q); auto k = new int[](Q); foreach (i; 0..Q) readln.read(l[i], r[i], k[i]); auto rsq = new SegmentTree!(int, (int a, int b) =\u0026gt; a + b, () =\u0026gt; 0)(N); auto ok = new int[](Q); auto ng = new int[](Q); auto mid = new int[](Q); ok[] = N - 1; ng[] = -1; auto value_ord = iota(N).array.sort!((i, j) =\u0026gt; a[i] \u0026lt; a[j]).array; auto query_ord = iota(Q).array; while (true) { bool end = () { foreach (i; 0..Q) if (1 \u0026lt; abs(ok[i] - ng[i])) return false; return true; }(); if (end) break; // セグメント木のリセット foreach (i; 0..N) rsq.set(i, 0); // midの計算 + midの昇順にソート foreach (i; 0..Q) mid[i] = (ok[i] + ng[i]) / 2; query_ord.sort!((i, j) =\u0026gt; mid[i] \u0026lt; mid[j]); int L = 0, R = 0; foreach (count, i; value_ord) { // 点追加 rsq.set(i, rsq.get(i) + 1); if (L \u0026lt; Q \u0026amp;\u0026amp; count == mid[query_ord[L]]) { while (R \u0026lt; Q) { if (mid[query_ord[R]] != count) break; R++; } // 二分探索を一段階進める foreach (U; L..R) { int qidx = query_ord[U]; bool f () { return k[qidx] + 1 \u0026lt;= rsq.prod(l[qidx], r[qidx]); } if (f()) { ok[qidx] = mid[qidx]; } else { ng[qidx] = mid[qidx]; } } L = R; } } } foreach (i; 0..Q) { writeln(a[value_ord[ok[i]]]); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } // セグメント木は省略 解法4 Mo\u0026rsquo;s algorithmと平方分割によるRange Sum Queryを用いる。 $A$を座標圧縮した後の値を横軸に、その値の出現回数を縦軸にとるRange Sum Queryを考える。 ある区間$[l _ i, r _ i)$のなかにある$A$の要素だけで上記Range Sum Queryを構築することにすると、$[0, x]$のRange Sum Queryがはじめて$k _ i + 1$以上になる$x$がRange Kth Smallestの解になる。 クエリ区間の巡回はMo\u0026rsquo;s algorithmにより$O(N \\sqrt{Q})$でできる。Range Sum Queryに平方分割を採用すると、Moの更新が$O(1)$、解の取得が$O(\\sqrt{N})$で出来る。(実はRange Sum Queryにセグメント木を用いるより高速になる。) 全体$O(Q \\sqrt{N} + N \\sqrt{Q})$ offlineかつ変更クエリなしのみ対応。 AC(372ms) 参考 1点更新range sumを平方分割でやると、更新がO(1)でクエリがO(√N)になって、Moと相性が良くなるの、おもしろ〜〜〜 \u0026mdash; けむにく＠競プロ (@kemuniku) May 7, 2024 /// Range Kth Smallest (offlineかつstatic) /// Mo\u0026#39;s algorithm + 平方分割rsqによる解法 /// aに含まれる要素で座標圧縮をし、横軸が座標圧縮後のindexとなるrsqを考える。 /// Moによって区間を巡回し、区間内の要素で上のrsqに積んでいくことにすると、[0, x)がはじめてkiを超える場所がRange Kth Smallestの解になる。 /// ここで、rsqに平方分割を採用すると、更新O(1)、ki以上の場所の取得がO(√N)であるから、全体O(Q√N + N√Q)で解ける。 /// 補足1: ki以上の場所がO(√N)になるからくり /// 先頭から足していくことにして、足して初めてki以上になるブロックを見つける。ここまでO(√N) /// ブロック内で厳密にkiになる場所を探す。ここでO(√N) /// 合計O(√N) /// 補足2: 座圧後のrsqで平方分割を使っているのは、セグメント木を用いるより全体の計算量が良くなるから。Mo\u0026#39;s algorithmでは移動が支配的なので、取得を多少遅くしたとしても更新を早くする方が有利になる。 import std; void main () { int N, Q; readln.read(N, Q); auto a = readln.split.to!(int[]); auto l = new int[](Q); auto r = new int[](Q); auto k = new int[](Q); auto ans = new int[](Q); foreach (i; 0..Q) readln.read(l[i], r[i], k[i]); // mo\u0026#39;s algorithmの準備 const int mo_width = max(1, sqrt(Q.to!double).to!int); auto priority = new int[](Q); foreach (i; 0..Q) priority[i] = l[i] / mo_width; bool less (int i, int j) { if (priority[i] == priority[j]) { if (priority[i] % 2 == 0) return r[i] \u0026lt; r[j]; return r[j] \u0026lt; r[i]; } return priority[i] \u0026lt; priority[j]; } auto query_ord = iota(Q).array.sort!(less).array; // 平方分割の準備 auto f = new int[](N); int max_f = 0; auto index = iota(N).array.sort!((i, j) =\u0026gt; a[i] \u0026lt; a[j]).array; auto b = a.dup.sort.uniq.array; { int L = 0, R = 0; while (L \u0026lt; N) { while (R \u0026lt; N) { if (a[index[L]] != a[index[R]]) break; R++; } foreach (U; L..R) { f[index[U]] = max_f; } max_f++; L = R; } } const int width = max(1, sqrt(max_f.to!double).to!int); auto block_count = new int[](max_f / width + 1); auto count = new int[](max_f + 1); int L = 0, R = 0; foreach (i; query_ord) { // 区間合わせ while (L \u0026lt; l[i]) { block_count[f[L] / width]--; count[f[L]]--; L++; } while (l[i] \u0026lt; L) { L--; block_count[f[L] / width]++; count[f[L]]++; } while (R \u0026lt; r[i]) { block_count[f[R] / width]++; count[f[R]]++; R++; } while (r[i] \u0026lt; R) { R--; block_count[f[R] / width]--; count[f[R]]--; } // 取得 int acc = 0; int cur_block = 0; while (acc + block_count[cur_block] \u0026lt; k[i] + 1) { acc += block_count[cur_block]; cur_block++; } // ブロック内走査 int cur = cur_block * width; while (acc + count[cur] \u0026lt; k[i] + 1) { acc += count[cur]; cur++; } ans[i] = b[cur]; } foreach (i; 0..Q) { writeln(ans[i]); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } おわりに 並列二分探索も平方分割も慣れない実装で辛かったです。ライブラリ化するかいい感じの実装方針を見つけないと実践で使える気がしません。 rectangle sumは実用性と汎用性のバランスが難しいなと悩む日々です。とりあえず定数倍とか無視して動くものを作ってみようかなと思っているんですが、なんだかんだ作るの面倒くさいですね。一方、簡潔でもコンパクトでもないビットベクトルなら実装できそうな気がするので、カスのwavelet matrix作ろうかなと検討中です。みなさんはどうしていますか？ MMA ContestとMaximum Cupの参加記録を書かなきゃいけないんですが、なかなか重い腰が上がりません。助けてほしい。 それでは。"
  },
  {
    url: "/post/cpp-copy-constructor/",
    title: "暗黙のコピーコンストラクタにご注意を",
    date: "2024-08-17T00:00:00+09:00",
    body: "暗黙のコピーコンストラクタにご注意を Hackで落とされた\u0026hellip; Educational Codeforces Round 169 (Rated for Div. 2) のD問題がHackされ、TLEで落ちました。 アルゴリズムは正しい自信があったので、定数倍で落ちていると思っていましたが、原因は意外なところにありました。 コピーコンストラクタの罠 落ちたコードを掲載します。 目的の街にいくために必要な中継のポータルは高々1つになるので、ポータルの色を決め打ちしてupper_boundで探しています。 これで8通りの色それぞれに2回upper_boundをすればよく、十分間に合うという感じです。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; using ll = long long; constexpr int iINF = 1\u0026#39;000\u0026#39;000\u0026#39;000; void solve () { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; // 中継は高々1回 // 中継のポータルを決め打ちして探索することで8 * 2 * logくらいでみつかる。 vector\u0026lt;string\u0026gt; portal(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; portal[i]; vector\u0026lt;int\u0026gt; ord(128); ord[\u0026#39;B\u0026#39;] = 0; ord[\u0026#39;G\u0026#39;] = 1; ord[\u0026#39;R\u0026#39;] = 2; ord[\u0026#39;Y\u0026#39;] = 3; map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt; mp; for (int i = 0; i \u0026lt; n; i++) { mp[portal[i]].push_back(i); } for (int i = 0; i \u0026lt; q; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--, y--; if (y \u0026lt; x) swap(x, y); int ans = iINF; // 中継ポータルを決め打ちする for (auto c1 : portal[x]) { for (auto c2 : portal[y]) { string key = \u0026#34;\u0026#34;; key += c1; key += c2; if (ord[key[1]] \u0026lt; ord[key[0]]) swap(key[0], key[1]); auto vec = mp[key]; { // xの左 auto it = upper_bound(vec.begin(), vec.end(), x); if (it != vec.end()) { ans = min(ans, abs(x - *it) + abs(*it - y)); } if (it != vec.begin()) { it--; ans = min(ans, abs(x - *it) + abs(*it - y)); } } { // yより右 auto it = upper_bound(vec.begin(), vec.end(), y); if (it != vec.end()) { ans = min(ans, abs(x - *it) + abs(*it - y)); } } } } if (ans == iINF) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } int main () { int t; cin \u0026gt;\u0026gt; t; for (int i = 0; i \u0026lt; t; i++) { solve(); } } TLEを引き起こしている場所は次の部分でした。(抜粋) // 中継ポータルを決め打ちする for (auto c1 : portal[x]) { for (auto c2 : portal[y]) { string key = \u0026#34;\u0026#34;; key += c1; key += c2; if (ord[key[1]] \u0026lt; ord[key[0]]) swap(key[0], key[1]); /* ↓これがダメ */ auto vec = mp[key]; { // xの左 ここで、のちのコードを記述しやすくするために、ポータルの色がkeyであるような街番号を昇順に格納したstd::vector\u0026lt;int\u0026gt;(すなわち、mp[key]のことです)をvecに代入しています。 このとき、実はmp[key]の長さ分のstd::vector\u0026lt;int\u0026gt;がいちいち作られていたようです。 正直C++の仕様には全然詳しくないので細かいことへの言及は避けますが、 CPP事始め: コピーコンストラクタ，代入演算子 によると、auto vec = mp[key];はコピーコンストラクタが呼ばれてしまうようです。 これを回避するためには、参照を利用するとよいです。すなわち、std::vector\u0026lt;int\u0026gt;\u0026amp;で受けます。 vector\u0026lt;int\u0026gt;\u0026amp; vec = mp[key]; auto\u0026amp; vec = mp[key]; // こうしても良い まとめ 色々見ている限り、C++では構造体やクラスなどは何も指定しなければコピーが走る傾向にあるようです。 皆様もC++で別の変数に参照を持つみたいなことをやろうとするときはお気をつけください。 最後に文句だけ言わせてください。 D言語なら動的配列の代入演算子は参照が渡されるからC++とかいうの許せね〜 これHackされなかったら830位くらいだったっていうのもマジで許せね〜(Hackされて3000位くらいまで落ちた) マジでレート返してくれ！！！ 参考 std::vector::operator= cpprefjp - C++日本語リファレンス CPP事始め: コピーコンストラクタ，代入演算子"
  },
  {
    url: "/post/ueccp-2024-first-half/",
    title: "UECCPバーチャルコンテストを発起し、完走した",
    date: "2024-08-08T00:00:00+09:00",
    body: "UECCPバーチャルコンテストを発起し、完走した UECCPバーチャルコンテストについて 私が電通大競プログラミングサークルに呼びかけて、4月から8月までAtCoder Problemsを利用したバーチャルコンテストを週1回開催しました。 某H先生のご厚意により、競プロサークルで利用できる教室があったため、そこをオンサイト会場(笑)として利用しました。 4月22日から8月5日まで合計13回開催しました。 第一回 第二回 第三回 第四回 第五回 第六回 第七回 第八回 第九回 第十回 第十一回 第十二回 第十三回 まえがき 本エントリでは、しばらくのあいだUECCPバーチャルコンテストを定期開催して感じたことなど適当に書こうと思います。 きっかけ せっかくUECCPという形で有志が集まっているのだから、なにか競技プログラミングの定期イベント的なものがあれば嬉しいなとずっと思っていました。 2023年前期はsepa_38さんが声掛けをして、ABC振り返り回的なものを行っていました。 しかし、その集まりも前期終盤になってなあなあで消滅してしまったりと、アクティブに活動する方は多くないという印象がありました。 こういった事情で、私がやりたいことは私が始めるしか無いなと思い、一念発起してみました。 私は競技プログラミングの話をするだけでも十分に楽しいので、あまりやることを固めていませんでした。 今になって思えばそんな集まり誰が来たいんだよという感じがあるので、バーチャルコンテストをやることにして正解でした。バーチャルコンテストを提案してくれたdyktr_06さんに感謝です。 実際に行ってみて 初回は物珍しさ + 学期はじめでスケジュールが楽な人が多かった(?)ため、沢山の人が参加してくれました。そのため椅子が足りなくなり、私は膝立ちでプログラムを書いていました。膝、めちゃくちゃ痛かったです。 所属「The University of Electro-Communications」で順位表によくいる人に実際に合ってお話する機会にもなりました。 第二回以降は人数も落ち着いて、だいたい同じ人が参加するようになりました。幸運なことに、私とレート帯の近い方がよく参加してくれたため、特にお話していて楽しかったです。 途中からdyktr_06さんにより UECCP Viewer という各回の結果を見れるツールが開発されました。(スゴイ) 終わっての感想 全体的にやってよかったなと思います。他の競技プログラミング勢とお話することは、私にとってとても新鮮で、毎週の楽しみでした。 しばらくは同じ部屋を利用させていただけそうな感じがするので、できるだけずっと開催したいと思います。 参加していただいた皆さん、ありがとうございました。またお願いします。 各回で一番好きな問題 第一回 ABC281E - Least Elements Priority sumという興味深いアルゴリズムを適用できる問題です。全順序と加法のような二項演算の定まった要素の集合において、順序の(高い/低い)順に先頭$K$個の和を求めることができます。いい感じの平衡二分木を使えば都度$K$を変更することもできます。整数しか扱わないといった制約をいくつか入れると、より簡単に$K$を変更できるようになります。 第二回 ABC281D - Max Multiple 迷いましたがこれにしました。私が競技プログラミングをはじめた頃に出題されて、わから無さすぎて困った思い出の問題です。典型的な取る/取らないdpとして解釈できます。この問題から多くを学びました。 第三回 ABC277E - Crystal Switches グラフ多重化典型で解くことができます。この手の問題は自力で解法にたどり着くのが非常に難しいと考えています。私がグラフ探索の可能性を感じ始めた思い出の一問です。 第四回 ABC188E - Peddler dpについて考えるきっかけをくれた問題です。 陽なDAG上のdpを楽に処理する はこの問題の解法に感動したのがきっかけで書きました。 第五回 ABC132D - Blue and Red Balls 組み合わせや場合の数に関する知識が問われる問題です。高校時代に非常に苦手だったジャンルですが、このような問題を解くうちに少しずつお気持ちがわかってきています。 第六回 ABC298E - Unfair Sugoroku 確率/期待値の知識が問われる問題です。この手の問題は未だに苦手ですが、多分競技プログラミングで最も「数学」な部分なのでつい頑張って考えてしまいます。 好きではないですが、一番思い出深いということでここにあげました。 第七回 キーエンスプログラミングコンテスト2021C - Robot on Grid バーチャルコンテストではじめて出会ったタイプの問題でした。解釈は2通りあります。ロボットの移動経路が何通りあるかの期待値を考える方法と、一つの経路からの主客転倒により数え上げる方法です。このタイプの問題についての解法はまだ自分の中に確立した理論がありませんが、この2通りの解釈はほぼ等価なのではないかという予想をしています。 第八回 ABC257C - Robot Takahashi difficultyの割に難しいと思っています。問題分の正確な理解とシンプルな実装方針を取れるかによって体感難易度が大きく変化します。間違いなく良問です。 第九回 ABC317E - Avoid Eye Contact 解法自体はすっと見える人が多そうですが、きちんとACを得るには正確かつ高速な実装が要求されます。 下手な実装だと実行時間制限がかなり厳しくなりそうです。 グリッドの下処理は4方向でやってしまうのが良いという謎の典型でもあります。 第十回 ARC127A - Leading 1s 桁dpとして解くことができます。この問題を考察しているうちに、桁dpへの理解が非常に深まりました。これまで私は桁dpを蛇蝎のごとく嫌っていましたが、この問題を通して好きになりかけています。 第十一回 ARC114A - Not coprime ARCらしい発想の転換が必要な問題です。$X$側から$Y$を構築するのは難しそうなので、$X _ i \\leq 50$の制約をうまく利用して解きます。 第十二回 ABC240F - Sum Sum Max 累積和の累積和という非常にややこしいものについて考える必要があります。累積和が最大値を取るときとはどのような時であるかを丁寧に考察する必要があります。 実装も方針によっては簡単に破滅してしまう問題なので、十分な経験と自力が必要です。 ちなみに、累積累積和に$x _ i$がどのように関与するかの絵を書くと解きやすいです。 第十三回 ABC266F - Well-defined Path Queries on a Namori なもりグラフの閉路を成す頂点集合を列挙するという典型問題が解ければ比較的簡単です。 functional graphと異なり、強連結成分分解を振り回せないので少し面倒です。 こちらも実装方針をちゃんと選ばないと実装が爆発しがちです。 以上です。ぜひ解いてみてください。 このリスト書くのに1時間くらいかかりました。疲れた\u0026hellip;"
  },
  {
    url: "/post/dp-in-explicit-dag/",
    title: "[覚書] 陽なDAG上のdpを楽に処理する",
    date: "2024-05-27T00:00:00+09:00",
    body: "[覚書] 陽なDAG上のdpを楽に処理する 定義 本稿におけるDAGとは、次のことを指します。 有向グラフ$G$であって、任意の$v \\in V(G)$に対して次の条件を満たすもの。 始点と終点が$v$であり、かつ少なくとも一つの辺を通る経路が存在しない。 概要 AtCoderの過去問は、暗黙的なDAG上のdpが多い一方、明示的なDAG上のdpをする問題が少ないです。 そのため、明示的なDAGを渡されたとき、dpをすればよいということがわかっていたとしてもうまい実装が思い浮かばない方は多いかと思います。 私もそのような場面に何回か出くわし、そのせいで大幅にパフォーマンスを落とした経験があります。 そこで、それなりに汎用的であると思われるやり方を提案します。 なお、これは「灯台下暗し」的なもので、人によっては自明かと思います。 明示的なDAGのどこがしんどいのか まずは、しんどくないdpについて考えましょう。 たとえば、よくある$$\\mathrm{dp}\\lbrack i \\rbrack \\lbrack j \\rbrack \\coloneqq (\\text{$i$番目までを見たときに、\u0026hellip;が$j$であるような\u0026hellip;})$$といった形のdpは、 $$\\mathrm{dp}\\lbrack i + 1 \\rbrack \\lbrack j \\rbrack = f(\\mathrm{dp} \\lbrack i \\rbrack \\lbrack k \\rbrack)$$ といった形の計算により処理できることが多いです。この場合、単純なループ処理だけで計算ができます。更新順は、$i$を深さと見たときのbfs順ととらえることもできます。 さらに、木上のdpも非常に簡単に処理することができます。 これは木上の2点間のパスが一意に定まることが理由です。例えば、ある頂点から始めて配る遷移のdpをすることを考えます。 このとき、パスの一意性から1回目に出会った頂点の値を確定してしまってよいことがいえます。 つまり、普通にdfs巡回順で更新していくだけで正しい値が求まります。 これらのdpがbfsやdfs巡回順と同じ順番で出来るのは、ある程度単純なトポロジカル順序を持っているからと言えそうです。 では、一般のDAGではどうでしょうか。 結論から言うと、配る遷移をするとき、単純なdfsやbfs巡回順で更新すると値が壊れるようなケースが存在します。さらに、そのようなケースは極めて一般的です。 上の図はそのようなグラフの例です。例えば頂点4の値を正しく求めるには、頂点1と頂点2から配られた値が必要なはずです。 しかし、普通にbfsやdfsをすると、いつ頂点4の値が確定するかがわからないため、他の変数などを管理する必要が出てきます。 遷移以外に変数を管理する必要があるため、より面倒になりがちです。 一般のDAG上でのdpのしんどさについて説明したところで、次は処理方法の説明に入ります。 配るdp 頂点をトポロジカルソートをすると、dp部分をいつもの更新とほぼ同様に扱えます。 多くの場合は次の手順で解けると思います。 頂点をトポロジカルソートする。 頂点における答えを記録しておく配列に対して、スタート地点以外をすべて異常値で初期化しておく。 トポロジカルソートされた順番に頂点を見ていき、異常値なら無視、正常値なら遷移とする。 異常値を無視している理由は、一般のDAGの場合スタート地点の入次数が0とは限らないからです。スタート地点ではない場所からの遷移で値が壊れるのを防止しています。 ABC335E に適用してみましょう。 この問題は、重みが等しい頂点をまとめて、重みが真に大きい方向にのみ辺を作ったDAGを考えると、最長経路問題に帰着します。 最長経路問題は配る遷移で解くことができるので、上記の方法を適用できます。 本稿で提案しているのはこの部分です。 いつものdpとほとんど同様に遷移できていることがわかると思います。 auto update_ord = topological_sort(graph); foreach (v; update_ord) { if (dist[v] == -1) continue; foreach (to; graph[v]) { dist[to] = max(dist[to], dist[v] + 1); } } 提出 もう一問例題を挙げておきます。 yukicoder No.2639 を考えましょう。 こちらもグリッドグラフであることを除けばほぼ同じです。グリッドグラフからDAGを構築して、トポロジカルソートしましょう。 auto update_ord = topological_sort(graph); vector\u0026lt;int\u0026gt; score(H * W, 1); for (auto v: update_ord) { for (auto nex: graph[v]) { score[nex] = max(score[nex], score[v] + 1); } } 提出 もらうdp こちらの方が楽です。自分の子の値が確定してしまえばよいので、確定するまで再帰的に掘っていけば良いです。すなわち、メモ化再帰で実装するのが楽です。 この方法は意識せずに行っている方が多いかと思います。典型的な例でいうと、ゲームの後退解析などはこの例に当てはまります。 陽にグラフが与えられていたとしても、やることは同じです。 こちらも例題を提示しておきます。 ABC188E を考えましょう。この問題は下流のDAGに属する頂点の最大の値が求まればよいです。 $\\mathrm{dp}\\lbrack i \\rbrack \\coloneqq (\\text{頂点$i$より下流のDAGに属する頂点における最大の$A$})$とすると、子からもらう遷移になります。 具体的には、次のような遷移になります。 int[int] memo; int dp (int pos) { if (pos in memo) return memo[pos]; int res = -int.max; foreach (to; graph[pos]) { res = max(res, dp(to), A[to]); } return memo[pos] = res; } メモ化しないと計算が爆発するので注意です。 提出 終わりに 今週のUECCPでABC188Eを解きなおした際、mid_さんがこのメモ化再帰の解法について言及していたことがきっかけでこのエントリを作成しました。 今振り返ると、今までの自分はトポロジカルソートとdp更新を同時にやっていくようなあまり賢くない解法をとっていて、さらにそれが賢くないことに気づいてすらいなかったようです。 このエントリが、私の様に陽なDAG上でのdpに苦しむ人の助けになれば幸いです。"
  },
  {
    url: "/post/yukicoder2758/",
    title: "No.2758 RDQ",
    date: "2024-05-18T00:00:00+09:00",
    body: "No.2758 RDQ 問題概要 問題へのリンク 問題文 長さ$N$の数列$A = (A _ 1, A _ 2, \\dots, A _ N)$が与えられる。次の$Q$個の質問に答えよ。 区間$\\lbrack L, R \\rbrack$の要素$A _ L, A _ {L + 1}, \\dots, A _ R$のうち、$K$の倍数はいくつ存在するか。 制約 $2 \\leq N \\leq 5 \\times 10^4$ $1 \\leq Q \\leq 5 \\times 10^4$ $1 \\leq A _ i \\leq 10^5$ $1 \\leq L _ j \u0026lt; R _ j \\leq N \\, (1 \\leq j \\leq Q)$ $1 \\leq K _ j \\leq 10^5$ 解法 素直な方針として、次のものが思いつく。 「$10^5$以下のすべての法について、$A _ i$が法で割り切れるなら$1$、割り切れないなら$0$とした数列を作成し、累積和をとっておく。 クエリに答えるパートでは、$K _ j$を法とした累積和配列を$\\mathrm{acc} _ {K _ j}$としたとき、$\\mathrm{acc} _ {K _ j} \\lbrack R _ j \\rbrack - \\mathrm{acc} _ {K _ j} \\lbrack L _ j - 1 \\rbrack$を答える。」 しかし、これは空間/時間ともに$\\mathcal{O}(10^5 N)$が必要であり、間に合わない。 そこで、クエリで要求される区間だけを見ることでうまく解けないかを考えてみる。 Mo\u0026rsquo;s algorithmを適用する。 これにより全体の移動回数$\\mathcal{O} (N \\sqrt{Q})$で次の配列$B$をクエリごとに得ることができる。 $$B \\lbrack i \\rbrack \\coloneqq (\\text{$\\lbrack L _ j, R _ j \\rbrack$に含まれる$i$の数})$$ この配列$B$を用いて$K$の倍数をカウントすることを考える。 この時クエリあたり$\\mathcal{O}((\\text{配列$B$の長さ}) / K)$回の計算が必要で、十分大きな$K$に対してなら間に合う。 $K$の値が小さなときがボトルネックになっているので、その時は別の解法に切り替えるようにしよう。 十分小さな$K$に対しては集計がネックになる代わりに、空間をあまり使わずに前計算ができることが多い。 以降、$M = (\\text{配列$B$の長さ})$とする。本問題においては$1$以上$\\sqrt{M}$以下の数に対して「素直な方針」を適用すると、数学的にある程度最善になる事が見込める。 この前計算に必要なメモリは$\\mathcal{O}(N \\sqrt{M})$で、制約の上で十分実現できる。 これで全体$\\mathcal{O}(N \\sqrt{Q} + (N + Q) \\sqrt{M})$で解ける。 公式解説の方法も理解しておこう。実はこの問題は、最初説明した「素直な方針」を拡張することでもっと楽に解ける。 「$A _ i$が法で割り切れるなら$1$、割り切れないなら$0$とした数列」というものを考えたが、実は$A _ i$を割り切る法は制約において十分に少ない。 そこで、$1$になる要素だけをメモリに記録しておくことで、大幅に高速化することができる。 「$A _ i$を割り切る法」というのはすなわち$A _ i$の約数であるから、「素直な方針」で$1$になる要素の数は高度合成数を用いて上から評価できる。 高度合成数の一覧 を見ると、$114N$で抑えることができ、これは制約下で可能である。 具体的なやり方としては、例えばvectorを要素に持つmapを用いる方法がある。空でない配列に対して「本来$1$になるインデックス」を昇順に保持するという感じになる。実装例を参照されたい。 座標圧縮を用いてmapを使用しないこともできると思う。 この方針では約数関数を$\\mathrm{d}(x)$として、$\\mathcal{O}(N \\mathrm{d}(\\max A) + Q \\log N)$となる。 実装例 Mo + 平方分割 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;tuple\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; using ll = long long; int main () { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; vector\u0026lt;int\u0026gt; A(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; // 賢いやり方不明。 // ある程度大きなKに対してはMoを適用し、小さなKに対しては空間N√Nで計算しながらやる。 vector\u0026lt;int\u0026gt; L(Q), R(Q), K(Q); for (int i = 0; i \u0026lt; Q; i++) { cin \u0026gt;\u0026gt; L[i] \u0026gt;\u0026gt; R[i] \u0026gt;\u0026gt; K[i]; L[i]--; // 0-indexedで開区間 } vector\u0026lt;int\u0026gt; index(Q), priority(Q); const int width = (int) sqrt((double) Q) + 10; for (int i = 0; i \u0026lt; Q; i++) { index[i] = i; priority[i] = L[i] / width; } sort(index.begin(), index.end(), [\u0026amp;](int x, int y) { if (priority[x] == priority[y]) { if ((priority[x]) % 2 == 0) return R[x] \u0026lt; R[y]; return R[y] \u0026lt; R[x]; } return priority[x] \u0026lt; priority[y]; }); const int max_mod = 100000; const int sqrt_N = (int) sqrt((double) N); vector\u0026lt;int\u0026gt; count_all(max_mod + 1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; acc(sqrt_N, vector\u0026lt;int\u0026gt;(N + 1, 0)); // 前計算 for (int i = 1; i \u0026lt; sqrt_N; i++) { for (int j = 0; j \u0026lt; N; j++) { int add = 0; if (A[j] % i == 0) add = 1; acc[i][j + 1] = acc[i][j] + add; } } vector\u0026lt;int\u0026gt; ans(Q); int l = 0, r = 0; // [l, r) for (int i = 0; i \u0026lt; Q; i++) { int idx = index[i]; while (l \u0026lt; L[idx]) { count_all[A[l]]--; l++; } while (L[idx] \u0026lt; l) { l--; count_all[A[l]]++; } while (r \u0026lt; R[idx]) { count_all[A[r]]++; r++; } while (R[idx] \u0026lt; r) { r--; count_all[A[r]]--; } if (K[idx] \u0026lt; sqrt_N) { ans[idx] = acc[K[idx]][R[idx]] - acc[K[idx]][L[idx]]; } else { int cur = K[idx]; while (cur \u0026lt;= max_mod) { ans[idx] += count_all[cur]; cur += K[idx]; } } } for (auto v : ans) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 実装例(約数列挙) #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; divisors (int N) { vector\u0026lt;int\u0026gt; res; for (int i = 1; 1LL * i * i \u0026lt;= N; i++) { if (0 \u0026lt; (N % i)) continue; res.push_back(i); if (1LL * i * i == N) continue; res.push_back(N / i); } sort(res.begin(), res.end()); return res; } int main () { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; vector\u0026lt;int\u0026gt; A(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; acc; for (int i = 0; i \u0026lt; N; i++) { for (auto d : divisors(A[i])) { acc[d].push_back(i); } } for (int i = 0; i \u0026lt; Q; i++) { int L, R, K; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; K; L--, R--; auto lit = lower_bound(acc[K].begin(), acc[K].end(), L); auto rit = upper_bound(acc[K].begin(), acc[K].end(), R); cout \u0026lt;\u0026lt; (rit - lit) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 終わりに つくづくMo\u0026rsquo;s algorithmは便利だなと思った。 後から考えてみると、私の解法はかなり行き当たりばったりでゴリ押し解法であるように感じる。 C++のイテレータあたりの仕様やテクニックが全然わからないため、公式解説の方法を実装するときにどうしたらよいか困った。 ランダムアクセスイテレータのインクリメントやデクリメントは変なバグやUBを踏みそうで怖い。"
  },
  {
    url: "/post/abc352/",
    title: "ABC352参加記録",
    date: "2024-05-06T00:00:00+09:00",
    body: "ABC352参加記録 はじめに いくつかの理由でしばらく更新していませんでしたが、久しぶりに更新することにしました。 戦績 順位: 771th パフォーマンス: 1697 レーティング変動: 1509 → 1529 (+20) 問題の振り返り ABC352のリンク A - AtCoder Line 問題リンク 駅$Z$が駅$X$と駅$Y$の間にあれば行くことができます。逆に、そうでない時は行くことができません。 したがって、$\\min(X, Y) \u0026lt; Z \u0026lt; \\max(X, Y)$が真であるかどうかで判定することができます。 import std; void main () { int N, X, Y, Z; readln.read(N, X, Y, Z); if (min(X, Y) \u0026lt; Z \u0026amp;\u0026amp; Z \u0026lt; max(X, Y)) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Typing 問題リンク なかなかの難読です。 題意としては次のような感じです。 $S$を部分列として含む$T$が与えられる。$T$の部分列$S$であって、インデックスが辞書順最小であるものを求めよ。 これは$T$を前から見ていき、$S$の文字を貪欲にとっていくことで達成できます。 import std; void main () { string S = readln.chomp; string T = readln.chomp; int[] ans; int lat = 0; foreach (i, t; T) { if (S.length \u0026lt;= lat) continue; if (S[lat] == t) { lat++; ans ~= i.to!int + 1; } } foreach (i, a; ans) { write(a, i == ans.length - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Standing On The Shoulders 問題へのリンク 求める答えは、$\\max _ {1 \\leq i \\leq N} (\\text{(巨人$i$を除いた肩までの高さの総和)} + \\text{(巨人$i$の頭までの高さ)})$です。 累積和をとると、一人を除いた肩までの高さの総和を$\\mathcal{O}(1)$で求めることができます。 よって、全体の計算量オーダー$\\mathcal{O}(N)$で求めることができます。 import std; void main () { int N = readln.chomp.to!int; auto height = new Tuple!(int, int)[](N); foreach (i; 0..N) { int A, B; readln.read(A, B); height[i] = tuple(A, B); } // 累積和でOK auto acc = new long[](N + 1); acc[0] = 0; foreach (i; 0..N) { acc[i + 1] = acc[i] + height[i][0]; } long ans = 0; foreach (i; 0..N) { // i人目を最後に立たせる。 long v = acc[i] + (acc[N] - acc[i + 1]); v += height[i][1]; ans = max(ans, v); } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } また、$\\text{(肩までの高さ)} \\leq \\text{(頭までの高さ)}$が成立するため、求める答えは$\\text{(肩までの高さの総和)} + \\max _ {1 \\leq i \\leq N}(\\text{(巨人$i$の頭までの高さ)} - \\text{(巨人$i$の肩までの高さ)})$とも表すことができます。こちらも$\\mathcal{O}(N)$で解けますし、楽です。 import std; void main () { int N = readln.chomp.to!int; long ans = 0; int diff_max = 0; foreach (i; 0..N) { int A, B; readln.read(A, B); ans += A; diff_max = max(diff_max, B - A); } ans += diff_max; writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Permutation Subsequence 問題リンク 求める値は、$\\min _ {1 \\leq i \\leq N - K + 1}(\\text{($i$から$i + K - 1$のすべての数を含む最小の連続部分列の長さ)})$と表すことができます。 すなわち、上記のような連続部分列の右端と左端のインデックスにのみ興味があります。 ここで、$\\mathrm{index}[i] = \\text{($i$のインデックス)}$を導入します。 これを用いると、上の値は$\\max _ {i \\leq x \\leq i + K - 1} (\\mathrm{index}[x]) - \\min _ {i \\leq x \\leq i + K - 1} (\\mathrm{index}[x])$ になります。 すなわち、長さ$K$の連続部分列の最大/最小を求める問題に帰着しました。 これをセグメントツリーを用いて求めると計算量オーダー$\\mathcal{O}((N - K) \\log N)$で解けます。 import std; void main () { int N, K; readln.read(N, K); auto P = readln.split.to!(int[]); P[] -= 1; solve(N, K, P); } void solve (int N, int K, int[] P) { // static range min queryとstatic range max queryが解ければよい。 auto RmQ = new SegmentTree!(int, (int a, int b) =\u0026gt; min(a, b), () =\u0026gt; int.max)(N); auto RMQ = new SegmentTree!(int, (int a, int b) =\u0026gt; max(a, b), () =\u0026gt; -int.max)(N); foreach (i; 0..N) { RmQ.set(P[i], i); RMQ.set(P[i], i); } int ans = int.max; foreach (i; 0..N) { if (N \u0026lt; i + K) break; ans = min(ans, RMQ.prod(i, i + K) - RmQ.prod(i, i + K)); } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } セグメントツリーは長いので省略しました。 また、連続部分列の最大/最小値を求めるまでの考察は同じですが、平衡二分木を用いる解法もあります。 $i$から$i + K - 1$の連続部分列に対する値を求めた後、$i + 1$から$i + K$の連続部分列に対する値を求めることを考えると、$\\mathcal{O}(1)$個の要素をremove/insertするだけで良いです。 これを続ける事で$\\mathcal{O}(N \\log N)$で解くことができます。 import std; void main () { int N, K; readln.read(N, K); auto P = readln.split.to!(int[]); P[] -= 1; solve(N, K, P); } void solve(int N, int K, int[] P) { auto rbt = new RedBlackTree!(int, \u0026#34;a \u0026lt; b\u0026#34;, true)(); auto index = new int[](N); foreach (i; 0..N) index[P[i]] = i; foreach (i; 0..K - 1) rbt.insert(index[i]); int ans = int.max; foreach (i; K - 1..N) { rbt.insert(index[i]); ans = min(ans, rbt.back() - rbt.front()); rbt.removeKey(index[i - K + 1]); } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 私はセグメントツリーを用いる解法の方が先に出てきましたが、後者で解いた人が多いみたいです。 E - Clique Connect 問題リンク クラスカル法を適用することを考えます。 すなわち、できるだけ安い辺を用いて連結成分を伸ばしていきます。 $A _ i$に含まれる頂点が一つの連結成分に属するようにしていき、最後に全体が連結であればよいです。 というわけで、$A _ i$に含まれる頂点を連結にする最安の方法がわかればよいです。 これは$A _ i$の全域木の一つをとればよいです。 例えば辺$e = (A _ {i, j}, A _ {i, j + 1})$をすべて見ることで達成できます。 import std; void main () { int N, M; readln.read(N, M); auto K = new int[](M); auto C = new int[](M); auto A = new int[][](M, 0); foreach (i; 0..M) { readln.read(K[i], C[i]); A[i] = readln.split.to!(int[]); A[i][] -= 1; } solve(N, M, K, C, A); } void solve (int N, int M, int[] K, int[] C, int[][] A) { // クラスカル法に突っ込む auto UF = UnionFind(N); auto index = iota(M).array(); index.sort!((a, b) =\u0026gt; (C[a] \u0026lt; C[b])); long ans = 0; foreach (i; index) { foreach (j; 0..K[i] - 1) { if (UF.same(A[i][j], A[i][j + 1])) continue; UF.unite(A[i][j], A[i][j + 1]); ans += C[i]; } } int cc = 0; foreach (i; 0..N) if (UF.root(i) == i) cc++; if (1 \u0026lt; cc) { writeln(-1); } else { writeln(ans); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } UnionFindの実装は省略しました。 本番では超頂点をかませる微妙に怪しい方針でACしたため、こっちだけ載せておきます。 あと、「クリーク」という単語を知らなかったため調べてみました。 クリーク(グラフ理論) - Wikipedia ざっくりいうと、グラフ$G$の極大な完全部分グラフのことをクリークと呼ぶらしいです。 この問題名との関連性で言うと、$A _ i$の中で出来るだけ辺をはると頂点数$K[i]$のクリークになるからということでしょうか。 F - Estimate Order 問題リンク 微妙に間に合わずACを逃しましたが、upsolveしたので載せておきます。 とりあえず、与えられた情報をできるだけ、すなわち、ある人が出てくる情報が高々1つになるようにまとめます。 こうすることで、わかっている順位の情報はパズルピースのようになります。 例えば、入力例3は 1______8 27__6 54 3 という4ピースになります。 このようにしてできたピースを組み合わせて、横幅$N$マスのパズルを完成させます。 さて、順位情報が確定できるというのは次のように言い換えることができます。 ピース$i$がある1つの場所以外にはめられた場合、他のピースをどのようにはめてもパズルを完成させることができない。 これをどうにか判定したいです。 というわけで、自分以外のピースを用いたときに実現できる盤面を列挙できれば良いです。 ピース数がそこそこ大きいため、単純な全探索は通りません。(多分) そこで、次の動的計画法を適用します。 $$\\mathrm{dp}[i][S] \\coloneqq (\\text{先頭$i$個のピースを用いて盤面$S$を実現できるか})$$ $$\\mathrm{rdp}[i][S] \\coloneqq (\\text{後ろ$i$個のピースを用いて盤面$S$を実現できるか})$$ これは$\\mathcal{O}(N 2^N)$で計算できます。 このテーブルを用いることで、一つのピースが確定できるかを$\\mathcal{O}(N 2^N)$で判定できます。 これで、全体$\\mathcal{O}(N^2 2^N)$になります。 import std; void main () { int N, M; readln.read(N, M); auto info = new Tuple!(int, int, int)[](M); foreach (i; 0..M) { int A, B, C; readln.read(A, B, C); info[i] = tuple(A, B, C); } solve(N, M, info); } void solve (int N, int M, Tuple!(int, int, int)[] info) { // 連結成分がパズルピースみたいになって順位が確定する。 // dfsによる探索だと間に合わない。 -\u0026gt; bitDPで埋めていく感じでできそう。 // ピースを作るよ // ここがバグっていると思う。具体的には、現状の手法だと本来連結なのに連結でないと判定されてしまうようなピースが存在しうる。 int[][] piece; // BFSでうまいことやりましょう。 auto vis = new bool[](M); { auto Q = DList!(int)(); void bfs (int cur) { Q.insertBack(cur); // 新規作成 piece ~= new int[](60); auto p = piece[$ - 1]; p[] = -1; while (!Q.empty) { auto h = Q.front(); Q.removeFront(); vis[h] = true; { // 追加処理 bool add = false; () { foreach (index, v; p) { if (v == info[h][0] || v == info[h][1]) { add = true; if (v == info[h][0]) p[index - info[h][2]] = info[h][1]; if (v == info[h][1]) p[index + info[h][2]] = info[h][0]; return; } } }(); if (!add) { p[30] = info[h][0]; p[30 - info[h][2]] = info[h][1]; } } foreach (index, I; info) { if (!(I[0] == info[h][0] || I[1] == info[h][0] || I[0] == info[h][1] || I[1] == info[h][1])) continue; if (vis[index]) continue; Q.insertBack(index.to!int); } } } foreach (i; 0..M) { if (vis[i]) continue; bfs(i); } } // 存在しない人を入れるよ { bool[int] mp; foreach (I; info) mp[I[0]] = mp[I[1]] = true; foreach (i; 1..N + 1) if (i !in mp) { piece ~= [i]; } } // 前に詰めるよ + 後ろも詰めるよ foreach (ref p; piece) { foreach (i; 0..p.length) if (p[i] != -1) { p = p[i..$]; break; } foreach_reverse (i; 0..p.length) if (p[i] != -1) { p = p[0..i + 1]; break; } } // bit変換するよ auto piece_bit = new int[](piece.length); foreach (i; 0..piece.length) { foreach (j, v; piece[i]) { if (v == -1) continue; piece_bit[i] |= 1 \u0026lt;\u0026lt; j; } } int pN = piece_bit.length.to!int; // dp[i][S] := 先頭iピースを用いてSを達成できるか？ auto dp = new bool[][](pN + 1, 1 \u0026lt;\u0026lt; N); dp[0][0] = true; foreach (i; 0..pN) { foreach (S; 0..(1 \u0026lt;\u0026lt; N)) { if (!dp[i][S]) continue; int p = piece_bit[i]; while ((p | S) \u0026lt; (1 \u0026lt;\u0026lt; N)) { if ((p \u0026amp; S) == 0) dp[i + 1][S | p] = true; p \u0026lt;\u0026lt;= 1; } } } auto rdp = new bool[][](pN + 1, 1 \u0026lt;\u0026lt; N); // rdp[i][S] := 後ろiピースを用いてSを達成できるか？ rdp[0][0] = true; foreach (i; 0..pN) { foreach (S; 0..(1 \u0026lt;\u0026lt; N)) { if (!rdp[i][S]) continue; int p = piece_bit[pN - i - 1]; while ((p | S) \u0026lt; (1 \u0026lt;\u0026lt; N)) { if ((p \u0026amp; S) == 0) rdp[i + 1][S | p] = true; p \u0026lt;\u0026lt;= 1; } } } // 判定 auto ans = new int[](N); ans[] = -1; foreach (i; 0..pN) { int p = piece_bit[i]; int pad = 0; int lpad = 0; int count = 0; while (p \u0026lt; (1 \u0026lt;\u0026lt; N)) { foreach (S; 0..(1 \u0026lt;\u0026lt; N)) { if (0 \u0026lt; (p \u0026amp; S)) continue; int complement = (1 \u0026lt;\u0026lt; N) - 1 - (p | S); if (dp[i][S] \u0026amp;\u0026amp; rdp[pN - i - 1][complement]) { lpad = pad; count++; break; } } pad++; p \u0026lt;\u0026lt;= 1; } if (1 \u0026lt; count) continue; foreach (index, v; piece[i]) { if (v == -1) continue; ans[v - 1] = (index + lpad + 1).to!int; } } foreach (i, a; ans) { write(a, i == ans.length - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } ピースの構築をうまくやる方法が思い浮かばず、かなり汚いコードになってしまいました。 初めてのdifficulty2000+のACです。わーい。 あまり関係ない話 本編はおしまいです。ここまで読んでいただきありがとうございます。 残りは参加記録を書くという建前がないと書けない、とるに足らない話を書きます。 物好きな人は読んでいってください。 1か月前くらいから累積和の変数をaccにすることに変えました。accumulateから来ています。 プログラムを書き始めたころからこういった微細な変化を積み上げてここまで来ましたが、積み重ねによりかなり原型から離れてきた実感があります。 いつか歴史を編纂したいなという野望だけがありますが、面倒くさいので多分やりません。 僕がAtCoderを始めた2022年11月あたりの提出を見てみると、今とはかなり異なるスタイルで書いていることがわかります。(言語も異なりますし。) 微細な変更つながりで言うと、今回のエントリからビッグオーを$O$ではなく$\\mathcal{O}$に変更してみました。ちょっとかっこいいですよね。 しばらくkatexを書いているので、結構書き方に慣れてきました。私のkatexは基本的に MathJaxとMarkdownで可搬性のある数式を書くには に沿うようにしています。これ実際すごくお勧めです。 最近僕のわがままで電通大競プロサークルの人を招集してバチャをやるという企画をやっています。 前回は昔からTwitterをフォローしてもらっているtetorapentagonさんに会ったり、PG battleでチームを組んだryotaさんと会ったりしました。 みなさんとても賢そうな印象でした。ずっとわけわからないことを言っている僕が浮いていないかすごく心配になります。 ともかく、皆さん参加ありがとうございます。また競技プログラミングの話をしましょう。 僕は結構Twitterを見ています。しかし、Twitterが僕に及ぼす悪影響が大きいなと思うことが多くなってきました。 競技プログラミングに関する話題によって精神的に参ってしまいそうになります。 少し距離を置こうと思います。 何に参ってしまいそうになるのかというと、やっぱり「隣の芝は青い」現象です。あまり詳細な言及は避けますが、自己肯定感がとんでもなく下がるような投稿が目についてしまい、苦しいです。 元来僕は謎に負けず嫌いであるというのもあり、精神的に良くないです。 これはレーティングシステムにも言える話です。最近、レーティングばかり気にする悪癖が再開している実感があります。1200にのるかどうかくらいの時もこういうことがありました。 これはレーティングというもの自体が抱える問題なので、簡単に避けるのは難しいです。しかし、レーティングはやはり価値評価の一側面でしかないということを念頭に置く必要があるでしょう。 ratismという単語がありますが、これは最もバカバカしいものであり、避けなければならない意識を持たねばなりません。 重要なのはレートではなく、より多くのアルゴリズム、データ構造についての知識をつけ、熟練することです。 僕の当面の目標は、拡張ユークリッド互除法の詳細な理解と、Treapの理論と実装を学ぶことです。 満足したらエントリにしたいです。気力が続けばですが。 大学が始まって1ヵ月くらい経ちましたが、結構忙しくてまいっています。参加記録を書くだけの精神的余裕がない原因のほぼすべてがこれです。 というわけで、また少しさぼってしまう見込みです。新しいエントリが出たときは何かを犠牲にしているかえらいかの2択になる見込みです。(実際、エントリを書くのって3時間くらいはかかるので\u0026hellip;) ではまた。"
  },
  {
    url: "/post/functional-graph-simulating/",
    title: "[メモ] Functional Graph上のシミュレーション",
    date: "2024-04-15T00:00:00+09:00",
    body: "[メモ] Functional Graph上のシミュレーション 概要 本稿において、$N$頂点$N$辺からなる有向グラフであって、すべての頂点の出次数が1であるグラフをfunctional graphと呼ぶ。 本稿の目的は、次の問題を時間計算量$O(N \\log k)$で解く方法を簡潔にまとめることである。 始点$u$が与えられる。\r頂点$p$を始点とする辺の終点を$f(p)$と表記するとき、\r$\\underbrace{f(f( \\dots f(u) \\dots ))} _ {k \\text{times}}$を求めよ。\r方法1 - ダブリング 時間計算量(前計算) : $\\Theta (N \\log k)$ 空間計算量(前計算) : $\\Theta (N \\log k)$ クエリ : $O(\\log k)$ 次の動的計画法を行う。 $$\\mathrm{dp} _ {i, j} \\coloneqq \\text{頂点$i$から$2^j$回移動したときに到達する頂点}$$ 初期値 $$\\mathrm{dp} _ {i, 0} = f(i)$$ 更新 $$\\mathrm{dp} _ {i, j + 1} = \\mathrm{dp} _ {\\mathrm{dp} _ {i, j}, j}$$ これは$j$の昇順に行うことができる。$j$は$\\log(k)$程度までで十分である。 $k \\leq 10^9$であれば30程度、$k \\leq 10^{18}$であれば60程度になる。 上記のテーブルを構築した上で、$f(f( \\dots f(u) \\dots))$は次のように求める。 非負整数$x$の二進数表示において、$n ~ \\text{bit}$目の値を返す関数を$\\mathrm{bit}(x, n)$とする。 $j = 1, 2, \\dots$に対して、順に次を行う。 $\\mathrm{bit}(k, j) = 1$ならば$u \\leftarrow \\mathrm{dp} _ {u, j}$とする。 アルゴリズムが終了した時点での$u$の値は$f(f( \\dots f(u) \\dots ))$に等しい。 利点 前計算が完了していれば、任意の始点に対して1回あたり$O(\\log k)$で計算できる。 欠点 グラフのサイズによってはTime LimitやMemory Limitがギリギリになる場合がある。 補足 $\\mathrm{dp} _ {i, j}$の値は必ずしも頂点である必要はなく、ある関数$g$を用いて$g(\\mathrm{dp} _ {i, j}) = \\text{頂点$i$から$2^j$回移動したときに到達する頂点}$とできる値ならばどのように決めても良い。 方法2 - 両端キューを用いる方法 時間計算量 : $O(N)$ 空間計算量 : $O(N)$ 次のアルゴリズムにより計算する。 到達済み頂点の集合を$\\mathrm{seen}$とする。最初$\\mathrm{seen} = \\emptyset$である。 また、現在の頂点を$\\mathrm{cur}$とする。最初$\\mathrm{cur} = u$である。 空の両端キューを$\\mathrm{deque}$とする。 $\\mathrm{cur} \\in \\mathrm{seen}$であれば手順4を行う。 $\\mathrm{seen} \\leftarrow \\mathrm{seen} \\cup \\mathrm{cur}$とし、$\\mathrm{deque}$の末尾に$\\mathrm{cur}$を追加する。その後$\\mathrm{cur} \\leftarrow f(\\mathrm{cur})$と更新する。 手順1を行う。 $\\mathrm{deque}$の先頭要素が$\\mathrm{cur}$と等しい、または$k = 0$であれば手順7を行う。 $\\mathrm{deque}$の先頭要素を取り除き、$k \\leftarrow k - 1$と更新する。 手順4を行う。 $k \\leftarrow k \\mod \\vert \\mathrm{deque} \\vert$と更新する。ただし$\\vert \\mathrm{deque} \\vert$は$\\mathrm{deque}$の要素数である。 $k = 0$であれば$\\mathrm{deque}$の先頭要素を出力し、手順を終了する。 $\\mathrm{deque}$の先頭要素を取り除き、$k \\leftarrow k - 1$と更新する。 手順8を行う。 アルゴリズムの説明\r手順1, 2, 3で閉路を含む頂点集合を列挙している。なお、$\\mathrm{deque}$内の要素は常に実際の訪問順と等しい。\r手順4, 5, 6で閉路を構成する頂点集合を抽出している。$k$が十分に小さい場合、閉路の頂点を抽出し終わる前にこの部分を抜ける。その時は$\\mathrm{deque}$の先頭要素が求める値になっている。 手順7で閉路のループを一括処理している。$k = 0$には影響しないことに注意。 手順8, 9, 10で最後の1周をシミュレーションにより求めている。これまでと同様に$k = 0$であれば最初に手順8を行う時点で終了することに注意。 利点 ダブリングと比較して、Time LimitやMemory Limitの点で有利である。 欠点 始点一つに対して$O(N)$時間かかるため、クエリ処理に向かない。 ダブリングと比較して、アルゴリズムがやや複雑である。 実装例 適用できる問題と、その解答コードを掲載する。(ネタバレ注意) これを見ながらコーディングすることを想定しているため、問題の解法に関する言及はない。 ABC167D - Telepoter (ダブリング/両端キュー) 問題へのリンク void solve (int N, long K, int[] A) { DList!int Q; bool[] vis = new bool[](N); int cur = 0; while (vis[cur] == 0) { Q.insertBack(cur); vis[cur] = true; cur = A[cur]; } // ループ入るまでpop while (0 \u0026lt; K \u0026amp;\u0026amp; Q.front != cur) { Q.removeFront; K--; } K %= Q.dup.array.length; // 残りシミュレーション while (0 \u0026lt; K) { Q.removeFront; K--; } writeln(Q.front + 1); } void solve (int N, long K, int[] A) { const int max_bit = 60; int[][] dp = new int[][](N, max_bit + 1); // 初期化 foreach (i; 0..N) { dp[i][0] = A[i]; } foreach (j; 0..max_bit) { foreach (i; 0..N) { dp[i][j + 1] = dp[dp[i][j]][j]; } } // 繰り返し二乗法の要領でK手を「ほぐす」 int ans = 0; foreach (i; 0..max_bit + 1) { if (0 \u0026lt; ((1L \u0026lt;\u0026lt; max_bit) \u0026amp; K)) { ans = dp[ans][i]; } } writeln(ans + 1); } ARC113C - A^B^C (両端キュー) 問題へのリンク void solve (int A, int B, int C) { // A^{B^C} % 10を考える。 // Aの冪はmod10で考えるとfunctional graphとみなせる bool[] vis = new bool[](10); DList!int Q; A %= 10; int cur = A; int MOD = 0; while (!vis[cur]) { MOD++; vis[cur] = true; Q.insertBack(cur); // 更新 cur *= A; cur %= 10; } long power = ModPow(B, C, MOD); foreach (_; 0..(MOD + power - 1) % MOD) { Q.removeFront; } writeln(Q.front); } ABC258E - Packing Potatoes (ダブリング) 問題へのリンク void solve (int N, int Q, int X, int[] W) { // 始点を決めれば終点が決まる。これはfunctional graphとみなせて、ダブリングでK番目に蓋をする箱の始点が見つかる。 int x = X; long sum = 0; foreach (w; W) sum += w; x %= sum; auto dp = new int[][](N, 64); auto ans = new long[](N); // 尺取りで最初の1回を見つける。 auto w = W ~ W; int l = 0, r = 0; long s = 0; while (l \u0026lt; N) { while (s \u0026lt; x) { s += w[r]; r++; } dp[l][0] = r % N; ans[l] = (r-l) + N * (X / sum); s -= W[l]; l++; } // doubling foreach (k; 1..64) { foreach (i; 0..N) dp[i][k] = dp[ dp[i][k-1] ][k-1]; } foreach (_; 0..Q) { long K = readln.chomp.to!long; K--; int cur = 0; foreach (i; 0..64) { if (0 \u0026lt; (K \u0026amp; (1L \u0026lt;\u0026lt; i))) cur = dp[cur][i]; } writeln(ans[cur]); } } ABC30d - へんてこ辞書 (両端キュー) 問題へのリンク void solve (int N, int a, BigInt k, int[] b) { // functional graphのシミュレーション 単一始点はキューでやると楽 bool[int] seen; int cur = a; DList!int Q; int size = 0; while (true) { if (cur in seen) break; seen[cur] = true; Q.insertBack(cur); size++; cur = b[cur]; } // ループだけが残る or kが0になるまでremove while (true) { if (k == 0) break; if (Q.front() == cur) break; Q.removeFront(); size--; k--; } k %= size; while (0 \u0026lt; k) { Q.removeFront(); k--; } writeln(Q.front() + 1); } ABC136D - Gathering Children (ダブリング) 問題へのリンク void solve (string S) { int[][] dp = new int[][](S.length, 18); // dp[i][j] := 頂点iから2^j回移動した先 foreach (i; 0..S.length) dp[i][0] = (S[i]==\u0026#39;R\u0026#39; ? cast(int) (i+1) : cast(int) (i-1)); foreach (j; 0..17) { foreach (i; 0..S.length) { dp[i][j+1] = dp[dp[i][j]][j]; } } // 10^{100}は過剰なので、10^5回移動したとする int move = 10^^5; int[] ans = new int[](S.length); foreach (i; 0..S.length) { int bit = 0; int cur = cast(int) i; while ((1\u0026lt;\u0026lt;bit) \u0026lt;= move) { if (0 \u0026lt; (move \u0026amp; (1\u0026lt;\u0026lt;bit))) cur = dp[cur][bit]; bit++; } ans[cur]++; } foreach (i, a; ans) { write(a, i == ans.length-1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } yukicoder No.2716 Falcon Method (ダブリング) 問題へのリンク int main () { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; string s; cin \u0026gt;\u0026gt; s; int D = 0, R = 0; for (auto c : s) { if (c == \u0026#39;D\u0026#39;) D++; if (c == \u0026#39;R\u0026#39;) R++; } if (D == 0) { for (int i = 0; i \u0026lt; Q; i++) { int H, W, P; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; P; cout \u0026lt;\u0026lt; (P + W) % N \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } if (R == 0) { for (int i = 0; i \u0026lt; Q; i++) { int H, W, P; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; P; cout \u0026lt;\u0026lt; (P + H) % N \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } // 両方向でダブリング -\u0026gt; 短い方を採用 const int MAX = 32; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp_R(N + 1, vector\u0026lt;ll\u0026gt;(MAX)), dp_D(N + 1, vector\u0026lt;ll\u0026gt;(MAX)); // dp_R[i][j] := カウンタiからスタートして、(カウンタiは踏む)右に2^jマス進むために踏むマス数 { int l = 0, r = 0; while (l \u0026lt; N) { if (r \u0026lt; l) r = l; while (true) { if (s[r % N] == \u0026#39;R\u0026#39;) break; r++; } dp_R[l][0] = r - l + 1; l++; } } { int l = 0, r = 0; while (l \u0026lt; N) { if (r \u0026lt; l) r = l; while (true) { if (s[r % N] == \u0026#39;D\u0026#39;) break; r++; } dp_D[l][0] = r - l + 1; l++; } } for (int j = 0; j \u0026lt; MAX - 1; j++) { for (int i = 0; i \u0026lt; N; i++) { dp_R[i][j + 1] = dp_R[(i + dp_R[i][j]) % N][j] + dp_R[i][j]; dp_D[i][j + 1] = dp_D[(i + dp_D[i][j]) % N][j] + dp_D[i][j]; } } for (int i = 0; i \u0026lt; Q; i++) { int H, W, P; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; P; ll h = P; ll w = P; for (int j = 0; j \u0026lt; MAX; j++) { if (0 \u0026lt; (H \u0026amp; (1LL \u0026lt;\u0026lt; j))) { h += dp_D[h % N][j]; } } for (int j = 0; j \u0026lt; MAX; j++) { if (0 \u0026lt; (W \u0026amp; (1LL \u0026lt;\u0026lt; j))) { w += dp_R[w % N][j]; } } cout \u0026lt;\u0026lt; min(h, w) % N \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 水以下コンテストB - f(f(f(f(f(x))))) (ダブリング) 問題へのリンク // 構文解析部分は省略 int main () { ll K; cin \u0026gt;\u0026gt; K; string S; cin \u0026gt;\u0026gt; S; // ダブリング vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(MOD, vector\u0026lt;int\u0026gt;(64)); // dp[i][j] := iから2^j回適用した値 for (int i = 0; i \u0026lt; MOD; i++) { dp[i][0] = analize(S, i); } for (int j = 0; j \u0026lt; 64; j++) { for (int i = 0; i \u0026lt; MOD; i++) { dp[i][j + 1] = dp[dp[i][j]][j]; } } int ans = 1; for (int j = 0; j \u0026lt; 64; j++) { if (0 \u0026lt; (K \u0026amp; (1LL \u0026lt;\u0026lt; j))) { ans = dp[ans][j]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 終わりに いっつもバグらせて混乱するのでまとめました。 追加情報及び不備の指摘は随時募集中です。"
  },
  {
    url: "/post/abc247f/",
    title: "ABC247F - Cards",
    date: "2024-04-10T00:00:00+09:00",
    body: "ABC247F - Cards 問題概要 問題へのリンク 問題文 $1$から$N$の番号がついた$N$枚のカードがあり、カード$i$の表には$P _ i$が、裏には$Q _ i$が書かれている。 ただし、$P = (P _ 1, \\dots, P _ N)$及び$Q = (Q _ 1, \\dots, Q _ N)$はそれぞれ$(1, \\dots, N)$の置換である。 $N$枚のカードの部分集合であり、次の条件を満たすものがいくつあるかを$998244353$で割ったあまりを求めよ。 $1$から$N$のどの数も、表または裏にその数が書かれたカードが、部分集合に少なくとも1枚含まれる。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $1 \\leq P _ i, Q _ i \\leq N$ 解法 カードを3種類に分類する。 表と裏に書かれている数が同じ。 書かれた数の集合が一致するカードが他に存在する。 その他。 まず、1のカードは条件を満たすために取るしかない。 2のカードは、少なくとも片方を取る必要があるため、このペア1組につき解が3倍になる。 もう少し詳細に説明しよう、カードに書かれた数の集合が$\\lbrace x, y \\rbrace$であるものが2枚存在するとする。 このとき、部分集合に$x$または$y$が含まれるようにするためには、この2枚のうち少なくとも1枚は取らなければいけない。 よって、これらカードについて(とる/とらない)、(とらない/とる)、(とる/とる)の3通りの選択肢が存在し、これは他のカードの選択に影響を及ぼさないため、独立である。 すなわち、ペアが1組増えるごとに部分集合の数は3倍になる。 3のカードについて考える。これらどう取ればよいかが一番難しい部分であり、この問題の本質である。 まずはカードを頂点とみなして、同じ数を含むカードに無向辺をはることにする。 このとき、カードに書かれている任意の数は、全体で必ず2個存在する。これはカード1とカード2の定義を考えれば明らかである。 すなわち、任意の頂点に必ず2辺が接続することになる。 このようにしてできたグラフは、各連結成分は必ず全体がただ一つの閉路に含まれる。すわなち、円環になる。 これは次の命題が真であることから言える。 「連結で単純な$N$頂点$N$辺の無向グラフで、すべての頂点の出次数が2であるとき、このグラフはちょうど一つの閉路を持ち、すべての頂点は閉路に含まれる。」 証明\r(i) ちょうど一つの閉路を持つこと\rまず、次の命題を帰納法により示す。 「連結グラフは、全域木を部分グラフに含む」 証明\rグラフ$G$の辺集合$E$とする。\r$\\vert E \\vert = 0$のときは、グラフが連結であるという仮定から、$G$は孤立頂点である。このとき命題は成立。\r$\\vert E \\vert = k$のときに成立すると仮定する。 $\\vert E \\vert = k + 1$のとき、 $G$が閉路を含まないならば、$G$は木の定義を満たすので、$G$そのものが全域木である。 $G$が閉路を含むならば、閉路の任意の辺を切断すると、$\\vert E \\vert = k$に帰着する。 したがって、グラフが連結であれば全域木が存在する。 折りたたみ内折りたたみ終わり。 この命題により、今考えているグラフは全域木を含むことが分かる。任意の全域木を選び、木に含まれない辺を$e = (u, v)$とする。 このとき木の性質として、$u, v$パスは一意に定まる。 すなわち、元の(この全域木に$e$を追加したグラフ)は、$u, v$パス → $e$というただ一つの閉路を持つ。 (ii) すべての頂点が閉路に含まれること 任意の頂点を選び、$v _ 0$とする。$v _ 0$に隣接する頂点を一つ選び、$v _ 1$とする。 $v _ 1$の$v _ 0$でない方の隣接頂点を$v _ 2$とする。 これを繰り返していく。 すると、グラフは閉路を持つため、いつか$v _ k$は訪問済みの頂点になる。 このとき、$v _ 0$以外の頂点($v _ x$とする)にたどり着いたとすると、$v _ x$は出次数2の仮定を満たさない。 さらに、$v _ 0$にたどりついたときに全頂点を訪問済みになっていない場合、連結であるという仮定を満たさない。 よって、頂点$v _ 0$からはじまり、すべての頂点をちょうど1回訪問し、頂点$v _ 0$に戻ってくるというパターン以外はありえない。 これはすべての頂点が閉路に含まれるということである。 折りたたみ終わり。 つまり、グラフは次の図のようになる。 ある一つの連結成分に対して考えると、条件を満たすようなカードの選び方は、「取らないカードの隣接頂点は必ず取る」であることが分かる。 必要性は、取らないカードが2連続するとき、そのカードをつなぐ数を取れなくなることによる。 十分性も同様に、任意の数は隣り合うカードのどちらかを取れば含めることができることにより説明できる。 上の図上部の連結成分に対しては、$\\lbrace \\lbrace 1, 3 \\rbrace, \\lbrace 1, 5 \\rbrace \\rbrace$は条件を満たすが、 $\\lbrace \\lbrace 1, 3 \\rbrace, \\lbrace 3, 4 \\rbrace \\rbrace$は条件を満たさない。 あとはこの数え上げを解ければよい。 これを解くために、次の問題を考えよう。 列$A = (A _ 0, A _ 2, \\dots, A _ {k - 1}), A _ i \\in \\lbrace 0, 1 \\rbrace$であって、次の条件を満たすものはいくつか？ $0 \\leq A _ i + A _ {i + 1 \\mod k}$ この有効な列$A$はそのまま有効なカードのとり方と対応している。 具体的には、閉路の任意の頂点を固定し、そこから時計回りに頂点を並べた列$(v _ 0, v _ 1, \\dots, v _ k)$を考える。 このとき、$v _ i$を取るかどうかを$A _ i$の値によって決めることで対応付けることができる。 隣との和が$0$でなければ良いのだから、$0$を使用したいときは$0$と$1$を束ねて使用することにすると見通しが良くなる。 すなわち、$x$個の$10$と、$k - 2x$個の$1$を並べる問題だと考えれば良い。 ただし、この方法だと先頭が$0$であるような列が生成できない。 これは、先頭を$0$、末尾を$1$に固定した状態で、$x - 1$個の$10$と$k - 2x$個の$1$を並べる場合の数を足すことで回避できる。 この方法により、任意の有効な列をちょうど1回数えることができる。 これは、次の理由による。 ある有効な列をこの方法により前から構成するとき、続く文字列が$11, 1$のときは$1$を配置するしかなく、$10$のときは$10$を配置するしか無いため、構成方法が一意に定まる。 $10$と$1$をどのように並べても、$00$を作ることはできない。 これらは二項係数の計算ができれば解ける。 適切に前計算することで各ケース$O(1)$時間で解けるから、全体で$O(k)$時間である。 これで、有効な列$A$の数え上げが解けた。 もとの問題に戻ろう。 一つの連結成分の頂点のとり方は他の連結成分のとり方に影響しないため、場合の数はそれらすべての積になる。 また、各連結成分の次数の和は$O(N)$個であるため、全体$O(N)$時間で解ける。 実装例 import std; void main () { int N = readln.chomp.to!int; auto P = readln.split.to!(int[]); P[] -= 1; auto Q = readln.split.to!(int[]); Q[] -= 1; solve(N, P, Q); } void solve (int N, int[] P, int[] Q) { // カードを3種類に分類する。 // 1. 表と裏で同じ数が書いている // 2. 同じ数字の割り当てのカードが存在する // 3. 1, 2に当てはまらない // 1は必ずとる必要があるので、これを除く。 // 2は少なくとも片方をとればよく、この枚数をxとして、任意の取り方が3^(x/2)倍になる。 // 3をどう取るか？が本質 const long MOD = 998244353; int[Tuple!(int, int)] count; foreach (i; 0..N) { count[tuple(min(P[i], Q[i]), max(P[i], Q[i]))]++; } int type1 = 0; foreach (i; 0..N) { if (tuple(i, i) in count) { type1++; } } int type2 = 0; foreach (key, val; count) { if (val == 2) { type2++; } } int[] type3; auto idx = new int[][](N, 0); foreach (i; 0..N) { idx[P[i]] ~= i; idx[Q[i]] ~= i; } auto UF = UnionFind(N); foreach (I; idx) { if (0 \u0026lt; I.length) { UF.unite(I[0], I[1]); } } foreach (i; 0..N) { if (UF.root(i) == i \u0026amp;\u0026amp; 3 \u0026lt;= UF.GroupSize(i)) type3 ~= UF.GroupSize(i); } // 3のカードを(a, b)のように考えて、同じ数字を隣り合わせに配置してみると、円環になる。 // この時、空白が高々サイズ1であることが有効なとり方の必要十分条件。 // とるのととらないのをペア(ox)にしてやれば、何個とらないかで場合分けして組み合わせに帰着できる。 // 具体的な帰着について考える。 // oとoxの並べ替えと考えると、多項係数になる。 // 頭がxになるようなものだけ無理なので、そのようなケースのみxoを使う数え上げもする。 // WA -\u0026gt; 多分議論は合っていて、円環が複数できうるケースに対応できていないものと考えられる。 alias m = PrimeModuloFactorial!MOD; m.build(N); long ans = 1; foreach (t3; type3) { long prod = 0; foreach (t; 0..N) { if (t3 \u0026lt; 2 * t) break; int r = t3 - 2 * t; if (t == 0) { prod++; continue; } { // ox数え上げ long add = m.factorial(t + r); add *= m.factorial_inv(t); add %= MOD; add *= m.factorial_inv(r); add %= MOD; prod += add; prod %= MOD; } { // xo数え上げ long add = m.factorial(t + r - 1); add *= m.factorial_inv(t - 1); add %= MOD; add *= m.factorial_inv(r); add %= MOD; prod += add; prod %= MOD; } } ans *= prod; ans %= MOD; } ans *= mod_pow(3, type2, MOD); ans %= MOD; writeln(ans); } // check mod_inv static assert(__traits(compiles, mod_inv(998244353, 1_000_000_007))); template PrimeModuloFactorial (ulong M) if ((1 \u0026lt;= M \u0026amp;\u0026amp; M \u0026lt; int.max) \u0026amp;\u0026amp; ((x) { for (int i = 2; i \u0026lt; x; i++) { if (x \u0026lt; 1L*i*i) break; if (x % i == 0) return false; } return true; })(cast(int) M)) { import std.conv : to; import std.format : format; private: long[] fact, fact_inv; int N = 0; long MOD = M; public: void build (ulong N_) { N = N_.to!int; fact.length = fact_inv.length = N+1; fact[0] = 1; for (int i = 1; i \u0026lt;= N; i++) fact[i] = i * fact[i-1] % MOD; fact_inv[N] = mod_inv(fact[N], MOD); for (int i = N; 0 \u0026lt; i; i--) fact_inv[i-1] = i * fact_inv[i] % MOD; } long binom (ulong n_, ulong k_) in { assert((n_ \u0026lt; k_ || (n_ \u0026lt;= N \u0026amp;\u0026amp; k_ \u0026lt;= N)), format(\u0026#34;Out of range of pre-calculation. MAX = %s, n = %s, k = %s.\u0026#34;, N, n_, k_), ); } do { int n = n_.to!int; int k = k_.to!int; if (n \u0026lt; k) return 0; long res = fact[n] * fact_inv[k] % MOD; return res * fact_inv[n-k] % MOD; } long factorial (ulong x_) in { assert(x_ \u0026lt;= N, format(\u0026#34;Out of range of pre-calculation. MAX = %s, x = %s.\u0026#34;, N, x_), ); } do { int x = x_.to!int; return fact[x]; } long factorial_inv (ulong x_) in { assert(x_ \u0026lt;= N, format(\u0026#34;Out of range of pre-calculation. MAX = %s, x = %s.\u0026#34;, N, x_) ); } do { int x = x_.to!int; return fact_inv[x]; } } // check mod_pow static assert(__traits(compiles, mod_pow(2, 10, 998244353))); long mod_inv (const long x, const long MOD) in { import std.format : format; assert(1 \u0026lt;= MOD, format(\u0026#34;MOD must satisfy 1 \u0026lt;= MOD. Now MOD = %s.\u0026#34;, MOD)); assert(MOD \u0026lt;= int.max, format(\u0026#34;MOD must satisfy MOD*MOD \u0026lt;= long.max. Now MOD = %s.\u0026#34;, MOD)); } do { return mod_pow(x, MOD-2, MOD); } long mod_pow (long a, long x, const long MOD) in { assert(0 \u0026lt;= x, \u0026#34;x must satisfy 0 \u0026lt;= x\u0026#34;); assert(1 \u0026lt;= MOD, \u0026#34;MOD must satisfy 1 \u0026lt;= MOD\u0026#34;); assert(MOD \u0026lt;= int.max, \u0026#34;MOD must satisfy MOD*MOD \u0026lt;= long.max\u0026#34;); } do { // normalize a %= MOD; a += MOD; a %= MOD; long res = 1L; long base = a; while (0 \u0026lt; x) { if (0 \u0026lt; (x\u0026amp;1)) (res *= base) %= MOD; (base *= base) %= MOD; x \u0026gt;\u0026gt;= 1; } return res % MOD; } class UnionFind_Array { /* * VERYFYIED * - uniteとsame : yosupo judge (https://judge.yosupo.jp/problem/unionfind) * * UNVERYFYIED * - countGroups * - GroupSize * - enumGroups */ private: int N; int[] parent; int[] size; this (int N) in { assert(0 \u0026lt;= N, \u0026#34;N must be positive integer.\u0026#34;); } do { this.N = N; parent = new int[](N); size = new int[](N); foreach (i; 0..N) { parent[i] = i; size[i] = 1; } } int root (int x) in { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; N); } do { if (parent[x] == x) return x; return parent[x] = root(parent[x]); } bool same (int x, int y) in { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; N); assert(0 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt; N); } do { return root(x) == root(y); } void unite (int x, int y) in { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; N); assert(0 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt; N); } do { int larger, smaller; if (GroupSize(x) \u0026lt;= GroupSize(y)) { larger = root(y); smaller = root(x); } else { larger = root(x); smaller = root(y); } if (larger == smaller) return; parent[smaller] = larger; size[larger] += size[smaller]; } int countGroups () { int res = 0; foreach (i; 0..N) if (root(i) == i) res++; return res; } int GroupSize (int x) in { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; N); } do { return size[root(x)]; } int[][] enumGroups (int x) in { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; N); } do { int[][] mp = new int[][](N, 0); foreach (i; 0..N) { mp[root(i)] ~= i; } int[][] res; foreach (m; mp) { if (m.length == 0) continue; res ~= m; } return res; } void reset (int N = this.N) in { assert(0 \u0026lt;= N, \u0026#34;N must be positive integer.\u0026#34;); } do { if (N != this.N) { this.N = N; parent.length = size.length = N; } foreach (i; 0..N) { parent[i] = i; size[i] = 1; } } } auto UnionFind (int N) { return new UnionFind_Array(N); } UnionFindで各閉路の連結成分のサイズを取得する実装になっている。 UnionFindを用いた影響により、微妙に線形時間ではなくなっていることに注意してほしい。 solveより下のコードはすべてライブラリである。 終わりに 難しかったです。かなり時間がかかりました。 カードを分類することは本質的ではないものの、分類することによって、タイプ3のカードの集合が成すサイクルに着目する発想をすることができました。 サイクルから条件を満たすように取る方法の数え上げについては、公式解説により自然な言い換えとその解法が載っています。そちらはまだ理解していませんが、次解くときにはその方針が見えるようになっていれば良いなと思います。 グラフに関する用語の定義は 37zigen を参考にしました。 全域木に関する議論の主張及び証明は、 電気通信大学のpdf を参考にしました。 「連結で単純なN頂点N辺の無向グラフで、すべての頂点の出次数が2であるとき、このグラフはちょうど一つの閉路を持ち、すべての頂点は閉路に含まれる。」という命題に関する議論は、@marble_kyoproさん、@Seed57_cashさん、@coindarwさんに助言頂きました。 ありがとうございました。"
  },
  {
    url: "/post/abc247e/",
    title: "ABC247E - Max Min",
    date: "2024-04-08T00:00:00+09:00",
    body: "ABC247E - Max Min 問題概要 問題へのリンク 問題文 長さ$N$の数列$A = (A _ 1, A _ 2, \\dots, A _ N)$及び整数$X, Y$が与えられる。次の条件をすべて満たす整数の組$(L, R)$の個数を求めよ。 $1 \\leq L \\leq R \\leq N$ $A _ L, A _ {L + 1}, \\dots, A _ R$の最大値が$X$で、最小値が$Y$である。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $1 \\leq A _ i \\leq 2 \\times 10^5$ $1 \\leq Y \\leq X \\leq 2 \\times 10^5$ 解法 条件を満たす連続部分列$A _ L, A _ {L + 1}, \\dots, A _ R$の各要素は、明らかに$Y$以上$X$以下である。 したがって、この範囲外にであるような要素$A _ i$に対して、$A _ i$をまたぐような区間は条件を満たすことはない。 これにより、$A _ i \u0026lt; Y$または$X \u0026lt; A _ i$を満たす要素で数列$A$を分割して考えて良いことがわかる。 分割してできた列のうち一つを$B = (B _ 1, B _ 2, \\dots, B _ M)$として、$B$に対して問題を解くことを考える。 数え上げの問題に対する一般的なアプローチとして、何かしらの値を固定して考えるというものがある。 今回は区間の右端を固定したときに、左端をどのように取れるかを考えることにする。 まず、$L \\leq R$であることから、右端$R$に次の必要条件が課されることがわかる。 $B _ 1, B _ 2, \\dots, B _ R$の最小値が$Y$で、最大値が$X$である。 すべての要素が$Y \\leq B _ i \\leq X$であるという仮定から、これは次の条件に言い換えることができる。 $R$は数列$B$の中で最初に現れる$X$と$Y$より後ろにいなければいけない。 数式で表現するなら、$X _ {\\mathrm{idx}} \\coloneqq \\lbrace i \\mid B _ i = X \\rbrace, Y _ {\\mathrm{idx}} \\coloneqq \\lbrace i \\mid B _ i = Y \\rbrace$に対して、$\\max (\\min X _ {\\mathrm{idx}}, \\min Y _ {\\mathrm{idx}}) \\leq R$ (ただし、$\\min \\emptyset = \\infty$とする。) という感じになる。 この条件が満たされるとき、少なくとも$(1, R)$は条件を満たすため、少なくとも1通りの有効な組が存在することがわかる。 では、この条件下で左端$L$はどこまで大きく取れるだろうか？この答えは、次の通りである。 $R$より前の一番近い$X$と$Y$より左ならよい。 より形式的には、$x \\coloneqq \\max \\lbrace i \\mid i \\in X _ \\mathrm{idx} \\land i \\leq R \\rbrace, y \\coloneqq \\max \\lbrace i \\mid i \\in Y _ \\mathrm{idx} \\land i \\leq R \\rbrace$として、$L \\leq \\min(x, y)$であるような$L$ならすべて条件を満たす。 さて、これで問題を解くことができた。残る問題は、これらの操作を高速に行うことができるかになる。 まず、数列$A$を分割するのは尺取り法などにより全体$\\Theta(N)$時間で行うことができる。 分割された数列$B$に対して考える。 事前に$\\Theta(\\vert B \\vert)$時間をかけて$X, Y$それぞれと等しい要素のインデックスを昇順に保持しておくと、 現在の$R$右端として用いることができるかを$O(1)$時間、$R$を順に(昇順/降順どちらでもできる)見ていくことで、その時点での$x, y$を$O(1)$時間で更新できる。 $R$の候補は$\\vert B \\vert$個であるから、全体$\\Theta(\\vert B \\vert)$時間で解ける。 以上より、問題を$\\Theta(N)$時間で解くことができる。 実装例 import std; void main () { int N, X, Y; readln.read(N, X, Y); auto A = readln.split.to!(int[]); solve(N, X, Y, A); } void solve (int N, int X, int Y, int[] A) { // Y \u0026lt;= a \u0026lt;= Xが成立する区間に分割 -\u0026gt; 区間に置いてa == Yとa == Xが成立するインデックスを全部持っておき、区間の右側を全探索 -\u0026gt; 線形時間 long ans = 0; int[] X_idx, Y_idx; // 尺取りで頑張る int l = 0, r = 0; void f () { X_idx.length = Y_idx.length = 0; foreach (i; l..r) { if (A[i] == X) X_idx ~= i; if (A[i] == Y) Y_idx ~= i; } if (X_idx.length == 0 || Y_idx.length == 0) return; // 右側を探索 int x = 0, y = 0; foreach (i; l..r) { if (x + 1 \u0026lt; X_idx.length \u0026amp;\u0026amp; X_idx[x + 1] == i) x++; if (y + 1 \u0026lt; Y_idx.length \u0026amp;\u0026amp; Y_idx[y + 1] == i) y++; if (i \u0026lt; X_idx[0] || i \u0026lt; Y_idx[0]) continue; ans += min(X_idx[x], Y_idx[y]) - l + 1; } } while (l \u0026lt; N) { if (r \u0026lt; l) r = l; if (A[l] \u0026lt; Y || X \u0026lt; A[l]) { l++; continue; } while (r \u0026lt; N) { if (Y \u0026lt;= A[r] \u0026amp;\u0026amp; A[r] \u0026lt;= X) { r++; continue; } break; } // 区間に対して操作 f(); l = r; } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 尺取り法で区間を分割している。 それぞれの連続部分列に対して問題を解くことは関数f()を呼ぶことと対応している。 $x, y$の計算等が面倒な場合、平衡二分木を用いると$O(N \\log N)$時間になる代わりに実装が楽になる。 終わりに 久しぶりに見返したら、思いの外苦戦したので解法をまとめておくことにした。 尺取り法を使うのが少しずつうまくなっているのを感じる。"
  },
  {
    url: "/post/mmacontest018/",
    title: "MMA Contest 018参加記録 + 怪文書",
    date: "2024-04-03T00:00:00+09:00",
    body: "MMA Contest 018参加記録 + 怪文書 オンサイトに行ってきました。 MMA Contest 018 - connpass 電気通信大学のサークル、MMAによるプログラミングコンテストが3月31日に開催されました。 電気通信大学内にオンサイト会場が確保されていたため、私も現地に行って参加してきました。 本エントリはその記録になります。 戦績 8問中7問正解し、4月1日時点で全体57位でした。 振り返り A - One Nafmo 問題へのリンク $A$本セットでしか買えない鉛筆をいくつか買うことで、合計$X$本以上手に入れる問題です。 早い話、$X / A$の切り上げが処理できれば良いです。 これは条件分岐などでもよいですが、次のイディオムがよく利用されています。 $$\\left\\lceil \\frac{X}{A} \\right\\rceil = \\left\\lfloor \\frac{X + A - 1}{A} \\right\\rfloor$$ import std; void main () { int A, B, X; readln.read(A, B, X); writeln(B * ((X + A - 1) / A)); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Bag of Words Encryption 問題へのリンク 文字列$S$に対して、(文字Aが登場する回数)(文字Bが登場する回数) ... (文字Zが登場する回数)という文字列を出力する問題です。 一旦配列等に各文字の出現回数を記録するときれいに解けます。 文字列として構築しなくても、整数の出力を26回行うこともできます。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; int[char] C; foreach (c; S) C[c]++; string X = \u0026#34;\u0026#34;; foreach (i; 0..26) { X ~= C.get((i + \u0026#39;A\u0026#39;).to!char, 0).to!string; } writeln(X); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Jewel holder 問題へのリンク 少し複雑なグリッドの上であり得る経路数の数え上げをする問題です。 私が「グラフの多重化」と呼んでいるテクニックを用いることで、よくあるdpに帰着できます。 「グラフの多重化」とは、現在のグリッドの座標に加えて何かしらの情報を持たせることです。 今回に関しては、$\\mathrm{dp}[i][j][k] \\coloneqq \\text{$(i, j)$にいて、宝石$k$個を持っている状態にたどり着く場合の数}$ とすることで、うまくdpができます。 import std; void main () { int H, W; readln.read(H, W); auto A = new string[](H); foreach (i; 0..H) A[i] = readln.chomp; auto dp = new int[][][](H, W, H * W + 1); // dp[i][j][k] := (i, j)に宝石k個で至る場合の数 dp[0][0][1] = 1; foreach (i; 0..H) { foreach (j; 0..W) { foreach (k; 0..H * W + 1) { // 右 if (i + 1 \u0026lt; H) { char c = A[i + 1][j]; if (c == \u0026#39;o\u0026#39;) { if (k \u0026lt; H * W) dp[i + 1][j][k + 1] += dp[i][j][k]; } if (c == \u0026#39;x\u0026#39;) { if (0 \u0026lt; k) dp[i + 1][j][k - 1] += dp[i][j][k]; } } // 下 if (j + 1 \u0026lt; W) { char c = A[i][j + 1]; if (c == \u0026#39;o\u0026#39;) { if (k \u0026lt; H * W) dp[i][j + 1][k + 1] += dp[i][j][k]; } if (c == \u0026#39;x\u0026#39;) { if (0 \u0026lt; k) dp[i][j + 1][k - 1] += dp[i][j][k]; } } } } } long ans = 0; foreach (k; 0..H * W + 1) { ans += dp[H - 1][W - 1][k]; } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } また、制約が十分小さいため、グラフの巡回路すべてを列挙することが可能なようです。各巡回路に対してはシミュレーションをすると正しく数え上げることができます。 D - 1975 Powers 問題へのリンク 条件を満たす部分列を数え上げる問題です。 部分列$(a, b, c, d)$に対して、$10^a + 9^b + 7^c + 5^d$を対応させることにします。 $A$をソートすることで、$a \u0026lt; b \u0026lt; c \u0026lt; d$が保証することができます。 この工夫により、取る/取らないdp(オレオレ語彙です)に帰着されます。 具体的には$\\mathrm{dp}[i][j][k] \\coloneqq \\text{先頭$i$項から$j$項とって、現在の和のあまりが$k$}$とすることで解けます。 しかし、このままだといろいろ厳しいので、前計算でlogを落としたり、nextdpというテクニックを用いてメモリ使用量を減らしました。 import std; void main () { int N, P, Q; readln.read(N, P, Q); auto A = readln.split.to!(int[]); solve(N, P, Q, A); } void solve (int N, int P, int Q, int[] A) { // なんかMLEしたのでnextdpやる A.sort; auto dp = new long[][](5, P); auto ndp = new long[][](5, P); // dp[i][j][k] := 先頭i個からj個とってあまりがk dp[0][0] = 1; const x = [10, 9, 7, 5]; auto memo = new long[][](4, N); foreach (i; 0..4) foreach (j; 0..N) memo[i][j] = mod_pow(x[i], A[j], P); foreach (i; 0..N) { foreach (d; ndp) d[] = 0; foreach (j; 0..5) { foreach (k; 0..P) { // 取る if (j + 1 \u0026lt;= 4) { ndp[j + 1][(k + memo[j][i]) % P] += dp[j][k]; } // 取らない ndp[j][k] += dp[j][k]; } } swap(dp, ndp); } writeln(dp[4][Q]); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } long mod_pow (long a, long x, const long MOD) in { assert(0 \u0026lt;= x, \u0026#34;x must satisfy 0 \u0026lt;= x\u0026#34;); assert(1 \u0026lt;= MOD, \u0026#34;MOD must satisfy 1 \u0026lt;= MOD\u0026#34;); assert(MOD \u0026lt;= int.max, \u0026#34;MOD must satisfy MOD*MOD \u0026lt;= long.max\u0026#34;); } do { // normalize a %= MOD; a += MOD; a %= MOD; long res = 1L; long base = a; while (0 \u0026lt; x) { if (0 \u0026lt; (x\u0026amp;1)) (res *= base) %= MOD; (base *= base) %= MOD; x \u0026gt;\u0026gt;= 1; } return res % MOD; } 想定解はdpではなく、ギリギリの計算量につく定数倍を見極められるかというものでした。 部分列をとるときに、できる列が重複しないようインデックスを動かすことで$1/24$の定数倍をつけることができます。 このため$O(N^4)$が間に合うようになるというからくりです。 E - How many more? 問題へのリンク 一列に並んだ人の座標が与えられるので、ある2人の間にいる人の数を求める問題です。 $A$の要素は大きいものの、要素数は$N$です。また、$A$はお互いの大小関係さえわかればよいため、座標圧縮することでうまく処理できます。 二分探索等を用いる解法もありますが、座標圧縮はタイブレークの処理が非常に楽になります。 後は数列$A$の圧縮列に対してstatic range sum queryが解ければよいので、累積和やセグメントツリーを用いましょう。 import std; void main () { int N, Q; readln.read(N, Q); auto A = readln.split.to!(int[]); solve(N, Q, A); } void solve (int N, int Q, int[] A) { // 座圧 + RSQ int[int] f; // ゴールからの距離 -\u0026gt; 全体の順番 int[] f_inv; { auto B = A.dup.sort.uniq.array; foreach (i; 0..B.length) f[B[i]] = i.to!int; f_inv.length = f.length; foreach (key, val; f) f_inv[val] = key; } auto RSQ = new SegmentTree!(int, (int a, int b) =\u0026gt; a + b, () =\u0026gt; 0)(N); foreach (a; A) RSQ.set(f[a], RSQ.get(f[a]) + 1); foreach (i; 0..Q) { int x, y; readln.read(x, y); x--, y--; // A[y] \u0026lt; hoge \u0026lt; A[x] if (f[A[x]] \u0026lt;= f[A[y]]) { writeln(0); continue; } writeln(RSQ.prod(f[A[y]] + 1, f[A[x]])); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } import std.traits : ReturnType, isCallable, Parameters; import std.meta : AliasSeq; class SegmentTree (T, alias ope, alias e) if ( isCallable!(ope) \u0026amp;\u0026amp; isCallable!(e) \u0026amp;\u0026amp; is (ReturnType!(ope) == T) \u0026amp;\u0026amp; is (ReturnType!(e) == T) \u0026amp;\u0026amp; is (Parameters!(ope) == AliasSeq!(T, T)) \u0026amp;\u0026amp; is (Parameters!(e) == AliasSeq!()) ) { /* 内部の配列が1-indexedで2冪のセグメントツリー */ import std.format : format; T[] X; size_t length; /* --- Constructors --- */ this (size_t length_) { adjust_array_length(length_); for (size_t i = length; i \u0026lt; 2*length; i++) { X[i] = e(); } build(); } import std.range.primitives : isInputRange; this (R) (R Range) if (isInputRange!(R) \u0026amp;\u0026amp; is (ElementType!(R) == T)) { adjust_array_length(walkLength(Range)); size_t i = length; foreach (item; Range) { X[i] = item; i++; } while (i \u0026lt; 2*length) { X[i] = e(); i++; } build(); } /* --- Functions --- */ private void adjust_array_length (size_t length_) { length = 1; while (length \u0026lt;= length_) length *= 2; X = new T[](2*length); } void set_with_no_update (size_t idx, T val) in { assert(idx \u0026lt; length, format(\u0026#34;In function \\\u0026#34;set_with_no_update\\\u0026#34;, idx is out of range. (length = %s idx = %s)\u0026#34;, length, idx)); } do { X[length+idx] = val; } void build () { for (size_t i = length-1; 1 \u0026lt;= i; i--) { X[i] = ope(X[2*i], X[2*i+1]); } } public override string toString () { string res = \u0026#34;\u0026#34;; int level = 1; while ((2^^(level-1)) \u0026lt; X.length) { res ~= format(\u0026#34;level: %2s | \u0026#34;, level); for (size_t i = (2^^(level-1)); i \u0026lt; (2^^level); i++) { res ~= format(\u0026#34;%s%s\u0026#34;, X[i], (i == (2^^level)-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } level++; } return res; } void set (size_t idx, T val) in { assert(idx \u0026lt; length, format(\u0026#34;In function \\\u0026#34;set\\\u0026#34;, idx is out of range. (length = %s idx = %s)\u0026#34;, length, idx)); } do { idx += length; X[idx] = val; while (2 \u0026lt;= idx) { idx /= 2; X[idx] = ope(X[2*idx], X[2*idx+1]); } } T get (size_t idx) in { assert(idx \u0026lt; length, format(\u0026#34;In function \\\u0026#34;get\\\u0026#34;, idx is out of range. (length = %s idx = %s)\u0026#34;, length, idx)); } do { idx += length; return X[idx]; } T prod (size_t l, size_t r) in { assert(l \u0026lt; length, format(\u0026#34;In function \\\u0026#34;prod\\\u0026#34;, l is out of range. (length = %s l = %s)\u0026#34;, length, l)); assert(r \u0026lt;= length, format(\u0026#34;In function \\\u0026#34;prod\\\u0026#34;, r is out of range. (length = %s r = %s)\u0026#34;, length, r)); assert(l \u0026lt;= r, format(\u0026#34;In function \\\u0026#34;prod\\\u0026#34;, l \u0026lt; r must be satisfied. (length = %s l = %s, r = %s)\u0026#34;, length, l, r)); } do { /* Returns all prod O(1) */ if (l == 0 \u0026amp;\u0026amp; r == length) return X[1]; if (l == r) return e(); /* Closed interval [l, r] */ r--; l += length, r += length; T LeftProd, RightProd; LeftProd = RightProd = e(); while (l \u0026lt;= r) { if (l % 2 == 1) { LeftProd = ope(LeftProd, X[l]); l++; } if (r % 2 == 0) { RightProd = ope(X[r], RightProd); r--; } l /= 2; r /= 2; } return ope(LeftProd, RightProd); } } F - Connection Lights 問題へのリンク $N \\times M$の長方形グリッドがあり、各グリッドに$0$または$1$を割り当てることができます。 条件を満たす割り当て方を数え上げる問題です。 問題文が結構複雑で難しいですが、条件は次のような感じです。 すべての列に対して11、つまり「今見ている列とその隣の列が1」となるような行が$K$個以上存在する というものです。 00\r01\r10\r11\r11\rという割り当ては$K \\leq 2$であれば条件を満たします。なぜなら、1列目4行目と1列目5行目に11があるからです。 $M$列の割り当てに対しては、$M - 1$列目まで同様の判定をします。 さて、「各列が条件を満たすかどうか」は隣の列に対して影響を及ぼすため、独立ではありません。 数学でどうにかするのがしんどそうな感じです。 この時点で割とdp濃厚になります。 そこで、前の列から順番に割り当てを決めていくことにしましょう。 最新列が条件を満たすためには、一つ前の割り当てさえわかれば十分です。さらに、それより前の列に対しては、条件を満たしさえすればどのような割り当てでもOKです。 以上より、全体の問題を小問題に分解できます。 $\\mathrm{dp}[i][j] \\coloneqq \\text{先頭$i$列の割り当てをして、$i$列目の割り当て状況が$j$である場合の数}$とすることで、うまく数え上げができます。 import std; void main () { int N, M, K; readln.read(N, M, K); solve(N, M, K); } void solve (int N, int M, int K) { const long MOD = 998244353; auto dp = new long[][](M + 1, 1 \u0026lt;\u0026lt; N); // dp[i][j] := 先頭i列が条件を満たし、最新列のランプがjである場合の数 foreach (j; 0..(1 \u0026lt;\u0026lt; N)) { dp[1][j] = 1; } foreach (i; 1..M) { foreach (j; 0..(1 \u0026lt;\u0026lt; N)) { foreach (k; 0..(1 \u0026lt;\u0026lt; N)) { int count = 0; foreach (l; 0..N) if (0 \u0026lt; (j \u0026amp; (1 \u0026lt;\u0026lt; l)) \u0026amp;\u0026amp; 0 \u0026lt; (k \u0026amp; (1 \u0026lt;\u0026lt; l))) count++; if (K \u0026lt;= count) { dp[i + 1][k] += dp[i][j]; dp[i + 1][k] %= MOD; } } } } long ans = 0; foreach (i; 0..(1 \u0026lt;\u0026lt; N)) { ans += dp[M][i]; ans %= MOD; } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } この実装では$j$を2進数と解釈したときの「立っているbit」と1になっているグリッドを対応付けています。 このような手法をbit dpと呼ぶことがあります。 G - Play more! 問題へのリンク $u _ 0 = 1, u _ k = N$であって、辺$(u _ i, u _ {i + 1})$に辺が存在する頂点列$(u _ 0, u _ 1, \\dots , u _ k)$を考えます。 ある頂点の攻略に必要な時間を$a(u)$、ある辺を通行するのに必要な時間を$c(u, v)$と表記するとき、 この頂点列の満足度は$\\sum a(u _ i) - \\sum c(u _ i, u _ {i + 1})$と表現できます。 この値を最大化しましょう。これは、辺$(u _ i, u _ {i + 1})$に重み$a(u _ i) - c(u _ i, u _ {i + 1})$の辺をはったときの最長経路問題にすればよいです。 しかし最長経路問題を扱うのは面倒なので、どうにか既知の簡単な問題に直したいです。 そこで、辺の重みを反転して、$c(u _ i, u _ {i + 1}) - a(u _ i)$の辺を考えます。こうすることで、頂点$1$を始点とした最短経路問題に帰着します。 これによりはられた辺のコストは負になりうるので、ベルマンフォード法で処理します。 さて、infの処理をしましょう。ベルマンフォード法は(自分は理解していませんが)負閉路の検出ができるらしいです。 頂点$1$または$N$の強連結成分に負閉路が含まれているとき、なんかいい感じに伝搬させることができます。 この辺りは別途勉強して、(余裕があれば)エントリにします。 import std; void main () { int N, M; readln.read(N, M); auto A = readln.split.to!(int[]); // 辺の重みをc - Aにすると最短経路問題に帰着 solve(N, M, A); } void solve (int N, int M, int[] A) { auto graph = new Tuple!(int, int)[][](N, 0); foreach (i; 0..M) { int a, b, c; readln.read(a, b, c); a--, b--; graph[a] ~= tuple(b, c - A[a]); } auto dist = new long[](N); dist[] = long.max; dist[0] = 0; // bellman-ford foreach (_; 0..N - 1) { foreach (i; 0..N) { if (dist[i] == long.max) continue; foreach (to; graph[i]) { int v = to[0]; long c = to[1]; if (dist[v] \u0026lt;= dist[i] + c) continue; dist[v] = dist[i] + c; } } } foreach (_; 0..N - 1) { foreach (i; 0..N) { if (dist[i] == long.max) continue; foreach (to; graph[i]) { int v = to[0]; long c = to[1]; if (dist[i] == -long.max) { dist[v] = -long.max; continue; } if (dist[v] \u0026lt;= dist[i] + c) continue; dist[v] = -long.max; } } } if (dist[N - 1] == -long.max) { writeln(\u0026#34;inf\u0026#34;); } else { writeln(-dist[N - 1] + A[N - 1]); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } H - Just Solitaire 問題へのリンク 全く解けず\u0026hellip; 単純な貪欲は無理そうです。 dpを考えようとしても、あるボーナスを受け取るためにはこれまでのカードの使用状況を記録しなければならないため、$O(2^N)$程度の状態があり得ます。 現状の知識では太刀打ちできませんでした。 問題に対する感想 全体を通して難易度調整がいい感じだと思いました。 典型パンチで倒せる問題がいくつかあり、想定レベルの参加者(私くらい？)にとって良い練習になったのではないかと思います。 懇親会も出ました。 オンサイトコンテストで他人と会話した経験がほとんどなかったのですが、本コンテストにおいては近くの方とお話しすることができました。 私は、私のことを他人から言及されているのを見てニヤニヤするタイプなので、他の人もそうだろうと仮定していくつか書きます。 あまり校正していない(する気がない)ので、乱文注意です。 まず、コンテスト開始前から終了後までcoindarwさんとお話することができました。 開始前はやることがなくてずっと席に座っていたのですが、声をかけてもらえてうれしかったです。 coindarwさんとはc++や競技プログラミングに関する話題で(自分的には)盛り上がった気がします。 ボス問が燃やす埋めるで解けるというのも教えてもらいました(理解はできていません)。このあたりのアルゴリズムは全く理解していなかったので、青コーダーはさすがだなぁと思いました。 横の席に西村さんが座っていたので、少しだけコンテストに関してお話しました。西村さんはRealforceを持ち込んで使用しており、業プロerだ\u0026hellip;と思いました。(持たせてもらいましたが、だいぶ重たかったです。フルサイズだしそれはそうか。) ベルマンフォードを検索で通したというのを褒めてもらって、ちょっと嬉しかったです。 私、実はMMA015の時にもCを検索で強引に通したりしています。謎のゴリ押し得意なのでしょうか。 西村さんは私のTwitterアカウントを開設してから初めてフォローしてくれた競技プログラミング界隈の方なので、印象に残っていました。(当時、界隈の方を誰もフォローしていなかったはずなのですが、どうやって見つけたんでしょうか) それから真鍋愛さんという方が加わり、ゲームやアニメの話などをしました。当日私は ハヤトの野望 というyoutuberのファングッズを身に着けていたのですが、真鍋さんもハヤトの野望のファンらしく、リアルでハヤトの話ができて楽しかったです。 フロムゲーに関する話題もありました。自分は名前しか知らなかったのですが、機会があればプレイしてみたいです。(地底人とかいう謎の単語が印象に残っています。) それと、coindarwさんとまぞくについての話をもっとしたかったなぁという若干の心残りがあります。(← それよりも、早く感想エントリを書かなければ) それからやきとりさん、sepaさん、くしらさんが加わり、人数多めでお話ししました。 このあたりで気が付いたのですが、私のハンドルネーム「InTheBloom」、呼ばれるととても恥ずかしいです。こんなヤバ目のハンドルネーム、そうそういない気がします。今更ですが、割と後悔していたり。でも気に入っているんですよね。 元は「In」というのがあり、そこに「TheBloom」を付け足した形がこれなので、全部Inで統一しようかと真面目に考えてます。 若干話がそれました。 そこからはやきとりさん、sepaさん、くしらさんたちがMMAについての話などをしているのを聞いていました。緑以下第三回やMMA019オンサイトの可能性が示唆されており、楽しみだなーと思って聞いていました。 そこからは大体競技プログラミング関連のお話をしていました。二分探索のlogとsetのlogの重さが全然違う話など、だれに通じるんだよみたいな話が飛び交っており、面白かったです。 どなたかがatkinの篩を持っているという話をしていたのが印象的です。(何に使うんだろう) 社交が苦手な私ですが、競技プログラミング界隈の方とお話しするという貴重な経験をすることができました。 特に、電通大競技プログラミングコミュニティでお世話になっているcoindarwさん、やきとりさん、sepaさんとお話できてよかったです。 終わりに オンサイトで、かつ難易度がちょうどいいものには積極的に出ようと思っています。 次回も楽しみです。"
  },
  {
    url: "/post/abc345/",
    title: "ABC345参加記録",
    date: "2024-03-29T00:00:00+09:00",
    body: "ABC345参加記録 はじめに 珍しくいくつかやることがあったのと、数日体調を崩していたため参加記録をサボっていました。 2週間遅刻ですが書きます。 戦績 順位 : 1593th パフォーマンス : 1342 レーティング変動 : 1373 → 1370 (-3) 問題 コンテストページ A - Leftrightarrow 問題へのリンク 先頭と末尾がそれぞれ\u0026lt;, \u0026gt;で、残りの中央の文字が=のみであればYesです。 import std; void main () { string S = readln.chomp; bool ok = true; if (!(S[0] == \u0026#39;\u0026lt;\u0026#39; \u0026amp;\u0026amp; S[$-1] == \u0026#39;\u0026gt;\u0026#39;)) ok = false; S = S[1..$-1]; foreach (c; S) if (c != \u0026#39;=\u0026#39;) ok = false; if (ok) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Integer Division Returns 問題へのリンク 切り上げを出力する問題です。 $X$が正のときは典型テクで、$\\lceil \\frac{X}{10} \\rceil = \\lfloor \\frac{X + 9}{10} \\rfloor$が成立します。 $X$が負のときは単に切り捨てすればよいです。 import std; void main () { long X = readln.chomp.to!long; if (0 \u0026lt;= X) writeln((X + 10 - 1) / 10); else writeln(X / 10); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 負のときの処理を今まで考えたことがなかったです。 C - One Time Swap 問題へのリンク ちょうど1回だけスワップしてできる文字列の種類数を数えます。 スワップして別の文字列になるとしましょう。 このとき、選択する2文字は異なっている必要があります。 また、上記のようなスワップによってできた文字列はすべて相異なります。 理由はシンプルで、例えば$(i, j)$を選択してスワップした文字列を$S$、$(k, l)$を選択してスワップした文字列を$T$とします。 ただし、$i \\neq k$または$j \\neq l$の少なくとも一方が成立するとします。 このとき、仮定より$S _ i \\neq T _ i$または$S _ j \\neq T _ j$の少なくとも一方が成立するからです。 これらのうち少なくとも一箇所において、片方は変わっているけどもう片方は変わっていないっていうことですね。 スワップしてもとと同じになる場合を考えます。これができる必要十分条件は、$S$がある文字を$2$以上含むことです。 これらを数え上げればOKです。 前者は「自分より後ろとしかペアを作らない」という制約条件で楽に数えられます。 後者はそのままです。 import std; void main () { string S = readln.chomp; int[char] mp; long ans = 0; foreach_reverse (c; S) { foreach (key, val; mp) if (key != c) ans += val; mp[c]++; } foreach (key, val; mp) if (2 \u0026lt;= val) { ans++; break; } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Tiling 問題へのリンク 本番解けませんでしたが、解説ACしたので載せておきます。 長方形タイルでマスを埋められるかを判定します。 いかにも全探索という見た目をしています。 実際、目標マスがかなり大きいこと、タイルのサイズが自由であることからbitで状態を持つのは無理そうです。 しかし、この問題はよくあるdfsで置いていくやつは厳しそうです。 これは単純に長方形タイルが(目標マスのサイズに対して)多いからです。 もっといい感じの全探索を構築してあげないといけません。 ここで、置くタイルが長方形であることを利用して高速化できます。 左上から右下に次のように番号をつけて見ていくことにします。 1 2 3 ... N\rN+1 N+2 N+3 ... 2N\r...\rさて、任意の完成状態のタイルを考えて、上の順番に長方形を見ていきます。 すると、まだ未発見だったある長方形に出会うとき、必ず左上の角のマスに出会うことがわかります。 これはどのような配置でも例外なく共通しています。 このことから、任意の完成状態まで持っていける置き方は、タイルの使用順の順列と対応付けることができます。 これより、わざわざdfsをして置いていく必要がなく、タイルの使用順の順列を列挙する問題になります。 それぞれのタイルの使用順に対しては、上の順番でマスを見ていき、最初に出会った空きマスに左上の角を合わせて設置を試みれば良いです。 import std; void main () { int N, H, W; readln.read(N, H, W); auto tiles = new Tuple!(int, int)[](N); foreach (i; 0..N) { int A, B; readln.read(A, B); tiles[i] = tuple(A, B); } solve(N, H, W, tiles); } void solve (int N, int H, int W, Tuple!(int, int)[] tiles) { auto ord = iota(N).array; auto used = new bool[][](H, W); do { bool ok = false; void rec (int cur, int y, int x) { if (ok) return; while (y \u0026lt; H) { // 空いてる？ if (!used[y][x]) { if (N \u0026lt;= cur) return; { // 縦 bool next = true; if (y + tiles[ord[cur]][0] \u0026lt;= H \u0026amp;\u0026amp; x + tiles[ord[cur]][1] \u0026lt;= W) { foreach (i; 0..tiles[ord[cur]][0]) { foreach (j; 0..tiles[ord[cur]][1]) { if (used[y + i][x + j]) next = false; } } if (next) { foreach (i; 0..tiles[ord[cur]][0]) foreach (j; 0..tiles[ord[cur]][1]) used[y + i][x + j] = true; rec(cur + 1, y, x); foreach (i; 0..tiles[ord[cur]][0]) foreach (j; 0..tiles[ord[cur]][1]) used[y + i][x + j] = false; } } } { // 横 bool next = true; if (y + tiles[ord[cur]][1] \u0026lt;= H \u0026amp;\u0026amp; x + tiles[ord[cur]][0] \u0026lt;= W) { foreach (i; 0..tiles[ord[cur]][1]) { foreach (j; 0..tiles[ord[cur]][0]) { if (used[y + i][x + j]) next = false; } } if (next) { foreach (i; 0..tiles[ord[cur]][0]) foreach (j; 0..tiles[ord[cur]][1]) used[y + j][x + i] = true; rec(cur + 1, y, x); foreach (i; 0..tiles[ord[cur]][0]) foreach (j; 0..tiles[ord[cur]][1]) used[y + j][x + i] = false; } } } return; } // 進める x++; if (x == W) { y++; x = 0; } } ok = true; } rec(0, 0, 0); if (ok) { writeln(\u0026#34;Yes\u0026#34;); return; } } while (next_permutation(ord)); writeln(\u0026#34;No\u0026#34;); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } bool next_permutation (alias less = \u0026#34;a\u0026lt;b\u0026#34;, T) (T array) if (is (T == E[], E) || is (T == E[n], E, size_t n)) { import std.algorithm : swap, reverse; import std.functional : binaryFun; alias is_a_less_than_b = binaryFun!(less); int i = -1, j; foreach_reverse (idx; 1..array.length) { if (is_a_less_than_b(array[idx-1], array[idx])) { i = cast(int) (idx-1); break; } } // Next permutation doesn\u0026#39;t exists. if (i == -1) return false; foreach_reverse (idx; i+1..array.length) { if (is_a_less_than_b(array[i], array[idx])) { j = cast(int) idx; break; } } swap(array[i], array[j]); array[i+1..$].reverse; return true; } bool prev_permutation (alias less = \u0026#34;a\u0026lt;b\u0026#34;, T) (T array) if (is (T == E[], E) || is (T == E[n], E, size_t n)) { import std.algorithm : swap, reverse; import std.functional : binaryFun; alias is_a_less_than_b = binaryFun!(less); int i = -1, j; foreach_reverse (idx; 0..array.length-1) { if (is_a_less_than_b(array[idx+1], array[idx])) { i = cast(int) idx; break; } } // Previous permutation doesn\u0026#39;t exists. if (i == -1) return false; foreach_reverse (idx; i+1..array.length) { if (is_a_less_than_b(array[idx], array[i])) { j = cast(int)idx; break; } } swap(array[i], array[j]); array[i+1..$].reverse; return true; } 計算量は$O(N! 2^N HW)$くらいです。多分。 終わりに 未だに全探索を落としてしまうとは\u0026hellip;と落ち込みましたが、振り返ってみてこれは無理だなと思いました。 正直、すべて長方形であることを利用して、順列と置き方を対応付けるというのはとんでもなくad-hocに思えます。 解けた人がどこをとっかかりにしたのかがいまいちわからないので、どうしようもないです。 E問題も見ましたが、だいぶ間に合わないdpを思いついただけなので、ここには載せないことにします。 Dが解けなかったことにより、この回は実質開始7分で解答終了したみたいです。"
  },
  {
    url: "/post/abc346/",
    title: "ABC346参加記録",
    date: "2024-03-29T00:00:00+09:00",
    body: "ABC346参加記録 はじめに 前回のエントリ 同様に、更新できていませんでしたが更新します。 戦績 順位 : 1492th パフォーマンス : 1389 レーティング変化 : 1340 → 1345 (+5) 問題 コンテストページ A - Adjacent Product 問題へのリンク 隣接項の積を求めれば良いです。ループを回しましょう。 import std; void main () { int N = readln.chomp.to!int; auto A = readln.split.to!(int[]); foreach (i; 0..N - 1) { write(A[i] * A[i + 1]); if (i \u0026lt; N - 1) write(\u0026#34; \u0026#34;); } write(\u0026#34;\\n\u0026#34;); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Piano 問題へのリンク $W, B$が十分小さいため、$S$の最初の200文字程度を考えれば十分です。あとは連続部分列を全部攫っても間に合います。 import std; void main () { int W, B; readln.read(W, B); string S = \u0026#34;wbwbwwbwbwbw\u0026#34;; string T = \u0026#34;\u0026#34;; foreach (i; 0..100) T ~= S; foreach (i; 0..T.length) { foreach (j; i + 1..T.length) { int w = 0; int b = 0; foreach (k; i..j) { if (T[k] == \u0026#39;w\u0026#39;) w++; if (T[k] == \u0026#39;b\u0026#39;) b++; } if (w == W \u0026amp;\u0026amp; b == B) { writeln(\u0026#34;Yes\u0026#34;); return; } } } writeln(\u0026#34;No\u0026#34;); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Σ 問題へのリンク $K$が結構大きいため、$O(K)$は避けたいところです。ということで、$(総和) - (Aに現れたもの)$を考えるとうまく行きます。 補集合を考えるのは典型テクと言えるでしょう。 import std; void main () { int N, K; readln.read(N, K); auto A = readln.split.to!(int[]); bool[int] mp; foreach (a; A) mp[a] = true; long ans = 1L * K * (K + 1) / 2; foreach (key, val; mp) if (key \u0026lt;= K) ans -= key; writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Gomamayo Sequence 問題へのリンク 与えられた文字列をgomamayoに変化させる最小コストを問う問題です。 どこでgomamayoを作るかを探索できるかを考えます。 すると、gomamayo部分以外は必ず0101...または1010...となるので、元の文字列の連続部分列をこれらのいずれかに変化させるコストがわかれば良さそうです。 すなわち、変化させるコストの累積和を持てば良いことがわかります。 前半部分が0101...であるとき、gomamayo部分で2文字消費するため、後半は1010...の方を適用すれば良いです。 逆も同様です。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; auto C = readln.split.to!(int[]); solve(N, S, C); } void solve (int N, string S, int[] C) { // どこを揃えるか探索 auto zero_one = new long[](N + 1); auto one_zero = new long[](N + 1); foreach (i; 0..N) { if (i % 2 == 0) { if (S[i] == \u0026#39;0\u0026#39;) { zero_one[i + 1] = zero_one[i]; one_zero[i + 1] = C[i] + one_zero[i]; } else { zero_one[i + 1] = C[i] + zero_one[i]; one_zero[i + 1] = one_zero[i]; } } else { if (S[i] == \u0026#39;0\u0026#39;) { zero_one[i + 1] = C[i] + zero_one[i]; one_zero[i + 1] = one_zero[i]; } else { zero_one[i + 1] = zero_one[i]; one_zero[i + 1] = C[i] + one_zero[i]; } } } long ans = long.max; foreach (i; 0..N - 1) { { // 0 long candi = 0; if (i % 2 == 0) { candi += zero_one[i] + (one_zero[N] - one_zero[i + 2]); } else { candi += one_zero[i] + (zero_one[N] - zero_one[i + 2]); } if (S[i] == \u0026#39;1\u0026#39;) candi += C[i]; if (S[i + 1] == \u0026#39;1\u0026#39;) candi += C[i + 1]; ans = min(ans, candi); } { // 1 long candi = 0; if (i % 2 == 0) { candi += one_zero[i] + (zero_one[N] - zero_one[i + 2]); } else { candi += zero_one[i] + (one_zero[N] - one_zero[i + 2]); } if (S[i] == \u0026#39;0\u0026#39;) candi += C[i]; if (S[i + 1] == \u0026#39;0\u0026#39;) candi += C[i + 1]; ans = min(ans, candi); } } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } dpでも解けることをコンテスト終了後知りました。 前から順番に確定させていくことにします。このとき、最新の場所では 最後が何か すでにgomamayoを達成したか がわかれば十分です。 したがって、$\\mathrm{dp}[i][j][k] \\coloneqq (\\text{「先頭$i$項確定させて、最後の項が$j$で、すでにgomamayoかどうかが$k$」に至る最小コスト})$ とすれば良いです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; auto C = readln.split.to!(int[]); solve(N, S, C); } void solve (int N, string S, int[] C) { // 前からdpで決めていく auto dp = new long[][][](N + 1, 2, 2); // dp[i][j][k] := 先頭i文字確定して、最後がjで、すでにgomamayoかどうかがk foreach (d; dp) foreach (dd; d) dd[] = long.max; dp[1][0][0] = (S[0] == \u0026#39;0\u0026#39; ? 0 : C[0]); dp[1][1][0] = (S[0] == \u0026#39;1\u0026#39; ? 0 : C[0]); foreach (i; 1..N) { foreach (j; 0..2) { foreach (k; 0..2) { if (dp[i][j][k] == long.max) continue; int cost_1 = 0; if ((j + 1) % 2 != S[i] - \u0026#39;0\u0026#39;) cost_1 = C[i]; dp[i + 1][(j + 1) % 2][k] = min(dp[i + 1][(j + 1) % 2][k], dp[i][j][k] + cost_1); // gomamayoを作りに行く if (k == 0) { int cost_2 = 0; if (j != S[i] - \u0026#39;0\u0026#39;) cost_2 = C[i]; dp[i + 1][j][1] = min(dp[i + 1][j][1], dp[i][j][0] + cost_2); } } } } long ans = min(dp[N][0][1], dp[N][1][1]); writeln(ans); } E - Paint 問題へのリンク 巨大なグリッド上に、1行(列)ずつ色を塗っていく問題です。 まず、シミュレーションは無理なことがわかります。どうにかうまくやる必要があります。 さて、自分も結構突っかかりましたが、これらのクエリは後ろのクエリのほうが強いという性質があります。 縦か横かに関係なく、後ろのクエリならばそれより前のクエリより優先されます。 この性質により、一番最後から見ていけば楽になります。 縦と横で、すでに採用された本数を記録しておくことで、次に引く線が何回かき消されるかがわかるからです。 これが見えてしまえば割と簡単でした。 import std; void main () { int H, W, M; readln.read(H, W, M); auto paint = new Tuple!(int, int, int)[](M); foreach (i; 0..M) { int T, A, X; readln.read(T, A, X); A--; paint[i] = tuple(T, A, X); } solve(H, W, M, paint); } void solve (int H, int W, int M, Tuple!(int, int, int)[] paint) { // クエリを後ろから見れば良さげ？ paint.reverse; auto color_count = new long[](2 * 10^^5 + 1); auto used_h = new bool[](H); int count_h = 0; auto used_w = new bool[](W); int count_w = 0; foreach (p; paint) { int T = p[0]; int A = p[1]; int X = p[2]; if (T == 1) { if (used_h[A]) continue; used_h[A] = true; count_h++; color_count[X] += W - count_w; } if (T == 2) { if (used_w[A]) continue; used_w[A] = true; count_w++; color_count[X] += H - count_h; } } int count = 0; long sum = 0; foreach (i, v; color_count[1..$]) if (0 \u0026lt; v) { sum += v; count++; } color_count[0] = 1L * H * W - sum; if (0 \u0026lt; color_count[0]) count++; writeln(count); foreach (i, v; color_count) { if (v == 0) continue; writeln(i, \u0026#34; \u0026#34;, v); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 色0の処理には少し注意が必要です。(2ペナ食らいました。) F - SSttrriinngg in StringString 問題へのリンク 部分列判定をする問題です。 典型テクとして、「答えで二分探索」を考えます。 これができることはほぼ明らかなので、一回の判定問題をある程度高速に解ければOKです。 関数$f$の方はあくまで元の文字列をつなげたものなので、文字列の構造自体は破壊されません。 すでに使用した周回数と現在のカーソル位置を持てば、消化したい文字列を順番に見ていくことで判定問題を$O(|T| \\alpha)$くらいで解けます。($\\alpha$はそんなに重くないやつくらいで考えてください。) あとは場合分けを頑張るとACできます。 import std; void main () { long N = readln.chomp.to!long; string S = readln.chomp; string T = readln.chomp; solve(N, S, T); } void solve (long N, string S, string T) { // 前から消化していく感じで二分探索 bool[char] S_mp; foreach (c; S) S_mp[c] = true; foreach (t; T) { if (t !in S_mp) { // Tの文字でSにはいってないやつがある。 writeln(0); return; } } auto idx = new int[][](26, 0); // idx[i][j] := S中で文字iが前からj番目に現れるインデックス foreach (i, c; S) idx[c - \u0026#39;a\u0026#39;] ~= i.to!int; bool f (long x) { if (x == 0) return true; long used = 0; int cur = 0; foreach (t; T) { /* writeln(\u0026#34;char : \u0026#34;, t); writeln(\u0026#34;used : \u0026#34;, used); writeln(\u0026#34;cur : \u0026#34;, cur); writeln(); */ long X = x; // curがどこか探索 if (cur \u0026lt;= idx[t - \u0026#39;a\u0026#39;][$ - 1]) { int ng = -1, ok = idx[t - \u0026#39;a\u0026#39;].length.to!int - 1; while (1 \u0026lt; abs(ok - ng)) { int mid = (ok + ng) / 2; if (cur \u0026lt;= idx[t - \u0026#39;a\u0026#39;][mid]) { ok = mid; } else { ng = mid; } } enforce(cur \u0026lt;= idx[t - \u0026#39;a\u0026#39;][ok]); enforce(ng == -1 || idx[t - \u0026#39;a\u0026#39;][ng] \u0026lt; cur); enforce(ng + 1 == ok); // 今のページで消化しきれる？ if (X \u0026lt;= idx[t - \u0026#39;a\u0026#39;].length - ok) { // できる cur = idx[t - \u0026#39;a\u0026#39;][ok + X - 1] + 1; if (S.length \u0026lt;= cur) { cur = 0; used++; } continue; } else { // できないので、端数処理する X -= idx[t - \u0026#39;a\u0026#39;].length - ok; used++; cur = 0; } } else { // 次ページに進む used++; cur = 0; } used += X / idx[t - \u0026#39;a\u0026#39;].length; long rem = X % idx[t - \u0026#39;a\u0026#39;].length; if (rem == 0) used--; cur = idx[t - \u0026#39;a\u0026#39;][($ + rem - 1) % $] + 1; if (S.length \u0026lt;= cur) { cur = 0; used++; } if (N \u0026lt; used) return false; } if (0 \u0026lt; cur) return used \u0026lt; N; return used \u0026lt;= N; } long ok = 0, ng = 10L ^^ 18; while (1 \u0026lt; abs(ok - ng)) { long mid = (ok + ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(ok); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 細かい場合分けが多いので詳細は書きませんが、概ね消化する文字の最初と最後に気を使うとうまく行く気がします。 真ん中あたりは割り算でガッとやりましょう。 これdiff高いのかなり非自明です。(相対的に)作業量多いだけ感がありました。 終わりに 本番でFをギリギリ通せなかったのが少し悔しいですが、概ねやりきれたと思います。 DEをちゃんとACできて嬉しいです。"
  },
  {
    url: "/post/sumitb2019f/",
    title: "三井住友信託銀行プログラミングコンテスト2019F - Interval Running",
    date: "2024-03-14T00:00:00+09:00",
    body: "三井住友信託銀行プログラミングコンテスト2019F - Interval Running 問題概要 問題文 高橋くんと青木くんが同じ方向に向かって走っている。 高橋くんは最初の$T _ 1$分間は分速$A _ 1$メートルで走り、続く$T _ 2$分間は分速$A _ 2$メートルで走る。 青木くんは最初の$T _ 1$分間は分速$B _ 1$メートルで走り、続く$T _ 2$分間は分速$B _ 2$メートルで走る。 二人は同時に同じ位置からスタートし、上記の動きを繰り返す。 高橋くんと青木くんが同じ位置に来る回数を求めよ。 無限回同じ位置に来る場合は、その旨を報告せよ。 ただし、スタート地点はカウントしない。 制約 $1 \\leq T _ i \\leq 100000$ $1 \\leq A _ i \\leq 10^{10}$ $1 \\leq B _ i \\leq 10^{10}$ $A _ i \\neq B _ i$ 解法 高橋くんと青木くんの速度によっては同じ位置に来る回数がかなり多くなるため、二人の位置をトレスして答えるのは間に合いません。 うまく計算する必要があります。 典型的な考え方として、複数物体の動きを追う問題に対して、相対値を考えるとうまく行くことがあります。 今回は、一方から見たもう一方の運動の相対速度を考えることで問題がシンプルになります。 $V _ i \\coloneqq A _ i - B _ i$を考えます。 この値は、青木くんがスタート地点で静止しているとみなしたときの高橋くんの速度になります。 これにより、問題は次のように変化します。 高橋くんは、次の動きを繰り返す。 最初の$T _ 1$分間は分速$V _ 1$メートルで走り、続く$T _ 2$分間は分速$V _ 2$メートルで走る。 何回スタート地点に戻ってくるだろうか。 ここで、変更された問題においては高橋くんが負の座標に来ることがあることに注意してください。 まず、無限回になる条件は、最初の$T _ 1 + T _ 2$分間動いたあと、スタート地点に戻っていることです。 そうでない場合、1周期分のズレが十分な回数積み重なると、スタート地点に戻ってこれなくなるからです。 以降、有限回戻ってくるような場合について考えます。 このとき、「ある周回でスタート地点に戻ってこられるか」という問題を考えると、これは単調性があります。 これがなぜかと言われると、かっちり論理的に理由を説明できないです。(すみません) しかし、感覚的には次のような感じです。 高橋くんがスタート地点に戻ってこられるとき、振り子のような運動をする必要がある。ただし、この振り幅は右方向と左方向で差があるため、周回するごとにどんどん原点から離れていく。振り幅の差は一定であるから、一回原点に戻れなくなったら、それ以降も戻れない。 よって、戻ってこれなくなる周回がどこかを二分探索することで答えを求めることができます。 「振り子のような動きをしている」と言ったように、普通、高橋くんは1周期で2回スタート地点に戻ることになります。 2回戻ってくるというのは、すなわち次のようなことです。 元いた座標から最初の$T _ 1$分移動した座標を$X _ 1$、そこから$T _ 2$分移動した座標を$X _ 2$とする。このとき、$X _ 1$が$0$でなく、$X _ 1$と$X _ 2$の符号が異なる。 $X _ 1$が$0$であるとき、1周期で1回しかスタート地点に戻ってきていないことに注意してください。 上記のように、1周期で1回しかスタート地点に戻ってきていないときは、スタート地点に戻ってこられる最後の1回になります。 また、最初の1回目の移動では1回しかカウントされませんが、上記の判定では「2回戻ってくる動きである」と判定され、特別扱いする必要がなくなります。 具体的な実装としては、次のようになります。 bool f (long x) { x--; BigInt cur = one_cycle; cur *= x; cur += v[0] * T[0]; BigInt nex = cur + v[1] * T[1]; if (cur == 0) return false; int p = (0 \u0026lt;= cur) ? 0 : 1; int q = (0 \u0026lt;= nex) ? 0 : 1; return 0 \u0026lt; (p ^ q); } $f(x)$は「$x$周目の動きで2回戻ってこられるか？」を判定しています。 符号判定はxorでうまく処理しています。 実装例 import std; void main () { int[2] T; long[2] A, B; T = readln.split.to!(int[2]); A = readln.split.to!(long[2]); B = readln.split.to!(long[2]); solve(T, A, B); } void solve (int[2] T, long[2] A, long[2] B) { long[2] v = [A[0] - B[0], A[1] - B[1]]; long one_cycle = v[0] * T[0] + v[1] * T[1]; if (one_cycle == 0) { writeln(\u0026#34;infinity\u0026#34;); return; } bool f (long x) { x--; BigInt cur = one_cycle; cur *= x; cur += v[0] * T[0]; BigInt nex = cur + v[1] * T[1]; if (cur == 0) return false; int p = (0 \u0026lt;= cur) ? 0 : 1; int q = (0 \u0026lt;= nex) ? 0 : 1; return 0 \u0026lt; (p ^ q); } long ok = 0, ng = 10L^^18; while (1 \u0026lt; abs(ok - ng)) { long mid = (ok + ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } long ans = 0; if (0 \u0026lt; ok) ans = 2 * ok - 1; // 最後ピッタリ踏むか？ BigInt last = one_cycle; last *= ok; last += v[0] * T[0]; if (last == 0) ans++; writeln(ans); } 最初の余分なカウントを引いていること、最後に1回だけ戻ってくるケースを処理していることに注意してください。 終わりに 一回目にスタート地点にいるせいで、かなり誤答しました。 とてもむずかしかったです。 相対値を利用する問題はたくさんあるので、慣れていけたらいいと思います。"
  },
  {
    url: "/post/abc35d/",
    title: "ABC35D - トレジャーハント",
    date: "2024-03-12T00:00:00+09:00",
    body: "ABC35D - トレジャーハント 問題概要 問題へのリンク 問題文 $1$から$N$の番号が割り振られた$N$個の町があり、$M$本の道がこれらの町を結んでいる。 $i$番目の道を用いることで$a _ i$番目の町から$b _ i$番目の町へと移動できるが、逆はできない。 高橋君は、$i$番目の町に1分間滞在することで、$A _ i$円得ることができる。 また、高橋君の開始$0$分時点での所持金は$0$円で、開始$0$分時点と$T$分時点で$1$番目の町にいたことがわかっている。 高橋君の所持金は、最大でいくらまで増やせるだろうか。 制約 $2 \\leq N \\leq 10^5$ $1 \\leq M \\leq \\min (N(N-1), 10^5)$ $1 \\leq T \\leq 10^9$ $1 \\leq A _ i \\leq 10^5$ 解法 この問題において、高橋君がお金を得る町は1つに絞るのが最適になります。 条件を満たす動きであって、2つ以上の町でお金を得るようなものを考えます。 この時、得られる金額がより大きな町のみでお金を稼ぐようにすると、必ず元の解以上の金額を得ることができるからです。 以上より、本問題は次の値を求められれば良いです。 $$ \\max _ {1 \\leq k \\leq N} ( A _ k \\times \\max(0, T - (\\text{町$1$から町$k$に行く最短時間}) - (\\text{町$k$から町$1$に行く最短時間})) ) $$ $(\\text{町$1$から町$k$に行く最短時間})$はダイクストラ法などで十分高速に計算することができます。 厄介なのは、$(\\text{町$k$から町$1$に行く最短時間})$を求めるところです。 厄介な点は次の2つです。 有向グラフにおいて、町$1$から町$k$の最短経路は町$k$から$1$の最短経路と異なる可能性があるので、町$1$からの最短経路が使いまわせない。 各頂点からダイクストラ法をすると間に合わない。 実は、すべての$(\\text{町$k$から町$1$に行く最短時間})$を1回のダイクストラ法で計算するうまい方法があります。 それは、通行方向を逆にしたグラフ上で町$1$からの最短経路問題を解くことです。 なぜこれが動作するのかの説明をします。 まず、元のグラフ上で、ある町$k$から町$1$への最短経路を成す頂点列$(v _ 0, v _ 1, \\dots , v _ x)$を考えます。 ここで、$v _ 0 = k$と$v _ x = 1$が成立することに注意してください。 辺の通行方向を逆にしたグラフを考えると、明らかに頂点列$(v _ x, v _ {x-1}, \\dots , v _ 0)$を経由するパスが存在し、そのコストも等しいです。 そして、逆グラフにおいてもこれ以上コストを小さくするパスは存在しません。なぜなら、そのようなパスが存在するとき、元のグラフ上にも存在するはずだからです。 元のグラフ上で町$k$から町$1$に到達不能であるときも、同様の議論により逆グラフにおいて到達不能であることが言えます。 よって、逆グラフ上での町$1$からの探索は正しい値を返します。 以上より、本問題を解くことができます。 実装例 import std; void main () { int N, M, T; readln.read(N, M, T); auto A = readln.split.to!(int[]); auto edges = new Tuple!(int, int, int)[](M); foreach (i; 0..M) { int a, b, c; readln.read(a, b, c); a--, b--; edges[i] = tuple(a, b, c); } solve(N, M, T, A, edges); } void solve (int N, int M, int T, int[] A, Tuple!(int, int, int)[] edges) { // どの場所で金稼ぎをするか？を全探索できる // 逆辺をはることで帰りの時間を求められる。 auto one_to_k = new long[](N); auto k_to_one = new long[](N); one_to_k[] = long.max; k_to_one[] = long.max; BinaryHeap!(Tuple!(int, long)[], \u0026#34;b[1] \u0026lt; a[1]\u0026#34;) PQ = []; { auto graph = new Tuple!(int, int)[][](N, 0); foreach (e; edges) { graph[e[0]] ~= tuple(e[1], e[2]); } // 1 -\u0026gt; k PQ.insert(tuple(0, 0L)); while (!PQ.empty) { auto h = PQ.front; PQ.removeFront; int u = h[0]; long cost = h[1]; if (one_to_k[u] \u0026lt; cost) continue; one_to_k[u] = cost; foreach (to; graph[u]) { int v = to[0]; long new_cost = cost + to[1]; if (one_to_k[v] \u0026lt;= new_cost) continue; one_to_k[v] = new_cost; PQ.insert(tuple(v, new_cost)); } } } { auto graph = new Tuple!(int, int)[][](N, 0); foreach (e; edges) { graph[e[1]] ~= tuple(e[0], e[2]); } // k -\u0026gt; 1 PQ.insert(tuple(0, 0L)); while (!PQ.empty) { auto h = PQ.front; PQ.removeFront; int u = h[0]; long cost = h[1]; if (k_to_one[u] \u0026lt; cost) continue; k_to_one[u] = cost; foreach (to; graph[u]) { int v = to[0]; long new_cost = cost + to[1]; if (k_to_one[v] \u0026lt;= new_cost) continue; k_to_one[v] = new_cost; PQ.insert(tuple(v, new_cost)); } } } long ans = 0; foreach (i; 0..N) { if (one_to_k[i] == long.max || k_to_one[i] == long.max) continue; if (T \u0026lt;= one_to_k[i] + k_to_one[i]) continue; ans = max(ans, A[i] * (T - (one_to_k[i] + k_to_one[i]))); } writeln(ans); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 感想 「元のグラフの$k \\rightarrow 1$最短経路は逆グラフの$1 \\rightarrow k$最短経路と同じ」という事実を非自明に感じたので、解法を残しておくことにした。 いつか別の問題に役立ちそうな気がする。"
  },
  {
    url: "/post/abc344/",
    title: "ABC344 (upsolved)",
    date: "2024-03-11T00:00:00+09:00",
    body: "ABC344 (upsolved) 贖罪 寝過ごしでABCポカしてしまった。信じられない。。 \u0026mdash; In (@UU9782wsEdANDhp) March 9, 2024 最近参加記録を更新していませんでしたが、更新します。 問題たち A - Spoiler 問題へのリンク 現在見ている場所が|に挟まれているかを変数に持つようにして、逐次出力するか判定します。 import std; void main () { string s = readln.chomp; bool is_in = false; foreach (c; s) { if (c == \u0026#39;|\u0026#39;) { is_in = is_in ? false : true; continue; } if (is_in) continue; write(c); } write(\u0026#34;\\n\u0026#34;); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Delimiter 問題へのリンク この問題はどういう意図なんでしょうか\u0026hellip; 入力に0が来た時点で入力待ちをやめ、reverseして出力します。 import std; void main () { int[] A; while (true) { int a = readln.chomp.to!int; A ~= a; if (a == 0) break; } A.reverse; foreach (a; A) writeln(a); } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - A+B+C 問題へのリンク $A, B, C$から$1$個ずつ要素を選んだ和として実現可能なものの数は$O(NML)$個であり、十分少ないです。 したがって、これらを先に連想配列などに登録しておけばクエリあたり高速に解くことができます。 import std; void main () { int N = readln.chomp.to!int; auto A = readln.split.to!(int[]); int M = readln.chomp.to!int; auto B = readln.split.to!(int[]); int L = readln.chomp.to!int; auto C = readln.split.to!(int[]); bool[long] mp; foreach (a; A) foreach (b; B) foreach (c; C) mp[a + b + c] = true; int Q = readln.chomp.to!int; auto X = readln.split.to!(int[]); foreach (x; X) { if (x in mp) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - String Bags 私が個人的に「とる/とらないdp」と呼んでいるものの亜種にあたる気がします。 前から$i$袋に対して操作したときに、$T$の前からどこまで一致させられるかを持てば十分です。 私は慣れでdpにたどり着いてしまいましたが、dpを考えるモチベーションとしては、 ナイーブな$O((\\max A _ i) ^ N)$通りの全探索を考える。 $T$を構築できるとり方のとき、最後に$s _ \\mathrm{last}$をくっつけて$T$になるなら、それまでに$T$の先頭$|T| - |s _ \\mathrm{last}|$文字が作れれば良いことがわかる。 これを繰り返していくと、各時点で$T$の先頭何文字なら実現できるかを変数に持てばよさそうだなとなる。 ついでに何回の採用でその状態に至るかを管理できそう。 という感じでしょうか。 import std; void main () { string T = readln.chomp; int N = readln.chomp.to!int; auto S = new string[][](N, 0); foreach (i; 0..N) { auto input = readln.split; S[i] = input[1..$]; } solve(T, N, S); } void solve (string T, int N, string[][] S) { // いい感じにdpしましょう auto dp = new int[][](N+1, T.length+1); // dp[i][j] := 前からi袋に対して操作を行い、Tの前j文字一致させる最小値段 foreach (d; dp) d[] = int.max; dp[0][0] = 0; foreach (i; 0..N) { foreach (j; 0..T.length+1) { if (dp[i][j] == int.max) continue; // とる foreach (s; S[i]) { if (T.length \u0026lt; j + s.length) continue; if (T[j..j + s.length] != s) continue; dp[i + 1][j + s.length] = min(dp[i + 1][j + s.length], dp[i][j] + 1); } // とらない dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]); } } if (dp[N][T.length] == int.max) { writeln(-1); } else { writeln(dp[N][T.length]); } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Insert or Erase 問題へのリンク いい感じのグラフのようなものがあれば解けそうな感じです。 できるだけポインタを扱いたくないので、「新しい要素の追加」を「まだ未使用な頂点を用いる」として考えるようにします。 削除する必要があるので、頂点にどこからリンクされているか？という情報も持たせる必要がありそうです。 結論としては、次のようなノードを用いれば十分です。 struct node { int val = -1; int pre = -1; int nex = -1; } auto graph = new node[](N + Q); int[int] val_to_idx; int latest = 0; 新しいノードを追加するときはgraph[latest]をいじります。 なお、先頭ノードのpreは-int.maxに、最後尾ノードのnexはint.maxにすることにします。 import std; void main () { int N = readln.chomp.to!int; auto A = readln.split.to!(int[]); int Q = readln.chomp.to!int; solve(N, A, Q); } void solve (int N, int[] A, int Q) { // グラフ表現で答える struct node { int val = -1; int pre = -1; int nex = -1; } auto graph = new node[](N + Q); int[int] val_to_idx; int latest = 0; foreach (i; 0..N) { graph[latest] = node(A[i], i-1, i+1); if (i == 0) graph[latest].pre = -int.max; if (i == N-1) graph[latest].nex = int.max; val_to_idx[A[i]] = latest; latest++; } foreach (_; 0..Q) { auto input = readln.split; int t = input[0].to!int; if (t == 1) { int x = input[1].to!int; int y = input[2].to!int; int node_idx = val_to_idx[x]; int next_idx = graph[node_idx].nex; // 新しい頂点の追加 graph[latest] = node(y, node_idx, next_idx); // 元の次の頂点の書き換え if (next_idx \u0026lt; int.max) graph[next_idx].pre = latest; // 元の頂点の書き換え graph[node_idx].nex = latest; // 登録 val_to_idx[y] = latest; latest++; } if (t == 2) { int x = input[1].to!int; int node_idx = val_to_idx[x]; int prev_idx = graph[node_idx].pre; int next_idx = graph[node_idx].nex; // 前からのリンクの変更 if (-int.max \u0026lt; prev_idx) graph[prev_idx].nex = next_idx; // 次からのリンクの解除 if (next_idx \u0026lt; int.max) graph[next_idx].pre = prev_idx; // 登録解除 val_to_idx.remove(x); } } int cur = -1; foreach (key, val; val_to_idx) { if (graph[val].pre == -int.max) { cur = val; break; } } while (true) { write(graph[cur].val); if (graph[cur].nex == int.max) { write(\u0026#34;\\n\u0026#34;); break; } write(\u0026#34; \u0026#34;); cur = graph[cur].nex; } } void read (T...) (string S, ref T args) { import std.conv : to; import std.array : split; auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 少し前に この問題 を解いていたため、いい感じに解くことができました。 一発で合わせられて満足です。 F以降 わかりません！！！！！ F問題は解説を見てもいいかなと思ったのですが、どうしても抵抗があり、今はまだupsolveしていません。 difficultyと私のこだわりの呪いにより、永遠に伸び悩んでます。 終わりに このくらいサクッとした参加記録を書こうかなと思いました。 今までのスタイルはあまりにも作成がしんどいので。 面倒くささに負けたような気もして嫌だなぁとなりますが、継続こそ価値があると思うのです。 ちなみにこの回出てたら多分温まりです。勘弁してくれー"
  },
  {
    url: "/post/mmacontest016/",
    title: "MMA Contest 016 (upsolved)",
    date: "2024-03-06T00:00:00+09:00",
    body: "MMA Contest 016 (upsolved) はじめに 来るMMA Contest 018に備えて MMA Contest 016 のupsolveを行いました。 問題の振り返りをします。 問題たち A - 2KA 3 KA 問題へのリンク $X = 2(AB + AC + BC)$と$Y = ABC$が成立します。 #include \u0026lt;iostream\u0026gt; using namespace std; int main () { int A, B, C; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C; int X = 2*A*B + 2*A*C + 2*B*C; int Y = A*B*C; if (Y \u0026lt; X) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } B - 偶数判定！Nafmoくん 問題へのリンク 2進数の偶奇は末尾の桁のみを見ればよいです。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main () { string A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; if (A.back() == \u0026#39;0\u0026#39; || B.back() == \u0026#39;0\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;Even\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Odd\\n\u0026#34;; } } C - vs Slime 問題へリンク よくある漸化式が立つやつです。 $f(h) \\coloneqq (体力hのスライムに対する問題の解)$としたとき、 $f(h) = 1 + 2 f( \\lfloor \\frac{h}{A} \\rfloor )$ $f(0) = 0$ が成立します。さらに、「割った値を床関数にかける」を繰り返して得られる値は十分少ないです。 特に、$A = 2$の時$\\lfloor \\frac{h}{2^x} \\rfloor$か$\\lceil \\frac{h}{2^x} \\rceil$に限られるそうです。 証明は理解していませんが、 これ などが参考になりそうです。 よって、メモ化で通ります。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; using ll = long long; ll rec (ll H, ll A, map\u0026lt;ll, ll\u0026gt;\u0026amp; memo) { if (H == 0) return 0; if (memo.find(H) != memo.end()) return memo[H]; ll res = 1 + 2 * rec(H/A, A, memo); memo[H] = res; return memo[H]; } int main () { // 再帰メモ化していいやつ。atcoderに似た問題あった気がする ll H, A; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; A; map\u0026lt;ll, ll\u0026gt; memo; cout \u0026lt;\u0026lt; rec(H, A, memo) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } D - Div Count 問題へのリンク ある$0 \u0026lt; A$を一つ固定します。この$A$が条件を満たすとは、次のことです。 ある整数$0 \\leq p$が存在して、$N = pA + K$かつ$K \u0026lt; A$が成立する。 この時、$p = \\frac{N-K}{A}$となるため、ある$A$が条件を満たすとき、$p$は一意であることがわかります。 すなわち、条件を満たす$A$の必要十分条件は$A \\vert (N-K)$かつ$K \u0026lt; A$です。 以上より、$N-K$の約数を列挙できれば良いことがわかります。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; vector\u0026lt;ll\u0026gt; enum_divs (ll x) { vector\u0026lt;ll\u0026gt; res; for (int i = 1; i \u0026lt;= x; i++) { if (x \u0026lt; 1LL * i * i) break; if (x % i == 0) { res.push_back(i); if (x / i != i) res.push_back(x/i); } } sort(res.begin(), res.end()); return res; } int main () { ll N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; auto divs = enum_divs(N-K); int ans = 0; for (auto\u0026amp; v : divs) if (K \u0026lt; v) ans++; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } E - 情報通だよ！Nafmoくん 問題へのリンク 連結成分内で出来るだけペアを組むのが最適です。 したがって、$(余る人の総和)/2$が解になります。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class UnionFind { private: vector\u0026lt;int\u0026gt; par, size; public: UnionFind (int N) { par.resize(N); size.resize(N); for (int i = 0; i \u0026lt; N; i++) { par[i] = i; size[i] = 1; } } int root (int u) { if (par[u] == u) return u; return par[u] = root(par[u]); } void unite (int u, int v) { int l = root(u); int s = root(v); if (l == s) return; if (size[l] \u0026lt; size[s]) swap(l, s); size[l] += size[s]; par[s] = l; } bool same (int u, int v) { return root(u) == root(v); } int groupsize (int u) { return size[u]; } }; int main () { // 余るのは常に連結成分数の端数だけ -\u0026gt; UF int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; UnionFind UF(2*N); for (int i = 0; i \u0026lt; M; i++) { int A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; A--, B--; UF.unite(A, B); } int ans = 0; for (int i = 0; i \u0026lt; 2*N; i++) { if (UF.root(i) == i) ans += UF.groupsize(i) % 2; } ans /= 2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } F - MMA文字列2 問題へのリンク 「先頭$i$文字から作れる部分列で、大文字2文字を0, 1, 2文字連続したものは何通りとれるか」を計算していけば良いです。 $\\mathrm{dp}[i][j][k] \\coloneqq (先頭i文字から、文字\u0026rsquo;A\u0026rsquo; + jがk個連続する部分列を何通りとれるか)$とします。 初期値は $\\mathrm{dp}[0][j][0] = 1$ で、新しく追加する文字$c$に対して、 $\\mathrm{dp}[i+1][c][k] += \\mathrm{dp}[i][c][k-1]$ と更新すればよいです。更新されるところ以外は$c$は3文字目として使えるので、$\\mathrm{dp}[i][j][2]$を答えに足しこんでいきます。 実装上は最新の配列のみを持てばよいです。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; int main () { string S; cin \u0026gt;\u0026gt; S; // (文字)と // (文字)(文字)が何通りあるかをカウントしながら進んでいけばwordsize分で行ける ll ans = 0; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(26, vector\u0026lt;ll\u0026gt;(3, 0)); for (int i = 0; i \u0026lt; 26; i++) dp[i][0] = 1; for (int i = 0; i \u0026lt; S.size(); i++) { // 更新 for (int k = 2; 1 \u0026lt;= k; k--) dp[S[i] - \u0026#39;A\u0026#39;][k] += dp[S[i] - \u0026#39;A\u0026#39;][k-1]; // それ以外の文字はMMAを完成させる for (int j = 0; j \u0026lt; 26; j++) { if (j == S[i] - \u0026#39;A\u0026#39;) continue; ans += dp[j][2]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } G - Simple Problem 問題へのリンク $$ \\begin{equation} \\begin{split} \u0026amp;\\sqrt{A} + \\sqrt{B} \u0026lt; X \\newline \\Rightarrow ~ \u0026amp; A + 2\\sqrt{AB} + B \u0026lt; X^2 \\newline \\Leftrightarrow ~ \u0026amp; 2\\sqrt{AB} \u0026lt; X^2 - (A+B) \\newline \\Rightarrow ~ \u0026amp; 4AB \u0026lt; (X^2 - (A+B))^2 \\end{split} \\end{equation} $$ となり、根号を排除できます。 ただし、最初と最後は同値ではないことに注意してください。 同値にするには、$0 \u0026lt; X$と$(A+B) \u0026lt; X^2$を追加すればよいです。 以上より、二分探索で解けます。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;boost/multiprecision/cpp_int.hpp\u0026gt; using namespace std; using ll = long long; using namespace boost::multiprecision; ll solve (int A, int B) { auto f = [\u0026amp;](ll X) -\u0026gt; bool { cpp_int a = A, b = B, x = X; return 0 \u0026lt; x*x - a - b \u0026amp;\u0026amp; 4 * a * b \u0026lt; (x*x - (a+b)) * (x*x - (a+b)); }; ll ok = 65000, ng = 0; while (1 \u0026lt; abs(ok-ng)) { ll mid = (ok + ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } return ok; } int main () { int N; cin \u0026gt;\u0026gt; N; // 二回2乗してやれば二分探索できそうな形になる(った) // -\u0026gt; アッ、二乗したときに符号関連の情報が死んでるっぽい while (N--) { int A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; auto ans = solve(A, B); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 同値性が失われていることを忘れており、精度死しているのかと思ってcpp_intを持ち出してしまいました。 H - entrsys? 問題へのリンク クエリ2は人ごとに入退室の時間をstd::mapに入れていけば良いです。 クエリ1はrange_add、point_getができればよいです。 出現しうる座標を先読み + 座標圧縮をし、Dynamic range sum queryができるデータ構造の上でimos法をすることで達成できます。 注意として、mapに退室情報を入れるときに、入力情報を上書きしてはいけません。(これでめちゃくちゃ不正解を出しました。) #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;atcoder/segtree\u0026gt; using namespace std; using namespace atcoder; int op (int x, int y) { return x + y; } int e () { return 0; } int main () { // クエリ2 -\u0026gt; 座圧 + 区間加算、1点取得のセグ木。 // クエリ1と3 -\u0026gt; 人ごとにmapを持っておいて、lower_boundしましょう。 int N; cin \u0026gt;\u0026gt; N; map\u0026lt;string, int\u0026gt; X_inv; vector\u0026lt;string\u0026gt; X(N); vector\u0026lt;int\u0026gt; L(N), R(N); for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; X[i] \u0026gt;\u0026gt; L[i] \u0026gt;\u0026gt; R[i]; int len = (int) X_inv.size(); if (X_inv.find(X[i]) == X_inv.end()) X_inv[X[i]] = len; } int Q; cin \u0026gt;\u0026gt; Q; vector\u0026lt;int\u0026gt; type(Q), l(Q), r(Q), t(Q); vector\u0026lt;string\u0026gt; x(Q); for (int i = 0; i \u0026lt; Q; i++) { cin \u0026gt;\u0026gt; type[i]; if (type[i] == 1) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; t[i]; int len = (int) X_inv.size(); if (X_inv.find(x[i]) == X_inv.end()) X_inv[x[i]] = len; } if (type[i] == 2) { cin \u0026gt;\u0026gt; t[i]; } if (type[i] == 3) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; r[i]; int len = (int) X_inv.size(); if (X_inv.find(x[i]) == X_inv.end()) X_inv[x[i]] = len; } } // 座圧 vector\u0026lt;int\u0026gt; f_inv; for (int i = 0; i \u0026lt; N; i++) { f_inv.push_back(L[i]); f_inv.push_back(R[i]); } for (int i = 0; i \u0026lt; Q; i++) { if (0 \u0026lt; l[i]) f_inv.push_back(l[i]); if (0 \u0026lt; r[i]) f_inv.push_back(r[i]); if (0 \u0026lt; t[i]) f_inv.push_back(t[i]); } sort(f_inv.begin(), f_inv.end()); f_inv.erase(unique(f_inv.begin(), f_inv.end()), f_inv.end()); map\u0026lt;int, int\u0026gt; f; for (int i = 0; i \u0026lt; f_inv.size(); i++) f[f_inv[i]] = i; // セグ木 segtree\u0026lt;int, op, e\u0026gt; seg(f.size() + 10); auto range_add = [\u0026amp;](int l, int r, int v) -\u0026gt; void { seg.set(l, seg.get(l) + v); seg.set(r, seg.get(r) - v); }; auto point_get = [\u0026amp;](int x) -\u0026gt; int { return seg.prod(0, x+1); }; for (int i = 0; i \u0026lt; N; i++) { range_add(f[L[i]], f[R[i]] + 1, 1); } // map enum STATE { IN, OUT, }; vector\u0026lt;map\u0026lt;int, STATE, greater\u0026lt;int\u0026gt;\u0026gt;\u0026gt; mp(X_inv.size()); for (int i = 0; i \u0026lt; N; i++) { int idx = X_inv[X[i]]; mp[idx][L[i]] = IN; mp[idx].try_emplace(R[i] + 1, OUT); } // クエリ処理 for (int i = 0; i \u0026lt; Q; i++) { if (type[i] == 1) { int idx = X_inv[x[i]]; auto it = mp[idx].lower_bound(t[i]); if (it == mp[idx].end() || it-\u0026gt;second == OUT) { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } } if (type[i] == 2) { cout \u0026lt;\u0026lt; point_get(f[t[i]]) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } if (type[i] == 3) { int idx = X_inv[x[i]]; mp[idx][l[i]] = IN; mp[idx].try_emplace(r[i] + 1, OUT); range_add(f[l[i]], f[r[i]] + 1, 1); } } } 解法は10分以内に見えた一方、慣れない言語でこれをやるのは本当にしんどかったです。 I - regisys? 問題へのリンク おそらく貪欲だろうなという点以外全くわかりませんでした。 とりあえず解説ACしましたが、正当性がわからないので提出は載せません。 SSRS氏のユーザー解説がありますが、こちらは私のレベルを大きく超えているため現時点では理解をあきらめました。(Hallの結婚定理の事実だけ覚えておきました。) J - Merge Stones 問題へのリンク $i$から右回りに$j$個とった連続区間を考え、これを色$c$の一つの石にまとめられるか？という状態を考えます。 $\\Theta (3^N)$のbit DPのように、完成状態から一つむしり取るような遷移で$O(N^3 50K)$の区間DPができます。 提出 上の提出のように、これは間に合いません。 ここで、詰まってしまい、解説を見ました。 「$i$から右回りに$j$個とった連続区間を色$c$にまとめられるか？」が1bitにまとめられることを利用して、64bit整数型に押し込むことでword sizeの高速化をします。 遷移に関しては、 切れ目の右側を$k$bits右シフト、左側はそのままとのbitwise AND 切れ目の右側を$k$bits左シフト、左側はそのままとのbitwise AND 切れ目の左側を$k$bits右シフト、右側はそのままとのbitwise AND 切れ目の左側を$k$bits左シフト、右側はそのままとのbitwise AND の4通りを考え、これらと分割元とのbitwise ORをとることで達成できます。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; using ull = unsigned long long; int main () { // 色と場所を持って区間dpできそう -\u0026gt; 間に合わないが、真偽値によるdpであることを考えるとワードサイズ分の高速化が効く int N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; vector\u0026lt;int\u0026gt; A(N), C(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; C[i]; for (int i = 0; i \u0026lt; N; i++) C[i]--; vector\u0026lt;vector\u0026lt;ull\u0026gt;\u0026gt; dp(N, vector\u0026lt;ull\u0026gt;(N+1, 0)); // dp[i][j] := iから右回りにj個の区間を全統合したとき、作成可能な色のセット for (int i = 0; i \u0026lt; N; i++) dp[i][1] = 1ull\u0026lt;\u0026lt;C[i]; ull mask = (1ull\u0026lt;\u0026lt;50) - 1; for (int j = 2; j \u0026lt;= N; j++) { for (int i = 0; i \u0026lt; N; i++) { for (int mid = 1; mid \u0026lt; j; mid++) { // 右シフト or 左シフト for (int k = 0; k \u0026lt;= K; k++) { dp[i][j] |= dp[i][mid] \u0026amp; (dp[(i+mid) % N][j-mid] \u0026gt;\u0026gt; k); dp[i][j] |= (dp[i][mid] \u0026gt;\u0026gt; k) \u0026amp; dp[(i+mid) % N][j-mid]; dp[i][j] |= dp[i][mid] \u0026amp; (dp[(i+mid) % N][j-mid] \u0026lt;\u0026lt; k); dp[i][j] |= (dp[i][mid] \u0026lt;\u0026lt; k) \u0026amp; dp[(i+mid) % N][j-mid]; } } dp[i][j] \u0026amp;= mask; } } ll ans = 0; for (int i = 0; i \u0026lt; N; i++) for (int j = 1; j \u0026lt;= N; j++) for (int c = 0; c \u0026lt; 50; c++) if (0 \u0026lt; dp[i][j]) { ll sum = 0; for (int k = 0; k \u0026lt; j; k++) sum += A[(i + k) % N]; ans = max(ans, sum); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 終わりに 体感難易度は次のような感じです。 A \u0026lt; B \u0026lt; C \u0026lt; E \u0026lt; D \u0026lt; F \u0026lt; G \u0026lt; H \u0026lt; J \u0026lt; I 後ろ3問はほんとに疲れました。"
  },
  {
    url: "/post/20th-birthday/",
    title: "20歳になりました。",
    date: "2024-03-01T00:00:00+09:00",
    body: "20歳になりました。 せっかく20歳になったので、なんか書きます 本日2024年3月1日は私の誕生日です。こんな私でも20歳になってしまいました。 日本では 明治時代からの名残 (？)から20歳を子供から大人に変化する節目とするそうです。 なんてことでしょう、いつの間にか大人になってしまいました。 誕生日ではしゃぐノリはあまり好きではないのですが、節目なので記念に何か書いておこうと思います。 来歴 さて、生まれて20年経ったというと「もうそんなにたったのかぁ」みたいな気持ちになります。 が、よくよく思い返してみるとハッキリ思い返せる記憶が全然なくてびっくりしています。 本当は昔話とかを書きたかったのですが、細部が思い出せないのでめちゃくちゃざっくりした来歴でも書いておこうかなと思います。 2004年3月1日、神戸に生まれる。 少しの間、愛知県名古屋市で暮らす。(記憶は全くない) 北海道札幌市に引っ越す。札幌には小学校4年の終わりまで住んでいた。 今思えば、小さいころを過ごすには良い土地だったような気がする。 スキーによく行かせてもらった。クロスカントリースキーも少し経験がある。 親の勧め(強制)で少しだけ水泳とサッカーをやっていた。どちらもへたくそだったが、特にサッカーが苦痛でたまらなかった。 家の近くに生鮮市場という謎スーパー？があった。 神奈川県川崎市に引っ越す。川崎には小学校5年の終わりまで住んでいた。 このころはまだ「連絡帳」なるクラスの電話番号を共有する謎文化があって、積極的に遊ぼうよと電話していた覚えがある。 それと、同じマンションに住んでいた子と仲良くしてもらっていたのを思い出す。 彼の飛び出せどうぶつの森はバージョンダウンが可能な時期のものだったので、勝手に南の島を無限増殖スポットにしていた。ごめんよ。 公文式に通っていたが、家から遠いわ時間取られるわで当時ブチギレだったらしい。あまりおぼえていない。 去年そこを見に行ったが、まだ公文はあった。 兵庫県神戸市に引っ越す。神戸には高校3年生の終わりまで住んでいた。 人生のかなり大きな転機になった。いい意味でも悪い意味でも。 この数年間を通して、人間付き合いがかなり下手になった気がする。(いや、もしかしたらカスなのがあらわになっただけなのかも) 神戸は「下町」という感じで、これまでの人生で関わったことのない(あまり関わりたいと思っていなかった)人たちとのかかわりを余儀なくされた。 ぶっちゃけ、中学卒業までの4年間くらいはかなりキていて、基本的に学校が嫌いだった。 中学/高校ではソフトテニス部に入っていた。しかし、いまいち熱意も才能もないため、特段上達することはなかった。 ただし、高校ソフトテニス部の同期には恵まれたような気がする。 高校1年くらいの時にパソコンと出会う。最初に触るようになったきっかけはスーパーマリオメーカーのプレイ動画を投稿したかったからだった。 そのうち自分のデスクトップを購入するに至り、現在このエントリもそれで書いている。 東京都調布市に引っ越す。 担任の先生に紹介された謎大学、「電気通信大学」になんやかんやで進学することになった。二次試験で有機化学が出なくて本当に助かった。 共通テストも散々だった。具体的には地理Bは平均点を割ってしまったし、数学IAの選択問題は0点だった。意外となんとかなってしまった。 大学に友人が2人くらいしかいないが、とりあえず生きている。 2022年9月あたりからプログラミングの学習を始め、同年11月あたりで競技プログラミングに出会う。以後、現在に至るまでそこそこ力を入れて取り組んでいる。 今思えば昔話だなぁという感じです。私より転校経験している人、あまりいないんじゃないでしょうか。 思い返したくもないカスみたいなこともたくさんありましたが、とりあえず絶命しなければ耐えるらしいということを学びました。 これからの展望 今のところ、将来の野望や目標はありません。 自分の心のルールを違反しないように、今向かっていることに精いっぱい取り組めたらいいなと思います。 おわりに 数年後の私はこれを読んでどう思うんでしょうか。 ここまで読んでいただき、ありがとうございました。"
  },
  {
    url: "/post/tenka1_2015_qualbb/",
    title: "天下一プログラマーコンテスト2015予選B - 天下一リテラル",
    date: "2024-02-28T00:00:00+09:00",
    body: "天下一プログラマーコンテスト2015予選B - 天下一リテラル 問題概要 問題 スクリプト言語hnwには整数型、辞書型、集合型が存在する。 整数型のリテラルは$0$以上$10^6$以下の整数を十進数で表記したものである。 辞書型、集合型のリテラルは以下の EBNF に従う。 DICT = \u0026#34;{\u0026#34; , EXPR , \u0026#34;:\u0026#34; , EXPR , { \u0026#34;,\u0026#34; , EXPR , \u0026#34;:\u0026#34; , EXPR } , \u0026#34;}\u0026#34; | \u0026#34;{}\u0026#34; ; SET = \u0026#34;{\u0026#34; , EXPR , { \u0026#34;,\u0026#34; , EXPR } , \u0026#34;}\u0026#34; ; EXPR = DICT | SET | INTEGER ; 集合型か辞書型のリテラル$S$が与えられる。型を判定せよ。 制約 $\\lvert S \\rvert \\leq 50000$ 入力に空白は含まれない 解法 このような構文解析はEXPRを受け取り、型を判定するオラクルが存在すると仮定して考えると良いです。 まず、エイヤと関数だけ作ってしまいましょう。 enum HNW_TYPE { DICT, SET, INTEGER, UNDECIDED, } enum HNW_TYPE analize_expr (string s, ref int i) { } まず、INTEGERに関しては定義に再帰的なものが含まれていないため、これを処理します。 if (\u0026#39;0\u0026#39; \u0026lt;= s[i] \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { while (\u0026#39;0\u0026#39; \u0026lt;= s[i] \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) i++; return HNW_TYPE.INTEGER; } 別に数値をパースする必要はないので、読み飛ばしてしまいましょう。 DICT/SETのパースをしましょう。DICT/SETは必ず{から始まるので、ここを見つけるところからスタートです。 さらに、DICTのみ空なブラケットが許されるので、これは先に判定してしまいましょう。 if (s[i] == \u0026#39;{\u0026#39;) { i++; if (s[i] == \u0026#39;}\u0026#39;) { // 空のDICTのリテラル i++; return HNW_TYPE.DICT; } } 次に何らかのEXPRが来ますが、これは今作っている関数に丸投げします。 現時点でこの関数にEXPRを処理する能力はないですが、ばっちり処理してくれるということにします。 そのあとにはDICTであれば:が来て、SETであれば,か}が来ます。 auto res = HNW_TYPE.UNDECIDED; bool end_of_expr = false; while (true) { // any EXPR analize_expr(s, i); switch (s[i]) { case \u0026#39;:\u0026#39;: // DICT i++; analize_expr(s, i); res = HNW_TYPE.DICT; break; case \u0026#39;,\u0026#39;: // SET res = HNW_TYPE.SET; break; case \u0026#39;}\u0026#39;: // SET res = HNW_TYPE.SET; break; default: assert(0); } // 後ろの余計なものを処理 switch (s[i]) { case \u0026#39;,\u0026#39;: i++; break; case \u0026#39;}\u0026#39;: i++; end_of_expr = true; break; default: assert(0); } if (end_of_expr) break; } これでよさそうです。今までのものをつなげましょう。 実装 enum HNW_TYPE { DICT, SET, INTEGER, UNDECIDED, } enum HNW_TYPE analize_expr (string s, ref int i) { if (\u0026#39;0\u0026#39; \u0026lt;= s[i] \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { while (\u0026#39;0\u0026#39; \u0026lt;= s[i] \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) i++; return HNW_TYPE.INTEGER; } if (s[i] == \u0026#39;{\u0026#39;) { i++; if (s[i] == \u0026#39;}\u0026#39;) { // 空のDICTのリテラル i++; return HNW_TYPE.DICT; } } auto res = HNW_TYPE.UNDECIDED; bool end_of_expr = false; while (true) { // any EXPR analize_expr(s, i); switch (s[i]) { case \u0026#39;:\u0026#39;: // DICT i++; analize_expr(s, i); res = HNW_TYPE.DICT; break; case \u0026#39;,\u0026#39;: // SET res = HNW_TYPE.SET; break; case \u0026#39;}\u0026#39;: // SET res = HNW_TYPE.SET; break; default: assert(0); } // 後ろの余計なものを処理 switch (s[i]) { case \u0026#39;,\u0026#39;: i++; break; case \u0026#39;}\u0026#39;: i++; end_of_expr = true; break; default: assert(0); } if (end_of_expr) break; } return res; } 後はこの関数に渡した返り値を見てやればよいです。 提出 感想 $\\lvert S \\rvert \\leq 50000$だったので、特に考えずに再帰処理することができました。 この問題に関しては判定するだけであって、かつ変な入力は与えられないのでそこまで大変ではありませんでした。 しかし、ガチ解析をするにはもう少しBNF等に対する専門知識が必要になると思います。(私は完全に雰囲気で解いています。) この問題の公式解説が見つからなかったのですが、どこにあるか知っている人いませんか\u0026hellip;？"
  },
  {
    url: "/post/abc74d/",
    title: "ABC74D - Restoring Road Network",
    date: "2024-02-27T00:00:00+09:00",
    body: "ABC74D - Restoring Road Network 問題 問題へのリンク 問題 行と列の大きさがそれぞれ$N$の非負整数数表$A$がある。 表の$i$行$j$列目の成分を$A _ {i, j}$と表記する。 ここで、$A$は次の条件を満たす。 $A _ {i, i} = 0$ $i \\neq j$のとき、$1 \\leq A _ {i, j} = A _ {j, i} \\leq 10^9$ 次の条件を満たすネットワークが存在するか判定し、存在するなら辺の重みの和としてありうる最小値を求めよ。 存在しない場合は-1を出力せよ。 辺の重みは正整数。 $A _ {i, j}$は頂点$i$から$j$への最短経路長である。 制約 $1 \\leq N \\leq 300$ 考察 重要な性質として、次が成立します。 頂点$i$と頂点$j$を結ぶ辺は、存在するなら重み$A _ {i, j}$である。 これは次の理由によります。 重み$A _ {i, j}$より小さい辺が存在するとき、明らかに制約を満たさない。 重み$A _ {i, j}$より大きい辺が存在するとき、それを削除しても任意の最短経路に影響しない。 したがって、どの辺を採用するかを考えればよいです。 まず、重みが正整数であることから、辺の重みが$\\min (A)$であるものは必ず存在する必要があります。 そうでない場合、$\\min (A)$未満の経路が必ず生まれてしまうからです。 そのほかの辺に関しては、その時点で存在する辺だけを用いた時の全点対最短経路がわかれば、重み昇順に決めていくことができます。 例えば、$(u, v)$に辺が存在するかチェックしたいとき、その時点での最短経路長を返す関数を$\\mathrm{dist}$と表記すると、 $\\mathrm{dist}(u, v) = A _ {u, v}$であれば、辺は必要ない。 $\\mathrm{dist}(u, v) \u0026lt; A _ {u, v}$であれば、条件を満たすネットワークは存在しない。 $A _ {u, v} \u0026lt; \\mathrm{dist}(u, v)$であれば、辺は必要。 となります。 2番目の条件は少し非自明に感じますが、決定済みの辺割り当てが必要十分であることから従います。 さて、あとは各時点での全点対最短経路を求められればよいです。 新しく辺$(u, v)$を追加したとき、その辺を通る経路だけ考えればよいので、$0 \\leq x, y \u0026lt; N$に対して、 $$\r\\mathrm{dist}(x, y), \\mathrm{dist}(y, x) \\leftarrow \\min (\\mathrm{dist}(x, y), \\mathrm{dist}(x, u) + \\mathrm{dist}(u, v) + \\mathrm{dist}(v, y))\r$$\rという更新をすればよいです。\r以上より、辺の候補が$\\Theta (N^2)$個で、更新に$\\Theta (N^2)$回の手順が必要であるから、worst $\\Theta (N^4)$で解くことができます。 さらに、もう少し考察することで$\\Theta (N^3)$で解くこともできます。 上述の解法で、 そのほかの辺に関しては、その時点で存在する辺だけを用いた時の全点対最短経路がわかれば、重み昇順に決めていくことができる。 例えば、$(u, v)$に辺が存在するかチェックしたいとき、その時点での最短経路長を返す関数を$\\mathrm{dist}$と表記すると、 としていましたが、実は「その時点で存在する辺だけを用いたときの全点対最短経路」は逐次更新する必要はありません。 上記解法では「それまでの辺候補を全採用したときの、辺$(u, v)$を用いない$(u, v)$最短経路長」さえわかれば十分です。 以降の辺候補の重みがすべて$\\mathrm{dist}(u, v)$以上であることを考えると、それらの辺は存在しても存在しなくても$(u, v)$をとるかどうかの判定に必要な部分に影響しません。 以上より、最初に「辺候補をすべて採用したネットワークにおける全点対最短経路長」を求めておいて、 $(u, v)$の判定には$\\min _ {0 \\leq x \u0026lt; N} \\mathrm{dist}(u, x) + \\mathrm{dist}(x, v)$を用いればよいです。 こうすることで、前計算$\\Theta (N^3)$、判定$\\Theta (N)$になり、全体の計算量オーダー$\\Theta (N^3)$になります。 実装例 worst $\\Theta (N^4)$ import std; void main () { int N = readln.chomp.to!int; auto A = new int[][](N, 0); foreach (i; 0..N) A[i] = readln.split.to!(int[]); solve(N, A); } void solve (int N, int[][] A) { // 非負の辺しかないので、Aの最小の値に関しては確定できる。 // それ以外にも、重みの昇順に見ていくことを考えると、 // 1. 重み分の辺をはる // 2. すでに制約が満たされている // のどちらかしかありえない。なぜなら、重みより小さい辺を新しくはると別の場所で制約違反が必ず起きるし、より大きな辺をはるとどうやっても達成できないから。 // さらに、追加していく辺が重み昇順であることを考えると、タイプ1の時はチェックすらしなくてよい。 Tuple!(int, int, int)[] edges; foreach (i; 0..N) { foreach (j; i+1..N) { edges ~= tuple(i, j, A[i][j]); } } edges.sort!\u0026#34;a[2] \u0026lt; b[2]\u0026#34;; long ans = 0; auto dist = new long[][](N, N); foreach (d; dist) d[] = long.max; foreach (i; 0..N) dist[i][i] = 0; bool ok = true; foreach (e; edges) { if (dist[e[0]][e[1]] == e[2]) continue; if (dist[e[0]][e[1]] \u0026lt; e[2]) ok = false; if (e[2] \u0026lt; dist[e[0]][e[1]]) { ans += e[2]; // floyd-warshallっぽく更新 // 辺をセット dist[e[0]][e[1]] = dist[e[1]][e[0]] = e[2]; foreach (i; 0..N) foreach (j; 0..N) { if (dist[i][e[0]] \u0026lt; long.max \u0026amp;\u0026amp; dist[e[1]][j] \u0026lt; long.max) { dist[i][j] = dist[j][i] = min(dist[i][j], dist[i][e[0]] + dist[e[0]][e[1]] + dist[e[1]][j]); } } } } if (ok) { writeln(ans); } else { writeln(-1); } } 提出 $\\Theta (N^3)$ import std; void main () { int N = readln.chomp.to!int; auto A = new int[][](N, 0); foreach (i; 0..N) A[i] = readln.split.to!(int[]); solve(N, A); } void solve (int N, int[][] A) { // Θ(N^3)解法 Tuple!(int, int, int)[] edges; foreach (i; 0..N) { foreach (j; i+1..N) { edges ~= tuple(i, j, A[i][j]); } } edges.sort!\u0026#34;a[2] \u0026lt; b[2]\u0026#34;; long ans = 0; auto dist = new long[][](N, N); foreach (d; dist) d[] = long.max; foreach (i; 0..N) dist[i][i] = 0; foreach (e; edges) dist[e[0]][e[1]] = dist[e[1]][e[0]] = e[2]; foreach (k; 0..N) { foreach (i; 0..N) foreach (j; 0..N) { if (dist[i][k] == long.max || dist[k][j] == long.max) continue; dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } bool ok = true; foreach (e; edges) { long d = long.max; foreach (i; 0..N) { if (i == e[0] || i == e[1]) continue; d = min(d, dist[e[0]][i] + dist[i][e[1]]); } if (d == e[2]) continue; if (d \u0026lt; e[2]) ok = false; if (e[2] \u0026lt; d) { ans += e[2]; } } if (ok) { writeln(ans); } else { writeln(-1); } } 提出 終わりに この問題は私にとって非常に難しかったです。 最小重みの辺を確定させることができるのは最初に気が付きましたが、そこからが本当に長かった。 辺候補を昇順に見ていくことがツボで、こうすることであとから追加する辺の影響を考えなくてよくなるのですが、これに気が付くまでかなり時間を要しました。 逆に、これに気が付いてからは割と道筋が見えてきて、あとは採用した辺を用いた最短経路問題をどうにかできればよいというところまで来ました。 結局この点は解決できず、$O(N^4)$で解きました。 あとから解説を見て$\\Theta (N^3)$解法を理解しましたが、 「その時点での最短経路はそれまでの辺を全採用したことにしても変わらない」という点に気が付いていなかったなという感想です。 こういうad-hoc寄りな問題全般に言えることですが、 問題を考えるプロセスや、解決したときの喜びは大きいです。しかし、この問題がコンテストに出たらと思うとぞっとします。"
  },
  {
    url: "/post/two-pointer-approach/",
    title: "尺取り法備忘録",
    date: "2024-02-22T00:00:00+09:00",
    body: "尺取り法備忘録 尺取り法、してますか？ 条件を満たす列に対して 条件を満たす連続部分列の最大/最小長さ 条件を満たす連続部分列の数え上げ などを求めるアルゴリズムとして、尺取り法が知られています。 要求される条件は、大まかには以下のどちらかです。 ある区間$I$が条件を満たすならば、$\\forall i \\subseteq I$もまた条件を満たす。 ある区間$I$が条件を満たすならば、$\\forall i \\supseteq I$もまた条件を満たす。 けんちょんさんの記事 によると、これらの条件は次のようにも言い換えられます。 区間の最左のインデックスを$l$、条件を満たす区間の右のインデックス最大値を$f(l)$としたとき、$f(l)$は広義単調増加。 区間の最左のインデックスを$l$，条件を満たす区間の右のインデックス最小値を$f(l)$としたとき、$f(l)$は広義単調増加。 いきなり抽象的なことを言ってもしょうがないので、具体例を見ていきましょう。 例題 : AOJ DSL_3_C (The Number of Windows) 問題 長さ$N$の数列$a_1, a_2, a_3, \\dots , a_N$が与えられる。次の$Q$個の質問に答えよ。 整数$x_i$が与えられる。$1 \\leq l \\leq r \\leq N$かつ$\\sum_{i=l}^{r} \\leq x_i$を満たす$(l, r)$の組の個数を求めよ。 制約 $1 \\leq N \\leq 10^5$ $1 \\leq Q \\leq 500$ $1 \\leq a_i \\leq 10^9$ $1 \\leq x_i \\leq 10^{14}$ $1 \\leq a_i$であるため、$\\sum_{i=l}^{r} a_i \\leq x_i$が成立するなら、これよりも狭い区間の和もまた$x_i$以下になります。 すなわち、尺取り法の条件を満たしています。 この問題は、ざっくり次のようなアルゴリズムで解くことができます。(わかりやすさのため、一部正確でないです) $l = 0, r = 0, \\mathrm{ans} = 0$とする。 総和が$x_i$を超えないギリギリまで$r$を右にずらしていく $\\mathrm{ans}$に$r-l$を加算する $r$の位置はそのままにして、$l$を一つ右にずらす 手順2に戻る このアルゴリズムは、すべての始点に対してギリギリ和が$x_i$を超えない右端を求めていると捉えることができます。 ここで大事なのは手順4です。尺取り法の条件は、つまるところ手順4をして良いかどうか？ということになります。 なぜ手順4をしてよいかと言うと、手順3が終わった時点での$\\sum_{i=l}^{r} a_i$が$x_i$を超えないため、当然それよりも狭い範囲を指す$[l+1, r]$の総和も$x_i$を超えないからです。 この工夫を行うことによって、$l, r$ともに$O(N)$回の移動でアルゴリズムが終了し、全体$O(N)$になります。 さて、ここまでは概要をざっくり説明してきました。 ここからは実装の詳細を説明します。 まず、区間を$l, r$を用いて表すわけですが、これは右半開区間$[l, r)$を用いましょう。 これは空である区間を自然に表現できるからです。両端閉区間だと面倒になります。 具体例を挙げます。上の問題で、$a = (1, 5, 10)$かつ$x_1 = 7$だったとします。 このとき、条件を満たす連続部分列は次のようになります。(0-indexed) $(0)$, $(0, 1)$, $(1)$ このように、左端が$2$になるような連続部分列で条件を満たすようなものは存在しません。すなわち空な区間が出てきてしまいます。 これは右半開区間なら$[2, 2)$と表現できますが、閉区間だときれいに表現できなくなり、場合分けが増えます。 さて、実装しましょう。以下の実装では次のようなものが上の方にあると仮定してください。 using namespace std; using ll = long long; int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; vector\u0026lt;int\u0026gt; A(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; まずは左端に関するループですから、それを作ります。 それと、現在の総和を保持する変数が必要です。 // クエリ入力 ll x; cin \u0026gt;\u0026gt; x; int l = 0, r = 0; ll sum = 0; while (l \u0026lt; N) { l++; } forでもいいですが、個人的にはwhile推しです。 初期状態で$[0, 0)$の空区間を示していることに注意してください。 このとき総和が$0$なので、整合性が取れています。 限界まで右に伸ばします。 // クエリ入力 ll x; cin \u0026gt;\u0026gt; x; int l = 0, r = 0; ll sum = 0; while (l \u0026lt; N) { // 右に伸ばす while (r \u0026lt; N) { if (x \u0026lt; sum + A[r]) break; sum += A[r]; r++; } l++; } 右は開区間なので、A[r]はまだ含まれていない要素ということなります。これを足してもxを超えなければ足し、超えるならbreakします。 また、そもそもrは上限があるので、それもwhileの条件に入れています。 答えを加算します。 // クエリ入力 ll x; cin \u0026gt;\u0026gt; x; int l = 0, r = 0; ll sum = 0; while (l \u0026lt; N) { // 右に伸ばす while (r \u0026lt; N) { if (x \u0026lt; sum + A[r]) break; sum += A[r]; r++; } // 答えを加算 ans += r - l; l++; } 区間の左側が$l$であるとき、右側として$[l, r)$のどこからとっても条件を満たします。なので、r - lを足します。 左側を進めます。 // クエリ入力 ll x; cin \u0026gt;\u0026gt; x; int l = 0, r = 0; ll sum = 0; while (l \u0026lt; N) { // 右に伸ばす while (r \u0026lt; N) { if (x \u0026lt; sum + A[r]) break; sum += A[r]; r++; } // 答えを加算 ans += r - l; // 次から含まれなくなる要素を削る if (l \u0026lt; r) sum -= A[l]; l++; } 左端を進めるということは、一番左の要素を含めなくするということです。 ただし、限界まで$r$を伸ばしても$[l, r)$が空であるときにこれをすると不正なので、if (l \u0026lt; r)を入れています。 最後のステップです。 最初、$l \\leq r$を仮定していましたが、$l$を右に進めるステップのせいで$r \u0026lt; l$になる可能性があります。 具体的には、$r$を伸ばした結果$[l, r)$が空($l = r$)であるとき、その次のステップで$r \u0026lt; l$になります。 これは都合が悪いため、最初に正規化を入れます。 忘れやすいので注意が必要です。 // クエリ入力 ll x; cin \u0026gt;\u0026gt; x; int l = 0, r = 0; ll sum = 0; while (l \u0026lt; N) { // rの正規化 if (r \u0026lt; l) r = l; // 右に伸ばす while (r \u0026lt; N) { if (x \u0026lt; sum + A[r]) break; sum += A[r]; r++; } // 答えを加算 ans += r - l; // 次から含まれなくなる要素を削る if (l \u0026lt; r) sum -= A[l]; l++; } これで完成です。お疲れ様でした。 提出 例題2 : ABC38C - 単調増加 問題 長さ$N$の数列$a_1, a_2, \\dots, a_N$が与えられる。 $a_l, a_{l+1}, \\dots, a_r$が狭義単調増加となるような$(l, r)$の数を求めよ。 制約 $1 \\leq N \\leq 10^5$ $1 \\leq a_i \\leq 10^5$ こちらのほうが色々と条件がゆるいです。 まず、長さ1の列は狭義単調増加なので、空列について考えなくてよくなります。 さらに、「総和」のようなものがないので、左端を進める際に気にすることが無いです。 よって、次のような尺取りができます。 import std; void main () { int N = readln.chomp.to!int; auto a = readln.split.to!(int[]); long ans = 0; int l = 0, r = 0; while (l \u0026lt; N) { // 空列はありえないので、なくても大丈夫 if (r \u0026lt; l) r = l; while (r \u0026lt; N) { // l == rのときはとりあえず一つ右に進める if (l \u0026lt; r \u0026amp;\u0026amp; a[r] \u0026lt;= a[r-1]) break; r++; } ans += r - l; // 左端を進める際にやることは無い l++; } writeln(ans); } 提出 例題3 : ABC32C - 列 問題 長さ$N$の非負数列$S = (s_1, s_2, \\dots, s_N)$と整数$K$が与えられる。次の条件を満たす空でない$S$の連続部分列の長さの最大値を求めよ。 条件を満たす連続部分列が存在しないときは$0$を出力せよ。 条件: 連続部分列の要素の総積が$K$以下 制約 $1 \\leq N \\leq 10^5$ $0 \\leq K \\leq 10^9$ $0 \\leq s_i \\leq 10^9$ $S$に$0$が含まれているとき、$S$の総積は$0$になり、どんな$K$に対しても条件を満たします。 最初にそれを判定してしまいましょう。 $0$が含まれないとき、連続部分列が右に伸びるほど総積は増えるので、尺取りの条件を満たします。 空な区間/左側の処理どちらもありえるので、丁寧に処理しましょう。 import std; void main () { int N, K; readln.read(N, K); auto S = new int[](N); foreach (i; 0..N) S[i] = readln.chomp.to!int; solve(N, K, S); } void solve (int N, int K, int[] S) { // 0を含むか？ foreach (s; S) { if (s == 0) { writeln(N); return; } } // 右半開区間 int ans = 0; long v = 1; int l = 0, r = 0; while (l \u0026lt; N) { // 区間がおかしい場合は空な区間で初期化 if (r \u0026lt; l) r = l; // 可能な限り右を伸ばす while (r \u0026lt; N) { if (K \u0026lt; v * S[r]) break; v *= S[r]; r++; } ans = max(ans, r - l); // 逆操作が必要ならして、左を一つ進める if (l \u0026lt; r) v /= S[l]; l++; } writeln(ans); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 提出 終わりに 右半開区間のありがたみを初めて感じたかもしれない\u0026hellip; よくわからなくて苦手だったアルゴリズムだったけれど、意外と便利に感じました。 皆様もぜひどうぞ。"
  },
  {
    url: "/post/geometric-progression-sum/",
    title: "等比数列の和を計算する2つの対数時間アルゴリズム",
    date: "2024-02-15T00:00:00+09:00",
    body: "等比数列の和を計算する2つの対数時間アルゴリズム 概要 隣り合う2つの項の比が一定である数列を、等比数列という。 より厳密には、初項$a$、公比$r$によって定まる次の数列のことを指す。 $a_1 = a$ $a_i = ra_{i-1} ~ (2 \\leq i)$ 本稿では、等比数列の最初の$n$項の和$S_n = a + ar + ar^2 + \\dots ar^{n-1}$を任意の法$M$で割った非負最小剰余を$O(\\log n)$時間で求めるアルゴリズムを紹介する。 以下のアルゴリズムでは、$a, r$を64bit整数型で、$M$を32bit整数型で表現できる事を仮定する。 この仮定を満たさない入力値に対して、計算量が悪化する可能性がある。 また、文章中において「$S_n$」と「$S_n$を$M$で割った非負最小剰余」を区別せず記述する場所がある。 アルゴリズム1(閉じた式による表示) 有名なテクニックを用いて、$S_n$を閉じた式で表す。 $S_n$と$r S_n$の差を考えると、 $$ \\begin{equation} \\begin{aligned} rS_n \u0026amp;=\u0026amp; \u0026amp;ar + ar^2 + \\dots + ar^{n-1} + ar^n \\\\ S_n \u0026amp;=\u0026amp; a + \u0026amp;ar + ar^2 + \\dots + ar^{n-1} \\\\ \\end{aligned} \\end{equation} $$ であるから、$S_n (r-1) = a(r^n - 1)$が成立する。 $r \\neq 1$ 両辺を$r-1$で割ることができて、 $$ \\begin{equation} S_n = \\frac{a(r^n - 1)}{r-1} \\end{equation} $$ が成立する。法を$M$としたとき、$\\gcd(M, r-1) = 1$であれば法$M$における$r-1$の逆元が存在し、 $S_n = a(r^n - 1) (r-1)^{-1}$となる。 $\\gcd(M, r-1) \\neq 1$であるときも このエントリ で触れた通り、 法$M(r-1)$において$r^n - 1$計算し、それを$r-1$で割ることで法$M$における$\\frac{r^n-1}{r-1}$の値を得ることができる。 最後に$a$を乗算することで$S_n$が求まる。 以上より、$S_n$を$O(\\log n)$時間で計算可能である。 $r = 1$ $\\forall i \\in \\mathbb{N}$に対して、$a_i = a_1$が成立する。 したがって、$S_n = na_1$であり、これは$O(1)$で計算可能である。 上記の方法により、$S_n$を$O(\\log n)$で計算することができる。。 アルゴリズム2(繰り返し2倍法) 「繰り返し2倍法」という名前は ここ で言及されているものであり、一般的でない可能性に留意してほしい。 このエントリ で触れたように、任意の自然数$n$は$\\{0, 1\\}$のみからなる数列($c$と書くことにする)による表示を一意に持つ。 つまり、次が成立するような数列$c$が存在して、かつそれは一意である。 $$ \\begin{equation} n = \\sum_{i=0} 2^i c_i \\end{equation} $$ これは2進数そのものである。例えば、$1$は$(1, 0, 0, \\dots)$で表現され、$2$は$(0, 1, 0, \\dots)$、$10$は$(0, 1, 0, 1, 0, \\dots)$である。 平素な言葉で言い換えるなら、「任意の自然数は$2$の冪の和によって一意に表すことができる。」となる。これを利用する。 $n$を2進表示した列$c$を用いて、$S_n$を次のように表すことができる。 $$\r\\begin{equation}\rS_n = \\sum_{i=0} c_i r^{\\sum\\limits_{j=0}^{i-1} c_j 2^j} S_{2^i}\r\\end{equation}\r$$\r(式が非常に複雑なので、フォントサイズを1.5倍にしている。) 式4は一見複雑に見えるが、$S_{2^i}$のいくつかの和によって長さの帳尻を合わせ、かつ適切な位置まで$r^{\\sum_{j=0}^{i-1} c_j 2^j}$を乗算することでずらしていると考えれば理解しやすいかもしれない。 例えば、$n = 10$において次のようになる。 $$ \\begin{equation} \\begin{split} S_{10} \u0026amp;= r^{0 \\times 2^0} S_{2^1} + r^{0 \\times 2^0 + 1 \\times 2^1 + 0 \\times 2^2} S_{2^3} \\\\ \u0026amp;= r^0 S_2 + r^2 S_8 \\\\ \u0026amp;= (a + ar) + r^2 (a + ar + ar^2 + \\dots + ar^7) \\\\ \u0026amp;= a + ar + ar^2 + ar^3 + \\dots + ar^9 \\end{split} \\end{equation} $$ さて、$S_{2x} = S_x + r^x S_x$と$r^{2x} = r^x r^x$が成立することを利用すると、 $(r^1, S_1), (r^2, S_2), (r^4, S_4), \\dots , (r^{2^x}, S_{2^x})$ を時間$O(x)$、空間$O(1)$で順番に列挙することができる。 式4の計算には$(r^{2^{\\lfloor \\log n \\rfloor}}, S_{2^{\\lfloor \\log n \\rfloor}})$まで分かれば十分であるため、$S_n$を$O(\\log n)$時間で計算可能である。 実装 D言語による実装を以下に示す。 なお、$a$と$r$を最初に正規化しているが、これは次の理由により正しい値を返す。 正規化後の値を$a^\\prime$と$r^\\prime$とするとき、 「初項$a$、公比$r$の等比数列の先頭$n$項の和を$M$で割った非負最小剰余」と「初項$a^\\prime$、公比$r^\\prime$の等比数列の先頭$n$項の和を$M$で割った非負最小剰余」が一致する。 ナイーブな実装とのランダムテストを含めた完全なソースは gist を参照せよ。 アルゴリズム1 long geometric_progression_sum_algorithm1 (long a, long r, long n, const long MOD) in { assert(0 \u0026lt;= n); assert(1 \u0026lt;= MOD); } do { import std.BigInt; // 正規化 a %= MOD; r %= MOD; if (a \u0026lt; 0) a += MOD; if (r \u0026lt; 0) r += MOD; // 場合分け if (r == 1) return a * (n % MOD) % MOD; // 計算 const BigInt M = BigInt(r-1) * BigInt(MOD); const BigInt N = BigInt(n); const BigInt R = BigInt(r); BigInt S = powmod(R, N, M) - 1; if (S \u0026lt; 0) S += M; S /= r-1; S *= a; return S % MOD; } アルゴリズム2 long geometric_progression_sum_algorithm2 (long a, long r, long n, const long MOD) in { assert(0 \u0026lt;= n); assert(1 \u0026lt;= MOD \u0026amp;\u0026amp; MOD \u0026lt;= int.max); } do { // 正規化 a %= MOD; r %= MOD; if (a \u0026lt; 0) a += MOD; if (r \u0026lt; 0) r += MOD; // 計算 long S = a; long R = r; long R_prod = 1; long res = 0; foreach (i; 0..64) { if (n \u0026lt; (1L\u0026lt;\u0026lt;i)) break; if ( 0 \u0026lt; (n \u0026amp; (1L\u0026lt;\u0026lt;i)) ) { res += R_prod * S % MOD; res %= MOD; R_prod *= R; R_prod %= MOD; } S += R * S % MOD; S %= MOD; R *= R; R %= MOD; } return res; } 終わりに 等差数列の和が非常に簡単な形で表されるのに対して、等比数列の和は工夫が必要なのが面白いと思った。 具体的に値を求めようとしたとき、閉じた式による計算が必ずしも最速ではないということが非自明に感じる。 また、実装していて、割ったあまりを人力で管理するのはなかなか厳しいものがあると感じた。 今まで必要性を感じていなかったが、ModPow構造体を用意するモチベーションになった気がする。"
  },
  {
    url: "/post/debian-install/",
    title: "Ubuntuが死んだのでDebianをインストールする",
    date: "2024-02-13T00:00:00+09:00",
    body: "Ubuntuが死んだのでDebianをインストールする はじめに 2023年の2月あたりからおよそ1年間にわたりUbuntu22.04.3LTSを使用してきた。 ここ一週間ほど、急にネットワーク接続がおかしくなったり、システムの電源を切ることすらままならなくなる事態が発生してしまった。 いくつか解決策を調べてみたり、応急手当として手元にあったUSBのwifiアダプターをさして(何故かこちらを経由するとうまく接続できる場合があったのである。しかし、特定のネットワークにはつながらないので意味不明であった。)みたりした。 しかし、私の知識と熱意では到底解決できそうにないし、そもそも私がコストをかけるべきはこんなところではないだろうと思い始めてきたところで、OSの入れ替えを決行することにした。 Debianを使ってみる 2023年6月10日にリリースされたという Debian12 bookworm を試してみることにした。 主な理由は、 Ubuntuに近い操作感であるだろうと思ったから。 違うディストリビューションを使ってみたかったから。 といったところだろうか。 インストール備忘録 また何かしらでトラブって、インストール作業が発生するかもしれないので、備忘録を残しておく。 インストールメディア作成 + インストール まずは適当にインストールメディアを作成する。イメージファイルを このリンク から落としてきて、手元のwin機にて Rufus で焼いた。 落としてくるイメージは各自PCのCPUアーキテクチャに依存する。 私はamdのcpuを使用しているので、amd64を落としてきた。 さて、インストールはUSBをさしてBIOSなりUEFIなりで起動順序変更をしてやればよい。細かいことはググってほしい。 Debianは比較的親切にインストール案内を出してくれる。guiインストールを選べばあとはポチポチしていたらインストールが終わる。 公式も インストールガイド を出しているので、困ったら見るとよいだろう。 sudoをなんかいい感じにする デフォルト状態だとなんかエラーが出てsudoさせてくれない。 これ が参考になる。 一回super userとしてsudoの設定をしてやれば良いらしい。 タスクバー的なものをセット GNOMEデフォルトだと「アクティビティ」からしかタスクバー的なものを使えない。windowsに飼い慣らされた我々は、画面の左か下にタスクバーがないと死んでしまうのだ。 解決は このページ が参考になった。 sudo apt install gnome-shell-extension-dashtodock で拡張機能をインストールして、一回ログアウトする。 再びログインしたら「拡張機能」アプリにdashtodockが追加されているから、有効化する。 設定はこんな感じ。 これで画面左側にタスクバーが出現する。ありがてえ。 各種ソフトウェアのインストール+設定 apt install hogeで普通に入るやつをインストールしていく いつものやつ sudo apt install gcc sudo apt install g++ sudo apt install git sudo apt install curl sudo apt install vim sudo apt install texlive-full 余談だが、Debianにプリインストールされているvimはなぜかnetrwが使えなかったし、vimのはずなのに「vim」へのシンボリックリンクすらなくて、「vi」でしか起動できなかった。あれはもしかしてviだったのだろうか。 texlive-fullは全部で7GBほどの容量を食う。そんなことしたくないという人は このあたり が参考になるかもしれない。 まずはgitの設定からしよう。 gitの設定は難しくてよくわからないので、 このページ や このページ を見ながらできそうなやつをポチポチしていく。 git config --global user.name \u0026#34;InTheBloom\u0026#34; git config --global user.email \u0026#34;hoge.fuga@example.com\u0026#34; git config --global core.quotePath false あとはgithubに接続する設定(?)みたいなのをやっていく。このあたり本当に勉強したほうがいい気がするが、わけわからない単語を並べられてもしんどいというのが本音である。 これ に沿ってやっていく。 inthebloom@debian:~$ ssh-keygen -t ed25519 -C \u0026#34;hoge.fuga@example.com\u0026#34; inthebloom@debian:~$ cat ~/.ssh/id_ed25519.pub | clip # githubの方でssh鍵の登録設定をする inthebloom@debian:~$ ssh -T git@github.com Hi InTheBloom! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. inthebloom@debian:~$ なんか動いた(最悪) 次にvimの設定をする。 自分のvimの設定が ここ にあるので、これをセットアップする。 詳細はREADME.mdに書いてある。 次にAtCoder Libraryとboost Libraryをローカルで動かせるようにする。 まずAtCoder Libraryをcloneする。 git clone git@github.com:atcoder/ac-library.git ACLは事前ビルドが不要(ヘッダオンリー)のため、単にコンパイラの参照パスに追加すればよい。 私の場合、競技プログラミング以外でg++を使用することはほぼないため、常時参照しても問題にならない。そのため、aliasとして登録しておくと楽になる。 alias g++=\u0026#39;g++ -I/home/inthebloom/cp/lib/ac-library\u0026#39; あとはboostを導入していく。 このページ に従ってやっていく。 まずは現在の最新バージョンを落としてくる。最新バージョンへのリンクは上のリンクにある。 boostディレクトリを解凍し、 ./bootstrap.sh ./b2 install -j8 --prefix=/home/inthebloom/libboost/ を実行し、boostをビルドする。 実は私が利用するような機能群は事前ビルドが必要ないものが多い(boost/multiprecision/cpp_intなど)が、全部使えると嬉しいのでビルドする。 もしヘッダオンリーだけでいい場合、 ./b2 headers でいいらしい。 あとはACLと同じように参照パスを追加しておく。 alias g++=\u0026#39;g++ -I/home/inthebloom/cp/lib/ac-library/ -I/home/inthebloom/libboost/include/\u0026#39; DMD(D言語処理系) 私が普段使ってるD言語処理系は、aptならldcをインストールできる。 ただし、公式実装のDegital Mars Dがいいという人(私)は、公式の.debファイルかインストールスクリプトを利用すると楽だと思う。 ダウンロードページ curl -fsS https://dlang.org/install.sh | bash -s dmd activateが必要なので、~/.bashrcに次を追記して、常時activatedにしておく。 行儀悪い方法かもしれないが、別にマナー講師になりたいわけではないので気にしないことにする。 # dmd activation _OLD_D_PATH=\u0026#34;${PATH:-}\u0026#34; _OLD_D_LIBRARY_PATH=\u0026#34;${LIBRARY_PATH:-}\u0026#34; _OLD_D_LD_LIBRARY_PATH=\u0026#34;${LD_LIBRARY_PATH:-}\u0026#34; export LIBRARY_PATH=\u0026#34;/home/inthebloom/dlang/dmd-2.107.0/linux/lib64${LIBRARY_PATH:+:}${LIBRARY_PATH:-}\u0026#34; export LD_LIBRARY_PATH=\u0026#34;/home/inthebloom/dlang/dmd-2.107.0/linux/lib64${LD_LIBRARY_PATH:+:}${LD_LIBRARY_PATH:-}\u0026#34; _OLD_D_PATH=\u0026#34;${PATH:-}\u0026#34; _OLD_D_PS1=\u0026#34;${PS1:-}\u0026#34; export PATH=\u0026#34;/home/inthebloom/dlang/dmd-2.107.0/linux/bin64${PATH:+:}${PATH:-}\u0026#34; export DMD=dmd export DC=dmd これは~/dlang/dmd-[version]/activateの下の方にある内容をコピってきたものなので、これをそのまま使っても動かない。(だってユーザー名とかガッツリ含まれてるし..) 私は競技プログラミングにおいて、c++と似た動作にするためにコンパイル結果をわざとa.outにするようにしている。 これはaliasを設定してやれば良い。 alias dmd=\u0026#39;dmd -of=\u0026#34;a.out\u0026#34;\u0026#39; その他のソフト vscode hugo zoom slack このあたりはdebian向けパッケージファイルhoge.debを公開してくれているので、それをパクってきて sudo apt install hoge.deb としておけばインストールできる。 私はいくつかの事情でvscodeをターミナルエミュレーターとして使用しているので、そのあたりの設定をしていく。 まず、ターミナルエミュレータにショートカットキーはいらないので、全部消す。ちょうどいい拡張機能があるので、これをインストールする。 ただし、この拡張機能はあまりに強力で、なんとbackspaceすら無効化されてしまう。 そのため、別途有効にしたいキーバインディングは~/.config/Code/User/keybindings.jsonに追記することにした。 デフォルト設定は ここ にあるため、これを改良して使う。 フォントは Inconsolata を使う。 Google Fonts からダウンロードしてきて、~/.fonts/にttfを配置すると、現在のユーザーで読み込まれる。( 参考 ) あとは、設定を開いて、 Terminal \u0026gt; Integrated: Default Locationをeditor Terminal \u0026gt; Integrated: Font Familyを'Inconsolata' Terminal \u0026gt; Integrated: Font Sizeを17 に変更した。 ついでに背景透明化も行う。GlassIt-VSCをインストールすると、普通に透ける。 地味な設定 地味にないと困る設定をしていく。 まず、firefoxの二本指スワイプで進む/戻るを実現する設定をする。 このページ を参考にした。 アドレスバーにabout:configを入力し、 mousewheel.default.override_xを2 mousewheel.default.delta_multiplier_xを-5 に設定する。これでスワイプ操作で進む/戻るを実現できる。 次に、コマンドラインコピーペーストを実現する。 このページ を参考にした。 まず、xselというツールをインストールする。 sudo apt install xsel ~/.bashrcに以下を追記 alias pbcopy=\u0026#39;xsel --clipboard --input\u0026#39; alias pbpaste=\u0026#39;xsel --clipboard --output\u0026#39; alias clip=$pbcopy これでcat file | clipや、pbpaste \u0026gt; fileができる。 OSレベルのキーバインディング関連 このあたりは自分も何やってるのかよくわかっていないことは許してほしい。とりあえず動く方法だけ紹介する。 私の普段のキーバインディングはCapsLockをctrlにし、hankaku/zenkakuをEscにした上でmuhenkanをIMEオン、henkanをIMEオフに割り当てるというものである。これを実現する。 とりあえずTweaksという神アプリがプリインストールされているので、これを起動する。Ubuntuにも入ってるはず。 追加のレイアウトオプションを選択 Caps Lock behaviorと日本語キーボードオプションをいじる。 前者はMake Caps Lock an additional Ctrlに、後者はMake Zenkaku Hankaku an additional Escにする。 これで割当変更ができる。仕組みはわからない。開発者ℒ𝒪𝒱ℰ\u0026hellip; 次にIMEの設定をしよう。DebianではIMEとしてMozcというソフトウェアが使われているらしい。 Mozc以外の話はわからないし、Mozcが何なのかもわかってないことは許してほしい。 まず、「アクティビティ」からMozcの設定という謎アプリを開く。 そしたら、「キー設定」の「キー設定の選択」を選んで、ここをいじっていく。 私の設定をエクスポートしたやつ\r```\rstatus\tkey\tcommand\rPrecomposition\tBackspace\tRevert\rComposition\tBackspace\tBackspace\rConversion\tBackspace\tCancel\rConversion\tCtrl a\tSegmentFocusFirst\rComposition\tCtrl a\tMoveCursorToBeginning\rComposition\tCtrl Backspace\tBackspace\rPrecomposition\tCtrl Backspace\tUndo\rConversion\tCtrl Backspace\tCancel\rConversion\tCtrl d\tSegmentFocusRight\rComposition\tCtrl d\tMoveCursorRight\rPrediction\tCtrl Delete\tDeleteSelectedCandidate\rConversion\tCtrl Down\tCommitOnlyFirstSegment\rComposition\tCtrl Down\tMoveCursorToEnd\rConversion\tCtrl e\tConvertPrev\rComposition\tCtrl e\tMoveCursorToBeginning\rComposition\tCtrl Enter\tCommit\rConversion\tCtrl Enter\tCommit\rConversion\tCtrl f\tSegmentFocusLast\rComposition\tCtrl f\tMoveCursorToEnd\rComposition\tCtrl g\tDelete\rConversion\tCtrl g\tCancel\rComposition\tCtrl h\tBackspace\rConversion\tCtrl h\tCancel\rComposition\tCtrl i\tConvertToFullKatakana\rConversion\tCtrl i\tConvertToFullKatakana\rConversion\tCtrl k\tSegmentWidthShrink\rComposition\tCtrl k\tMoveCursorLeft\rConversion\tCtrl l\tSegmentWidthExpand\rComposition\tCtrl l\tMoveCursorRight\rConversion\tCtrl Left\tSegmentFocusFirst\rComposition\tCtrl Left\tMoveCursorToBeginning\rComposition\tCtrl m\tCommit\rConversion\tCtrl m\tCommit\rConversion\tCtrl n\tCommitOnlyFirstSegment\rComposition\tCtrl n\tMoveCursorToEnd\rComposition\tCtrl o\tConvertToHalfWidth\rConversion\tCtrl o\tConvertToHalfWidth\rComposition\tCtrl p\tConvertToFullAlphanumeric\rConversion\tCtrl p\tConvertToFullAlphanumeric\rConversion\tCtrl Right\tSegmentFocusLast\rComposition\tCtrl Right\tMoveCursorToEnd\rConversion\tCtrl s\tSegmentFocusLeft\rComposition\tCtrl s\tMoveCursorLeft\rComposition\tCtrl Shift Space\tInsertFullSpace\rConversion\tCtrl Shift Space\tInsertFullSpace\rPrecomposition\tCtrl Shift Space\tInsertFullSpace\rComposition\tCtrl Space\tInsertHalfSpace\rConversion\tCtrl Space\tInsertHalfSpace\rComposition\tCtrl t\tConvertToHalfAlphanumeric\rConversion\tCtrl t\tConvertToHalfAlphanumeric\rComposition\tCtrl u\tConvertToHiragana\rConversion\tCtrl u\tConvertToHiragana\rConversion\tCtrl Up\tConvertPrev\rComposition\tCtrl Up\tMoveCursorToBeginning\rConversion\tCtrl x\tConvertNext\rComposition\tCtrl x\tMoveCursorToEnd\rComposition\tCtrl z\tCancel\rConversion\tCtrl z\tCancel\rComposition\tDelete\tDelete\rConversion\tDelete\tCancel\rSuggestion\tDown\tPredictAndConvert\rConversion\tDown\tConvertNext\rComposition\tDown\tMoveCursorToEnd\rComposition\tEisu\tToggleAlphanumericMode\rConversion\tEisu\tToggleAlphanumericMode\rPrecomposition\tEisu\tToggleAlphanumericMode\rDirectInput\tEisu\tIMEOn\rConversion\tEnd\tSegmentFocusLast\rComposition\tEnd\tMoveCursorToEnd\rComposition\tEnter\tCommit\rConversion\tEnter\tCommit\rComposition\tESC\tCancel\rConversion\tESC\tCancel\rComposition\tF10\tConvertToHalfAlphanumeric\rConversion\tF10\tConvertToHalfAlphanumeric\rDirectInput\tF13\tIMEOn\rComposition\tF2\tConvertWithoutHistory\rComposition\tF6\tConvertToHiragana\rConversion\tF6\tConvertToHiragana\rComposition\tF7\tConvertToFullKatakana\rConversion\tF7\tConvertToFullKatakana\rComposition\tF8\tConvertToHalfWidth\rConversion\tF8\tConvertToHalfWidth\rComposition\tF9\tConvertToFullAlphanumeric\rConversion\tF9\tConvertToFullAlphanumeric\rComposition\tHenkan\tIMEOff\rConversion\tHenkan\tIMEOff\rPrecomposition\tHenkan\tIMEOff\rConversion\tHome\tSegmentFocusFirst\rComposition\tHome\tMoveCursorToBeginning\rConversion\tLeft\tSegmentFocusLeft\rComposition\tLeft\tMoveCursorLeft\rPrecomposition\tMuhenkan\tInputModeSwitchKanaType\rComposition\tMuhenkan\tSwitchKanaType\rConversion\tMuhenkan\tSwitchKanaType\rDirectInput\tMuhenkan\tIMEOn\rPrecomposition\tMuhenkan\tIMEOn\rConversion\tPageDown\tConvertNextPage\rConversion\tPageUp\tConvertPrevPage\rConversion\tRight\tSegmentFocusRight\rComposition\tRight\tMoveCursorRight\rComposition\tShift Backspace\tBackspace\rConversion\tShift Backspace\tCancel\rConversion\tShift Down\tConvertNextPage\rSuggestion\tShift Enter\tCommitFirstSuggestion\rComposition\tShift ESC\tCancel\rConversion\tShift ESC\tCancel\rConversion\tShift Henkan\tConvertPrev\rConversion\tShift Left\tSegmentWidthShrink\rComposition\tShift Left\tMoveCursorLeft\rComposition\tShift Muhenkan\tConvertToFullAlphanumeric\rConversion\tShift Muhenkan\tConvertToFullAlphanumeric\rPrecomposition\tShift Muhenkan\tToggleAlphanumericMode\rConversion\tShift Right\tSegmentWidthExpand\rComposition\tShift Right\tMoveCursorRight\rComposition\tShift Space\tConvert\rPrecomposition\tShift Space\tInsertAlternateSpace\rConversion\tShift Space\tConvertPrev\rConversion\tShift Tab\tConvertPrev\rConversion\tShift Up\tConvertPrevPage\rComposition\tSpace\tConvert\rConversion\tSpace\tConvertNext\rPrecomposition\tSpace\tInsertSpace\rComposition\tTab\tPredictAndConvert\rConversion\tTab\tPredictAndConvert\rConversion\tUp\tConvertPrev\rConversion\tVirtualEnter\tCommitOnlyFirstSegment\rComposition\tVirtualEnter\tCommit\rConversion\tVirtualLeft\tSegmentWidthShrink\rComposition\tVirtualLeft\tMoveCursorLeft\rConversion\tVirtualRight\tSegmentWidthExpand\rComposition\tVirtualRight\tMoveCursorRight\rComposition\tASCII\tInsertCharacter\rComposition\tKanji\tIMEOff\rComposition\tOFF\tIMEOff\rComposition\tON\tIMEOn\rConversion\tKanji\tIMEOff\rConversion\tOFF\tIMEOff\rConversion\tON\tIMEOn\rDirectInput\tKanji\tIMEOn\rDirectInput\tON\tIMEOn\rPrecomposition\tASCII\tInsertCharacter\rPrecomposition\tKanji\tIMEOff\rPrecomposition\tOFF\tIMEOff\rPrecomposition\tON\tIMEOn\r```\r多分これをコピーしてインポートすることができるので、よかったら使ってね。\rwifiアダプタ有効化 手元にusbのwifiアダプタがあるので、一応動かせるようにしておく。 lsusbコマンドによると、アダプタはTP-Link AC600 wireless Realtek RTL8811AU [Archer T2U Nano]らしい。 単にさしただけだと反応しないので、何らかの処置が必要らしい。 いくつかググると、 このページ がヒットした。 まず、必要なツールをインストールする。 sudo apt install dkms sudo apt install build-essential sudo apt install linux-headers-6.1.0-17-amd64 ドライバのリポジトリを引っ張ってきて、makeする。 git clone git@github.com:aircrack-ng/rt18812au.git cd rt18812au sudo make dkms_install 何故か「すでにインストールされています」的なことを言われる。 でもまだアダプタが認識しないので、一回アンインストールを試みる。 sudo make dkms_remove sudo make dkms_install これで急に認識されるようになった。 NetWorkManagerのclクライアントnmcliで簡単に確認できる。 nmcli device show 終わりに これで必要なセットアップは大体できた。 もっと細かいこともあるが、あとはケースバイケースなものが多いと思う。 このエントリが初心者linuxユーザーの役に立つことを願う。"
  },
  {
    url: "/post/yukicoder2616/",
    title: "No.2616 中央番目の中央値",
    date: "2024-01-27T00:00:00+09:00",
    body: "No.2616 中央番目の中央値 問題概要 問題へのリンク 長さ$N$の順列$P = (P_1, \\cdots , P_N)$が与えられる。$P$の部分列$p$であって、以下の条件をすべて満たすものの総数を$998244353$で割ったあまりを求めよ。 長さが奇数 $p$の中央値が、$p$のちょうど中央に位置する 制約 $1 \\leq N \\leq 3 \\times 10^5$ $(P_1, \\cdots , P_N)$は$(1, 2, \\cdots , N)$を並べ替えた順列 考察 まず中央値としてどこをとるかを固定して問題を考察する。 中央値として$P_i$をとるとしたとき、 自分より左と自分より右から同量の項を採用する。 採用した項は半分が自分未満で、半分が自分超過である。 ということが題意を満たす$p$の必要条件十分になる。 例えば、自分の左右から自分超過と自分未満の項を$\\mathrm{more}_{左}, \\mathrm{less}_{左}, \\mathrm{more}_{右}, \\mathrm{less}_{右}$ 個とったとすると、前述の条件から次の連立方程式が立つ。 $$ \\begin{equation} \\left \\{ \\begin{split} \\mathrm{less}_{左} + \\mathrm{more}_{左} \u0026amp;= \\mathrm{less}_{右} + \\mathrm{more}_{右} \\\\ \\mathrm{less}_{左} + \\mathrm{less}_{右} \u0026amp;= \\mathrm{more}_{左} + \\mathrm{more}_{右} \\\\ \\end{split} \\right . \\end{equation} $$ これを解くと、$\\mathrm{more}_{左} = \\mathrm{less}_{右}, \\mathrm{less}_{左} = \\mathrm{more}_{右}$を得る。 結果としては当たり前のことを言っていて、「左側から大きい項をとってきたなら、右側で小さい項をとってきて帳尻を合わせなさいよ」ということである。 さて、よく見ると$\\mathrm{less}_{左}$と$\\mathrm{more}_{左}$は反対側で取る項により帳尻を合わせている。 すなわち、$\\mathrm{less}_{左}$と$\\mathrm{more}_{左}$自体は関係性がないため、独立に考えてよいことがわかる。 まず$\\mathrm{less}_{左}, \\mathrm{more}_{右}$の取り方によってできる部分列について考えよう。 まず、 $$\r0 \\leq \\mathrm{less}_{左}, \\mathrm{more}_{右} \\leq \\min((自分より左にあるP_i未満の数の数), (自分より右にあるP_i超過の数の数))\r$$\rであることがわかる。そうでないなら、帳尻を合わせられないからだ。\r$\\mathrm{less}_{左} = \\mathrm{more}_{右} = i$であるとき、 どこから取るかの自由度があるため、作れる部分列の個数は$X = (自分より左にあるP_i未満の数の数)$、$Y = (自分より右にあるP_i超過の数の数)$と定めると、 $\\binom{X}{i} \\binom{Y}{i}$通りになる。この総和を考えればよいため、 $$ \\sum_{i=0}^{\\min(X, Y)} \\binom{X}{i} \\binom{Y}{i} $$ 通りになる。 二項係数の性質$\\binom{N}{K} = \\binom{N}{N-K}$を用いると、 $$ \\sum_{i=0}^{\\min(X, Y)} \\binom{X}{X-i} \\binom{Y}{i} $$ $\\min(X, Y) = X$であるとき、 ヴァンデルモンドの畳み込み という恒等式が成立し、 $$ \\sum_{i=0}^{X} \\binom{X}{X-i} \\binom{Y}{i} = \\binom{X+Y}{X} $$ となる。$\\min(X, Y) = Y$であるときも全く同様にして $$ \\sum_{i=0}^{Y} \\binom{X}{i} \\binom{Y}{Y-i} = \\binom{X+Y}{Y} $$ が成立する。ただし、$\\binom{X+Y}{X} = \\binom{X+Y}{Y}$に注意せよ。 $\\mathrm{more}_{左}, \\mathrm{less}_{右}$にも全く同様の議論ができる。 これらの議論がそれぞれ独立であることを考えると、中央値$P_i$であるときのあり得る部分列の個数はこれらの積になる。 これらの二項係数は適切に前計算することでクエリ$O(1)$となり、$(自分より左にあるP_i未満の数の数)$といった数はSegmentTreeなどのデータ構造によりクエリ$O(\\log N)$で求まる。 具体的には、要素数$N$の一点更新/区間和取得のセグメントツリーを2本持っておいて、セグメントツリーの最下段の配列と$P$の各項を対応付けて管理する。 すなわち、「区間$[0, x)$に入っている$P_i$は1、そうでないなら0」という情報と、「区間$[x+1, N)$に入っている$P_i$は1、そうでないなら0」という情報を持っておいて、それぞれ適切に prod(0, P[i])やprod(P[i]+1, N)というクエリを飛ばすことで達成できる。 以上より、$O(N \\log N)$で解が求まる。 実装例 ICPCもあるので、練習にc++を使ってみた。 コンパイルが通るように全部貼り付けたが、solve関数の中だけ見ればよい。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;atcoder/segtree\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; using namespace std; using namespace atcoder; using ll = long long; ll ModPow (ll a, ll x, const ll MOD) { assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); a %= MOD; if (a \u0026lt; 0) a += MOD; ll res = 1; while (x != 0) { if (0 \u0026lt; (x \u0026amp; 1)) { res *= a; res %= MOD; } a *= a; a %= MOD; x \u0026gt;\u0026gt;= 1; } return res % MOD; } ll ModInv (ll x, const ll MOD) { assert(1 \u0026lt;= x); assert(2 \u0026lt;= MOD); return ModPow(x, MOD-2, MOD); } int ope (int a, int b) { return a + b; } int e () { return 0; } void solve (int N, vector\u0026lt;int\u0026gt; \u0026amp;P) { // ある要素を中央値に採用すると考える。 // 「前から見て(長さ-1)/2個からなる部分列でmaxがそれ未満」と「後ろから見て(長さ-1)/2個からなる部分列でminがそれ超過」の場合の数がわかればよい？ // -\u0026gt; 明らかにΘ(N^2)以上が見込まれるのでダメ // 右側から超過をk個、未満をl個とったと考える。この時、左側からとるべきものも確定して、未満をk個、超過をl個とる必要がある。 // 左側でとった超過/未満は右側でつじつまを合わせるため、独立に考えてよい。 // 例えば左側未満は[0, min((左側未満), (右側超過))]個自由にとれる。-\u0026gt;どこからとるかはnCkになり、これの積を足していけばいい // wolfram alpha先生にbinomial(N, i) * binomial(M, i)の和[0, N]を投げたら(M+N)!/(N!M!)って言われた // セグ木かなんかでこれを持っておけばよくないか？ const ll MOD = 998244353; vector\u0026lt;ll\u0026gt; fact(2*N+1), factinv(2*N+1); fact[0] = 1; for (int i = 1; i \u0026lt;= 2*N; i++) fact[i] = i*fact[i-1] % MOD; factinv[2*N] = ModInv(fact[2*N], MOD); for (int i = 2*N-1; 0 \u0026lt;= i; i--) factinv[i] = (i+1) * factinv[i+1] % MOD; segtree\u0026lt;int, ope, e\u0026gt; L(N), R(N); for (int i = 0; i \u0026lt; N; i++) R.set(i, 1); ll ans = 0; for (int i = 0; i \u0026lt; N; i++) { // 計算 int Llarge = L.prod(P[i]+1, N); int Lless = L.prod(0, P[i]); int Rlarge = R.prod(P[i]+1, N); int Rless = R.prod(0, P[i]); ll add = fact[Llarge + Rless] * factinv[Llarge] % MOD; add *= factinv[Rless]; add %= MOD; add *= fact[Rlarge + Lless]; add %= MOD; add *= factinv[Rlarge]; add %= MOD; add *= factinv[Lless]; add %= MOD; ans += add; ans %= MOD; // 更新 L.set(P[i], 1); R.set(P[i], 0); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main () { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; P(N); for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; P[i]; P[i]--; // 0-indexed } solve(N, P); } 感想 久しぶりにyukicoderで難しめの問題が解けた気がする。 本番はwolfram alphaに投げたら式変形してくれたが、本稿を書くにあたって二項係数が入った恒等式の証明が全然わからなくて苦労した。 ヴァンデルモンドの畳み込み恒等式は競技プログラミングにおいて様々な応用がありそうな気がするが、筆者のレベルだとあまり見たことがない。 不明点があれば 公式解説 が詳しい。"
  },
  {
    url: "/post/abc167e/",
    title: "ABC167E - Colorful Blocks",
    date: "2024-01-03T00:00:00+09:00",
    body: "ABC167E - Colorful Blocks 問題概要 問題へのリンク $N$個の横一列に並んだブロック列に色を塗る。 色は整数で表され、$1$から$M$までの$M$種類ある。 必ずしもすべての色を使う必要はない。 隣り合うブロックが同じ色である箇所が$K$以下の色の塗り方の総数を$998244353$で割ったあまりを求めよ。 制約 $1 \\leq N, M \\leq 2 \\times 10^5$ $0 \\leq K \\leq N-1$ 考察 dp解を考えてみよう。 $dp[i][j] = (iブロック目まで塗って、隣り合うブロックが同じ色である場所がj個であるような塗り方の総数)$\rとすれば、初期値\r$dp[1][0] = M$ 更新 $dp[i+1][j] = (M-1) * dp[i][j]$ $dp[i+1][j+1] = dp[i][j]$ とすることで、$O(NK)$で解くことができる。 import std; void main () { int N, M, K; readln.read(N, M, K); solve(N, M, K); } void solve (int N, int M, int K) { const long MOD = 998244353; long[][] dp = new long[][](N+1, K+1); foreach (d; dp) d[] = 0; dp[1][0] = M; foreach (i; 1..N) { for (int j = 0; j \u0026lt;= K; j++) { dp[i+1][j] += (M-1) * dp[i][j] % MOD; dp[i+1][j] %= MOD; if (j \u0026lt; K) { dp[i+1][j+1] += dp[i][j]; dp[i+1][j+1] %= MOD; } } } long ans = 0; foreach (d; dp[N]) { ans += d; ans %= MOD; } writeln(ans); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } しかし、これでは間に合わない。 どうにか他の方法を考えよう。 こういうときは、他にうまいdpがあることは(この難易度帯では)少なく、 うまく数学で解くことが多い。 まず、隣り合う数を固定して(以下、$x$で考える)考える。 前から順番に色を塗っていくと考えると、$i$番目のブロックを塗る時、 $i-1$番目のブロックと色が同じ時、隣り合う同じ色の場所の数は増える。(場合の数は$1$倍) $i-1$番目のブロックと色が違う時、隣り合う同じ色の場所の数は変わらない。(場合の数は$M-1$倍) が$2$以上の$i$に対して常に成立することがわかる。 すなわち、最後まで塗った結果隣り合う色が同じ場所が$x$となるような塗り方は、 パターン1を$x$回、パターン2を$N-1-x$回経たようなものに限定されることになる。 また、$i=1$のときは何色で塗っても「一つ前」がいないので変わらなく、$M$通りになる。 どこでパターン2を引くかの自由度を考えると、これは$\\binom{N-1}{N-1-x}$通りであるから、最終的に場合の数は 上で議論したものにこれをかけた値、つまり $$ M \\times 1^{x} \\times (M-1)^{N-1-x} \\times \\binom{N-1}{N-1-x} = M \\times (M-1)^{N-1-x} \\times \\binom{N-1}{N-1-x} $$ 通りであり、解はこれを$0 \\leq x \\leq K$の範囲で合計したものになる。 適切な前計算の元、一つ固定した$x$に対して$O(\\log N)$で求められるため、問題を$O(N \\log N)$で解くことが出来た。 実装例 import std; void main () { int N, M, K; readln.read(N, M, K); solve(N, M, K); } void solve (int N, int M, int K) { /* 前から順番に色を塗っていくことを考える。 1通りの現状維持(同じ色+1) or M-1通りの色変え(同じ色維持) をN-1回迫られるという考え方で行く。 */ const long MOD = 998244353; long[] fact = new long[](N+1); long[] factInv = new long[](N+1); fact[0] = factInv[0] = 1; foreach (i; 1..N+1) { fact[i] = i*fact[i-1] % MOD; factInv[i] = modInv(fact[i], MOD); } long comb (int n, int k) { if (n \u0026lt; k) return 0; long res = fact[n] * factInv[k] % MOD; res *= factInv[n-k]; return res % MOD; } long ans = 0; for (int i = 0; i \u0026lt;= K; i++) { /* i組の隣が同じ色のペアが存在する */ long add = M*comb(N-1, N-1-i) % MOD; add *= modPow(M-1, N-1-i, MOD); add %= MOD; ans += add; ans %= MOD; } writeln(ans); } 長いので、ModPowやModInvなど一部関数は省略している。 感想 久しぶりに問題を見返したら全く解けなくて驚愕した。 折角なので復習の意味も込めて解法を理解し直してみた。 この手の問題ではやはり 変数をできるだけ固定して考えてみる 単純化したバージョンの問題を考えてみる(2Dから1Dに落としてみるなど) などの基本テクニックを忘れないことももちろん、 前から決めていくことにして考える(うまく行けば、今回のdp解のように部分問題の構造が見つかることも) 問題の操作を俯瞰的に見る 途中の「状態」を持たなくて良い方法を考える など色々あると思う。 今回の解法はどこで一つ前と違う色を入れても変わらず場合の数が$M-1$倍になることが重要なポイントであった。 いや、やっぱりこんなの誰が解けるんだ？でも1ヶ月前の自分は解けてるんだよな。。。 結局思考を再現できそうにない気がする。助けてくれ。"
  },
  {
    url: "/post/2023-final/",
    title: "2023年お疲れ様でした。",
    date: "2023-12-31T00:00:00+09:00",
    body: "2023年お疲れ様でした。 2023年12月31日 今年も大晦日と呼ばれるこの日がやってきました。 折角この場があるので、何か書きます。 それぞれの章は独立しており、関連性はありません。 なので突拍子もないことが書いてあるかもしれません。 ご了承くださいな。 競技プログラミングと自分 振り返りとこれからの目標 2022年末に競技プログラミングに出会い、そこからそこそこ力を入れてやってきました。 毎日必ず触れるようにしようと決めて、ずっとstreakが切れないように問題を解き続けてきました。 2023年が始まった時点でのレーティングが199で、現在が1258まで到達することが出来ました。 これで満足かと言われると、そんなことは無いです。2024年も頑張って取り組んでいきたいなと思っています。 目標は ICPC予選突破(して、合法的に美味しいもの食べに行きたい) レーティング1600達成 の2つです。 初心を忘れることのないようにしたいものです。 最近の自分 最近は1200以上はキープできるけど、それ以上を目指すにはかなり力不足を感じています。 客観的に分析すると、このランク帯の適正難易度が出にくいというのが原因かなという感じです。 緑くらいの難易度と、青以上の難易度は割と出題割合が高いものの、水ちょい上くらいの問題というのはあまり見かけないイメージです。 文句を言わずに青レベルを解けるようになるのが一番早そうな感じがします。 皆さんは、(これを見てる人はたいてい青以上だったりすると思うのですが、)「こんな解法思いつくわけ無いだろ」とか思ったりしませんか？ 私が問題を解いてて一番精神的ダメージを受けるのは、自分で再現できる自信がまったくないような頭の良い解法に出くわしたときです。 練習量がどうだとかそういうものをあざ笑うかのような問題にぶち当たり、何回もやめたくなったことがあります。 それでも「そのまま覚えてしまうのも練習の内」と言い聞かせて続けてきました。 しかしそんな愚かな考えは、初見で普通に解ける人の存在によって打ち砕かれ、自分はなぜ生きているんだろうと感じることすらあります。 基本的には楽しいんですが、やはり辛いときもありますよね。競技プログラミングは。 で、結局どうすれば良いのかとかの疑問に対する答えはまだ出ていません。自分は今でも問題が解けなくて大ダメージを受けることもあるし、なんでこんなに頭が悪いのだろうと思うこともあります。 しかし、その分をstreakの更新や「少なくともこの問題の解法は覚えてしまったから俺の勝ち」みたいな違う方向での喜びに変更するようにしています。 来年のこの時期に「そんなこともあったなぁ」と言えるくらい強くなっていたらどんなに良いだろうと思います。 思ったこと もしかしたら自分は今までまともに「真剣に取り組む」ということをしてこなかったのかもしれません。 スポーツに熱中して、真剣に取り組んだことがある人は多いんじゃないかと思います。 かくいう自分は中高で運動部の部活動をしてきたり、小さい頃からスキーをしていたりしました。 しかし、競技プログラミングをはじめて、そのどれもあまりやる気を出せていなかったんじゃないかと今になって感じます。 それらと競技プログラミングの最大の違いが、やってて楽しいと思う時間の長さです。 それとともに、逆に、やってて楽しいことじゃないと真剣に向き合えないんじゃないかなとも思います。 かの 渡辺明 は次のように言いました。(ソースが 怪しい のでほんまかは知らん) 初めて竜王になったころ、僕はこう思っていました。 「自分が竜王になれたのは、誰よりも努力したからだ。誰だって努力すればプロになってタイトルくらい取れる。他の人たちは、全然努力をしていない」 自分よりも弱い人たちに対して、心の中で「真面目にやらなかった人」とレッテルを貼って馬鹿にしていたんです。 だけど、息子に将棋を教えるようになって、自分の間違いに気付きました。昔の自分に簡単にできたことが、息子は全然できないんです。 実は、子供に将棋を教えるという経験がそれまで一度もなかったので、本当に驚きました。「え？なんでこんなことが分からないの？」って。 それでやっと理解しました。「あぁ、自分には将棋の才能があったんだ」と。 もちろん、たくさん努力もしましたよ。だけど、それだけではなかった。 将棋の神様が与えてくれた才能があったからここまで来れたということが、ようやく分かったんです。 誰でも努力を続ければ、将棋は確実に上達していくと思います。そして、トッププロはみんな努力しています。 それは事実です。だけど、上達スピードは人それぞれ。 一生努力を続けてもプロレベルになれない人もいるということに、僕はこのとき初めて気付きました。 みんな努力していないと決め付けて馬鹿にしていた昔の自分は、我ながら最低の人間です。 得意なことだから努力したくなるし、楽しいのではないでしょうか。 そういう仮定をすると、私は競技プログラミングに出会えて幸運だったのかもしれません。 ギャラリー 大晦日小話 イベント、好きですか？ イベントというのは、ハレの日みたいなものだと考えてもらえばよいです。 学園祭でもいいし、年中行事の日でもいいし、コミケでもいいです。 ちなみに私はイベント嫌いです。 嫌いな理由はいくつかありますが、大まかに 「いつも通り」が崩されること ワイワイしてないやつが「仲間はずれ」とみなされること 自分の中の逆張り心が「今はスカしておくべき」だと言ってくること などがあります。 こういう日は心がざわついて、何をしても楽しくも無いという地獄です。 どうでしょう？共感できますか？ ちなみに今日、12月31日も自分にとって少しハズレの日です。 世間は〇〇納めだなんだと言いますし、みんな揃いも揃って浮ついています。 ですが、今年の大晦日は少し心穏やかに過ごせました。 私はいま実家(兵庫県神戸市)に帰省しており、市の中心街である元町や三宮にでかけてきました。 しかし、思った以上に街は「いつもどおり」をキープしており、年末感は少なかったです。 電車が少し空いていたり、干支に因んだ服が売っていたりしたくらいです。 残りの時間も昼寝をしたり、競技プログラミングをしたりして、テレビなどから少し距離を取ることにより良い年末を過ごせたような気がします。 来年はより良い年になるといいな。 教訓: ボッチで体調を崩すのはやめようね！ またもや体調が崩壊... とりあえず寝ます。 \u0026mdash; In (@UU9782wsEdANDhp) December 21, 2023 事件は2023年12月21日に始まった\u0026hellip; この日、当然のように2限の授業を寝坊し、4限に出席していました。 すると、なんだか知らんけどめちゃくちゃ鼻水が出るし、なんか気持ち悪くて吐きそうになってきました。 5限も授業がありましたが、これ出たら死ぬんじゃないかと思ってブチ切り、帰って寝ました。 起きても全然体調が回復していなく、このツイートをして1問だけ通して寝ました。 ここから地獄が始まります。 ちょっとマシになってきた... 24時間くらい横になった後は頭が痛くても眠れないということを知った。 ABCどうしようかな。 \u0026mdash; In (@UU9782wsEdANDhp) December 23, 2023 さて、いきなり2日飛びましたが、この間のすべての時間寝ていました。 寒気と頭痛で1時間おきくらいに目が覚めるので、本当に最悪でした。 こいつABC出ようか悩んでいますが、かなり体調悪いですよ。 さて、結局この後ABCに出て、-22を食らうという最悪なことが発生したのはまた別のお話。 実はこの翌日に用事があり、どうしても朝起きて昼間で活動しなくてはいけなかったのです。 そんな状態でよる12時くらいまで競プロをやってしまったため、翌日はまじで最悪でした。 ずっと目が痛くてディスプレイを見てられないし、寒気がするから異常に厚着をしてなんとか耐えていました。 結局最終的に限界を迎えたようで、途中で鼻血が出る始末でした。 この辺りで体調は未だ悪いのに、家事が一切出来ないため部屋が荒れだします。 具体的に一番最悪だったのは、汗がいっぱい出るから着替えるのですが、着る服がなくなってくることです。 体調的に無理だと思って、月曜日の授業は出ずに部屋にこもりました。 まあ色々あり、現在はだいぶ体調が良くなってきたのですが、頼れる人間がいない状態で体調を崩すとこの世の終わりみたいな自体に簡単に陥るので、皆さんは体調を崩さないように気をつけましょうね。 おわりに 色々書きたいことをかいた。後悔はしてない。 みなさまにとって2024年が実りあるものになりますように。"
  },
  {
    url: "/post/abc290e/",
    title: "ABC290E - Make it Palindrome",
    date: "2023-12-31T00:00:00+09:00",
    body: "ABC290E - Make it Palindrome 問題概要 問題へのリンク 文字列$X$に対して、$f(X) = $($X$を回分にするために変更する必要のある要素の個数の最小値)と定める。 長さ$N$の数列$A$が与えられるので、$A$のすべての連続部分列の集合$X$として、 $\\sum_{x \\in X} f(x)$を求めよ。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $1 \\leq A_i \\leq N$ 解法 すべての連続部分列は$O(N^2)$個ある。 なぜなら、連続部分列を1つ決めることは端点を2つ決めることと等価であるからであり、 端点を2つ決める組み合わせの数は$\\binom{N}{2}$通りであるからである。 一つの連続部分列は長さ$O(N)$であるため、全探索は$O(N^3)$となり、当然間に合わない。 そこで、主客転倒してみよう。(言葉の使い方があってるか不安) ある$(A_i, A_j)$ペアに着目した時、これらが一致する必要のあるような連続部分列は何通り取れるのかを考える。 次に、具体例を挙げる。 2つのOが$A_i$と$A_j$だと考えれば良い。 ____O____O___\rまず、これらが端点の連続部分列を取れば良い。連続部分列の端点をXで示す。 ____X____X___\r他にもこういうとり方もできる。 ___XO____OX__\rこれでも良い。 __X_O____O_X_\rというわけで、問題の答えは「$\\min{} (i, N-j+1)$通り取れる」となる。(1-indexed) O(N)は通るので、左側の項を列挙することにする。 すなわち、任意の$(A_i, A_j)$に対して考えたいが、 とりあえず$A_i$は固定して、$i$より大きな$j$に対する$A_j$の寄与を考えるというわけだ。 1つ左端$A_i$をとった時、「各項が何回一致する必要があるか」は、次のようになる。 ___O______\r4444321\rというわけで、とりあえず$O(N^2)$解を得ることが出来た。 $A_i$と$A_j$が一致するならスキップ、そうでないなら$\\min{} (i+1, N-j)$(0-indexed)を足し込んでいく感じで解ける。 実装例は次のような感じ。 long ans = 0; foreach (i; 0..N) { foreach (j; i+1..N) { if (A[i] != A[j]) { ans += min(i+1, N-j); } } } 当然まだ通らないので、これを高速化しよう。 問題を解くには、「ある区間に何個分$x$があるのか？」みたいなのを管理できれば良さそうである。 これをセグメントツリーで管理する。 ただし、右端の「4321」みたいになってるところがキモいので、これと「4444」みたいに一定値になってる部分を分けてセグメントツリー2本で管理することにする。 わかりにくいと思うので、もう少し言語化する。 セグメントツリーの最下段を$N$要素確保して、最下段の$i$番目の値を「今見てる区間に$i$は何個あるか？」を管理することにする。 こうすれば、(総和)-(区間の左端の値が何個あるか)を計算することで 「固定した左端の要素を変更する必要のあるような連続部分列のとり方」を数え上げられるという仕組みになっている。 まだイメージがわかない人は実装例を見てほしい\u0026hellip;と言いたかったのだが、実装が厳しすぎておよそ人の読めるようなものではなくなってしまった。 どうしてもインデックスが合わなくて、偶奇で分けて、プリントと$O(N^2)$と合わせながら頑張って実装した。 もっとスマートなやり方はいくらでも紹介されてるので、そちらを参照したほうが良いだろう。(自分もそうする。) 提出 努力の証拠ということで一応貼り付けておく。 解法自体はすぐわかったものの、問題とは3日以上向き合った気がする。 多分$O(N \\log N)$ import std; void main () { /* 主客転倒して、A[i]がどこと何回一致判定されるかを考える。 すると、min(右側の幅, 左側の幅)を考えれば良いことがわかり、セグ木2本持っておくとよい。 */ int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); A[] -= 1; long ans; if (N % 2 == 0) { ans = solveEVEN(N, A); } else { ans = solveODD(N, A); } writeln(ans); } long solveEVEN (int N, int[] A) { auto M = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); auto R = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); long ans = 0; for (int i = N-1; N/2 \u0026lt;= i; i--) { R.set(A[i], R.get(A[i]) + N-i); } /* 右に進む */ for (int i = N/2-1, j = 0; i \u0026lt; N-1; i++, j++) { ans += R.prod(0, N) - R.get(A[i]); R.set(A[i+1], R.get(A[i+1]) - (N/2-j)); } /* セット */ foreach (i; 0..N) R.set(i, 0); for (int i = N-1; N/2+1 \u0026lt;= i; i--) { R.set(A[i], R.get(A[i]) + N-i); } M.set(A[N/2], M.get(A[N/2]) + 1); M.set(A[N/2-1], M.get(A[N/2-1]) + 1); for (int i = N/2-2, j = 0; 0 \u0026lt;= i; i--, j++) { ans += (i+1) * (M.prod(0, N) - M.get(A[i])); ans += R.prod(0, N) - R.get(A[i]); R.set(A[N/2+1+j], R.get(A[N/2+1+j]) - (i+1)); M.set(A[N/2+1+j], M.get(A[N/2+1+j]) + 1); M.set(A[i], M.get(A[i]) + 1); } return ans; } long solveODD (int N, int[] A) { auto M = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); auto R = new SegmentTree!(long, (long a, long b) =\u0026gt; a+b, () =\u0026gt; 0L)(N); long ans = 0; for (int i = N-1; N/2 \u0026lt; i; i--) { R.set(A[i], R.get(A[i]) + N-i); } /* 右に進む */ for (int i = N/2, j = 0; i \u0026lt; N-1; i++, j++) { ans += R.prod(0, N) - R.get(A[i]); R.set(A[i+1], R.get(A[i+1]) - (N/2-j)); } /* セット */ foreach (i; 0..N) R.set(i, 0); for (int i = N-1; N/2 \u0026lt; i; i--) { R.set(A[i], R.get(A[i]) + N-i); } M.set(A[N/2], M.get(A[N/2]) + 1); for (int i = N/2-1, j = 0; 0 \u0026lt;= i; i--, j++) { ans += (i+1) * (M.prod(0, N) - M.get(A[i])); ans += R.prod(0, N) - R.get(A[i]); R.set(A[N/2+1+j], R.get(A[N/2+1+j]) - (i+1)); M.set(A[N/2+1+j], M.get(A[N/2+1+j]) + 1); M.set(A[i], M.get(A[i]) + 1); } return ans; } 流石に長いのでセグメントツリーの実装は省略した。 感想 死ぬほど苦戦して、かなり自信を失った気がする。 次解くときはもっとスマートな解法でやりたいと思う。"
  },
  {
    url: "/post/abc221e/",
    title: "ABC221E - LEQ",
    date: "2023-12-16T00:00:00+09:00",
    body: "ABC221E - LEQ 問題概要 問題へのリンク 長さ$N$の整数列$A = (A_1, A_2, \\dots , A_N)$が与えらえる。 $A$の長さ$2$以上の部分列であって、次の条件を満たすものをの総数を$998244353$で割ったあまりを求めよ。 部分列の最初と最後の項を$A^\\prime{}_1, A^\\prime{}_k$とするとき、$A^\\prime{}_1 \\leq A^\\prime{}_k$が成立する。 制約 $2 \\leq N \\leq 3 \\times 10^5$ $1 \\leq A_i \\leq 10^9$ 考察 まず感じるのが、ちょっと変わった条件だなということ。 この条件下では、部分列を要求しておきながら、最初と最後しか条件に影響しない。 現段階で私は、部分列を扱うという時点である程度はdpの線を疑ったほうが良いと考えている。 なので、とりあえず典型的なdpに落とし込めないか(簡単な部分問題を見つけられるか)を試す。 こういう問題でdpを考えるときは、大抵の場合前から逐次的に項を部分列に追加するかどうかを見ていくdpになる。 なので、ある段階でそれまでの部分列を特徴づける値(高々2次元くらいが好ましい)がないかを探してみる。 が、いい感じのdpはなさそうである。 そういう時はもっと大枠の数学で数え上げられることがある。 例えば、「実はこの問題の解は重複順列と同じようなアイディアで解ける」というようなケースがこれに当たる。 そう思っていろいろ考えてみるが、やはり「最初の項」の情報を持っておかなければどうにもならないので、そんな都合のいいことはなさそうである。 だが、例えば始点を完全に一つに定めたとする。これなら解ける。 始点を$A_x$、終点を$A_y$とする。 この間の$y-x-1$項は、どのように採用しても部分列は条件を満たす。 すなわち、$2^{y-x-1}$通りになる。これを$x \u0026lt; y$なるすべての$y$について足し合わせれば$O(N)$くらいで解ける。 しかし、この問題においてはどの項も初項になる可能性があり、結局$O(N^2)$となるため間に合わない。 ここで自力考察は力尽きてしまった。 解法(解説AC) 実は、最後の始点固定が当たりの方針で、これをうまく利用すると解くことができる。 (どちらでもよいが)簡単のため、終点を固定して考える。終点を$A_j$とするとき、条件を満たす部分列の個数はいくつになるだろうか？ 答えは、$i \u0026lt; j$かつ$A_i \\leq A_j$なるすべての$i$に対して、$2^{j-i-1}$の和、つまり、数式で表わすと、 $$ \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} 2^{j-i-1} $$ である。これを次のように変形する。 $$ \\begin{split} \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} 2^{j-i-1} \u0026amp;= \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} \\frac{2^{j}}{2^{i+1}} \\\\ \u0026amp;= 2^{j} \\sum_{\\substack{i \u0026lt; j \\\\ A_i \\leq A_j}} \\frac{1}{2^{i+1}} \\end{split} $$ なんと、数式の裏に隠れて気づきにくいが、$2^{j}$を外に出すことができる。 この形に持ってきたら、なんとなく方針が見えてくる。 要は、$i \u0026lt; j$なる$i$で、条件を満たすものの総和を高速に求められたら良いということになる。 そしてこれは、座標圧縮とセグメントツリー(やBITなど)で達成できる。 具体的な方法の説明をしよう。 座標圧縮によって、元の数列$A$を$[0, N-1]$の元へ写す。 こうすることで、セグメントツリーの$x$個目の要素が元の数列の$x$番目に大きな要素と対応する。 ここに、$A$の前の項から順番に適切な場所へ$1/2^{i+1}$の値を足しこんでいく。 終点が$A_x$であるときの解を求めるには、$A_x$の圧縮先を$x$とするとき、セグメントツリーの$[0, x]$の合計値に$2^{x}$をかけることで得られる。 以上より、全体$O(N \\log N)$で解を求めることができる。 実装例 import std; void main () { int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); solve(N, A); } void solve (int N, int[] A) { /* 解説AC: 先に部分列の頭と尻尾を決め打ちする。 この時、i \u0026lt; j かつ A_i \u0026lt;= A_jである。 このような部分列は2^{j-i-1}個存在し、すべて条件を満たす。 2^{j-i-1} = 2^{j} / 2^{i+1}であるから、 jを一つ固定して考える。尻尾がA_jであって、条件を満たす部分列は2^{j} / sum(1 \u0026lt;= i \u0026lt; j かつ A_i \u0026lt;= A_j) 2^{i+1}通り。 これは座圧 + 動的区間和取得ができればO(log N) 具体的には、Aを座圧して列Bを作り、前からj-1までで1/2^{i+1}の計算結果を列のしかるべきところに入れる。 すべてのjに対して同じことを行うと、O(N log N)に落ちる */ const long MOD = 998244353; /* 座圧 */ auto B = A.dup; B = B.sort.uniq.array; int[int] comp; int f (int x) { /* A -\u0026gt; B */ return comp[x]; } int fInv (int x) { /* B -\u0026gt; A */ return B[x]; } foreach (i, b; B) comp[b] = cast(int) i; auto RSQ = new SegmentTree!(long, (long a, long b) =\u0026gt; ((a+b)%MOD), () =\u0026gt; 0L)(B.length); long ans = 0; long po = 2; long deno = modInv(2, MOD); long inv = deno*deno % MOD; foreach (i, a; A) { ans += po * RSQ.prod(0, f(a)+1) % MOD; ans %= MOD; long NewVal = RSQ.get(f(a)) + inv; NewVal %= MOD; RSQ.set(f(a), NewVal); po *= 2; po %= MOD; inv *= deno; inv %= MOD; } writeln(ans); } セグメントツリーの実装は長いので省略した。 感想 いいところまでたどり着けていたので、自力でACとりたかった気持ちもあるが、それ以上に解法に感動した。 この解法は$O(N \\log N)$で転倒数を求めるアルゴリズムとほぼ同じだと思った。 しかし、そこに帰着するまでの考察もそこそこ非自明だと感じる。 やはり水色diffはかなり苦しい。 得られる教訓としては、やはり変数固定は大事であるということと、式におこすことに成功したら変数分離を試みるべきという事だろうか。 $j$(尻尾のインデックス)を分離できるというのは負の指数を分数形に直すまで全然気が付かなかった。 また、考察の最初にdpの線を考えていたが、今になって考えてみると、 この問題で問われる部分列は、明らかに最後にとった項やこれまで取った項から計算できる何かで特徴づけされているのではない。 先頭の項のみによって特徴づけられているということからdpの線を外すべきだったなと思う。 なぜなら、ある項で終了できる部分列かどうかというのは最初の項を見ないと判断できないため、どうしても$O(N)$個くらいの情報を持っておかないといけないはずだからである。"
  },
  {
    url: "/post/split-into-continuous-subsequences/",
    title: "列をいくつかの連続部分列へ分解する小技",
    date: "2023-12-13T00:00:00+09:00",
    body: "列をいくつかの連続部分列へ分解する小技 問題 数列$A$の連続部分列を、$i, j \\in [1, N]$かつ$i \\leq j$なる$i, j$を選択し、 $A$の$i$項目から$j$項目までを順番を変えずに取り出したものとし、$B_{i, j}$と表記することとする。 長さ$N$の数列$A = (A_1, A_2, \\dots, A_N)$が与えられる。 数列$A$から取り出した$1$個以上の連続部分列の列$C$であって、次の条件を満たすものをすべて列挙せよ。 $C$の要素を前から順番を変えずに結合して得られる数列は、$A$に一致する。 但し、$2$つの連続部分列の列が異なるとは、ある要素が存在して、片方にのみ含まれることとする。 制約 $1 \\leq N \\leq 15$ 問題の説明 ややこしく書いたが、要は重ならない/余らないようにいくつかの連続部分列に分解しろという問題である。 まず、連続部分列への分割は$2^{N-1}$通り存在することを説明する。 まず、$A_i$と$A_{i+1}$の間に全部で$N-1$個の「切れ目」があると考える。 最終的に$k$個の連続部分列に分解する時、これらの切れ目を$k-1$個選択することで達成される。 この組み合わせ数は$\\binom{N-1}{k-1}$通りである。 $1 \\leq k \\leq N$に対する総和を取ればよいため、全体の組み合わせ数は、 $$ \\sum_{k=0}^{N-1}\\binom{N-1}{k} = 2^{N-1} $$ 通りになる。 なお、この変形を含めた二項係数の公式は 高校数学の美しい物語 を参照すると良い。 次の章で、これらすべてを実際に列挙する方法を説明する。 解法 本問題は、bit全探索を用いて時間計算量$O(N2^N)$で解くことができる。 まず、元の数列$A$をint[]で、1つの有効な分割をint[][]で管理することにする。 int[] A = readln.split.to!(int[]); // 標準入力から入力 int[][] ans = new int[][](N, 0); // 二次元配列を宣言し、メモリ確保 また、$A_i$と$A_{i+1}$の「切れ目」をint[]で管理する。 int[] cut = new int[](N-1); ここで、cut[i]が表すのは$A_i$と$A_{i+1}$の間の「切れ目」であることに注意せよ。 bit全探索を用いて、どの「切れ目」を採用するかを探索する。 for (int bit = 0; bit \u0026lt; (1\u0026lt;\u0026lt;(N-1)); bit++) { cut[] = 0; // cutのすべての要素に0を代入 for (int i = 1; i \u0026lt; N; i++) if (0 \u0026lt; (bit\u0026amp;(1\u0026lt;\u0026lt;i))) cut[i] = -1; // -1の代入された切れ目を使う } 例えば、$N=5$の時、cutを適切な場所でprintすると次の出力を得る。 [0, 0, 0, 0] [-1, 0, 0, 0] [0, -1, 0, 0] [-1, -1, 0, 0] [0, 0, -1, 0] [-1, 0, -1, 0] [0, -1, -1, 0] [-1, -1, -1, 0] [0, 0, 0, -1] [-1, 0, 0, -1] [0, -1, 0, -1] [-1, -1, 0, -1] [0, 0, -1, -1] [-1, 0, -1, -1] [0, -1, -1, -1] [-1, -1, -1, -1] あとは、cutの情報を利用しながらansへ格納していけば良い。 具体的には、次のアルゴリズムで達成できる。 cur = 0、idx = 0とする。 cur \u0026lt; N-1 \u0026amp;\u0026amp; cut[cur] == -1が真の時、手順3へ。そうでなければ手順4へ行く。 ans[idx]にA[cur]を追加し、idx += 1とする。手順5へ行く。 ans[idx]にA[cur]を追加する。手順5へ行く。 cur += 1とする。cur == Nであれば終了。手順2へ行く。 実装例 import std; void main () { int[] A = [1, 2, 3, 4, 5]; int[][] ans = new int[][](A.length, 0); int[] cut = new int[](A.length-1); /* bit全探索 */ for (int bit = 0; bit \u0026lt; (1\u0026lt;\u0026lt;(A.length-1)); bit++) { cut[] = 0; // cutをリセット for (int i = 0; i \u0026lt; A.length-1; i++) if (0 \u0026lt; (bit\u0026amp;(1\u0026lt;\u0026lt;i))) cut[i] = -1; /* ansへ割り振る */ foreach (ref a; ans) a.length = 0; // ans[i]をリセット int cur = 0, idx = 0; while (true) { if (cur == A.length) break; if (cur \u0026lt; A.length-1 \u0026amp;\u0026amp; cut[cur] == -1) ans[idx++] ~= A[cur]; // ~=はpush_backのようなもの else ans[idx] ~= A[cur]; cur++; } /* 出力 */ write(\u0026#34;answer \u0026#34;, bit, \u0026#34; \u0026#34;); for (int i = 0; i \u0026lt;= idx; i++) { write(ans[i], i == idx ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;); } } } answer 0 [1, 2, 3, 4, 5] answer 1 [1] [2, 3, 4, 5] answer 2 [1, 2] [3, 4, 5] answer 3 [1] [2] [3, 4, 5] answer 4 [1, 2, 3] [4, 5] answer 5 [1] [2, 3] [4, 5] answer 6 [1, 2] [3] [4, 5] answer 7 [1] [2] [3] [4, 5] answer 8 [1, 2, 3, 4] [5] answer 9 [1] [2, 3, 4] [5] answer 10 [1, 2] [3, 4] [5] answer 11 [1] [2] [3, 4] [5] answer 12 [1, 2, 3] [4] [5] answer 13 [1] [2, 3] [4] [5] answer 14 [1, 2] [3] [4] [5] answer 15 [1] [2] [3] [4] [5] 確かに分割が成功している。 使用例 ネタバレ注意であるが、AtCoderの この問題 で使うことができる。 提出例 終わりに これサッと実装しろと言われたら困る人も多いんじゃないかなと思ったので作りました。 役にたてば幸いです。"
  },
  {
    url: "/post/uec-advent2023/",
    title: "ミスりにくい二分探索 [UEC Advent Calendar 2023] 6日目",
    date: "2023-12-05T00:00:00+09:00",
    body: "ミスりにくい二分探索 [UEC Advent Calendar 2023] 6日目 \rまえがき この記事は、 電通大生による電通大生のためのUEC Advent Calendar 2023 の6日目担当です。 2時間ほど遅刻しました！すみません！ 5日目はトナカイさんによる、 BASHであそぼ でした。 私もⅠ類の友人がいますが、彼は毎回提出コマンドを手打ちしていた記憶があります。 自動化スクリプトをbashでササッと組めるのすごく憧れるんですが、いつもbashを勉強する面倒臭さが勝ってしまいます。 私もいつの日か 退屈なことはpythonにやらせ られるようになりたいです。 実はAdvent Calendarは公開後すぐに枠が埋まってしまったので、2枠目も存在します(なんで？)。 5日目の牛田ウシタさんの記事はまだ公開されていないようですが、こちらもぜひ読んでみてはいかがでしょうか！ 本記事を書いている間に更新されていました。 アドカレを書くためにいきなり22万吹き飛んでいて笑いました。 長期間の出来事が詳細に語られていて、臨場感がありました。私が文章書くと臨場感が死ぬので、すごいなぁ。。 私は関西に住んでいた経験があるため、いくつか知っているポイントがあったのが面白かったです。(京都のデカい階段、奈良の穴とか) それではそろそろ本題に行きましょう。 はじめに こんにちは、こんばんは、おはようございます。 6日目を担当する、 In と申します。 去年に引き続き、今年も参加させていただきました。 今年は 去年のやつ よりも実りのある記事がかければ良いなと思っております。よろしくおねがいします。 二分探索とは 本記事では、競技プログラミングでよく使うかつ、割とバグらせやすいと思っているアルゴリズムである二分探索の 比較的バグらせにくい実装を紹介します。 なお、厳密性を欠いていたり、不正確な情報があるかもしれません。 もしまずい場所があれば指摘していただけると助かります。 まずは、本記事において「二分探索」が何を指すのかをはっきりさせておきましょう。 二分探索で出来る事\r関数$f: \\mathbb{Z} \\rarr \\{0, 1 \\}$であって、次の性質を満たすものを考える。 $f(x)=0$を満たす$x \\in \\mathbb{Z}$が少なくとも一つ以上存在する。 $f(y)=1$を満たす$y \\in \\mathbb{Z}$が少なくとも一つ以上存在する。 次のどちらか片方のみが成立している。 $x \\leq y \\Rightarrow f(x) \\leq f(y)$ $x \\geq y \\Rightarrow f(x) \\leq f(y)$ $f(a)=0$、$f(b)=1$を既知として、任意の$\\mathbb{Z}$の元に対して$f$の値を時間計算量$\\alpha$で求められるとする。 この時、$f(x) \\neq f(x+1)$なる$x$を時間計算量$O(\\alpha \\log{|a-b|})$で求める。 状況はこんな感じです。 二分探索の動作原理はいたってシンプルです。 最初、$a$と$b$の中点$c$をとります。 具体的には、$c = \\lfloor \\frac{a+b}{2} \\rfloor$とします。 仮定より、関数$f$の値はある一点で$0$と$1$が切り替わり、それ以外の場所で変化しません。 ゆえに、もし$f(c)=0$であったとすると、必ず$a \\leq c \\leq x$であることがいえ、そうでない時は$x+1 \\leq c \\leq b$が言えます。 $f(c)$の値によって区間の端点$a$か$b$を$c$で置き換えます。これを繰り返します。 結果的に、$f(a)=0$と$f(b)=1$を保ったまま、$|b-a|=1$となるまで区間を縮めることができます。 時間計算量を考えましょう。 区間の端点を一度置き換えるごとに区間の長さはおよそ$\\frac{1}{2}$になります。 したがって、アルゴリズムが停止するまでに繰り返される回数は、 $$ \\begin{equation*} \\begin{split} \\frac{|b-a|}{2^x} \u0026amp;= 1 \\\\ |b-a| \u0026amp;= 2^x \\\\ \\end{split} \\end{equation*} $$ より、$x = \\log_2{|b-a|}$となり、$O(\\log{|b-a|})$回程度である事がわかります。 実装の詳細 競技プログラミング界隈で「めぐる式二分探索」と呼ばれる実装があります。 【めぐるのアルゴリズム講座】 二分探索（整数）の書き方 難しさ：４ pic.twitter.com/LGLbkS0D7l \u0026mdash; 因幡めぐる@競技プログラミング (@meguru_comp) February 9, 2016 これをベースにやっていきます。 まず、めぐる式二分探索とは、次のような実装です。 long ok = 0, ng = x; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } この実装では、whileの条件式が1 \u0026lt; abs(ok-ng)になっています。 このおかげで、okとngの大小関係に気を配らなくてよくなります。 関数$f$の実装と二分探索のアルゴリズム部分を分けているのも特徴的です。 これによって、 初期値ok及びngの設定 関数$f$の内部実装 さえきちんとできていれば、あとはボイラープレートとして扱えるという利点があります。 基本はこれ一本ですべてうまくいきます。 ということで、ここからは関数$f$の設計と初期値の設定に注力しましょう。 関数$f$の設計 関数の設計は、二分探索で最も重要な部分です。 ここをミスったらどうやってもバグります。 関数の設計で気を付けることはただ一つです。 必ず$f(x)=0$及び$f(y)=1$なる$x$、$y$が存在するようにしてください。 当たり前だろ。と思った方、意外にも見落とすことがあるので、本当に気を付けたほうがいいです。 配列の探索や、ちょっと変則的な関数から$f$を作る場合、定義域が知らぬ間に制限されることがあります。 このような場合、定義域の外まで定義域を拡張して回避するテクニックがあります。あとで触れます。 初期値の設定 初期値の設定は、$f$をうまく構成できたことを確認してから行いましょう。 初期値の設定に落とし穴は少ないです。 okが区間のどちら側か？ $f$の中で計算するとき、ok、ngはオーバーフローしないか？ 本当に$f(\\mathrm{ok}) \\neq f(\\mathrm{ng})$が成立しているか？(もっと初期値を大きく/小さくとる必要があるか？) あたりを調べれば、経験上大体うまくいきます。 練習問題 いくつか練習問題を用意しました。 要は習うより慣れろってことです。 解説も用意してみました。ぜひ見てみてください。 Q1: 年齢あてゲーム 問題 あなたは相手に、「年齢は$x$歳以上ですか？」と何回でも質問できます。 なるべく少ない回数で年齢を当てましょう。 制約 $0 \\leq (相手の年齢) \\leq 10^{18}$ 解答\r$$ \\begin{equation*} f(x) = \\begin{cases} 1 \u0026amp; \\text{if ($x$に対する質問の答えがYes),} \\\\ 0 \u0026amp; \\text{if ($x$に対する質問の答えがNo).} \\end{cases} \\end{equation*} $$ とすれば、$f$として満たすべき性質を満足します。 よって、次のような解答ができます。 bool f (long x) { return ask(x); // ask: long -\u0026gt; bool を暗黙に仮定 } long ok = 0, ng = 10L^^18+1; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(\u0026#34;age = \u0026#34;, ok); 図にするとこうです。 ポイント: $f$の構成は簡単ですが、okを左端にすること、ngの初期値に注意が必要です。 Q2: LowerBound 問題 $N$要素の配列$A$が与えられる。ここで、$i \u0026lt; j \\Rightarrow A[i] \u0026lt; A[j]$が保証される。 $A$の要素であって、$x$以上のものの集合$B$を考える。すなわち、$B = \\{a \\in A | x \\leq a \\}$である。 $B$の最小要素を求めよ。$B = \\emptyset$である場合はその旨を報告せよ。 制約 $1 \\leq N \\leq 2 \\times 10^5$ $0 \\leq i \\leq N-1$に対して、$-10^9 \\leq A[i] \\leq 10^9$ $-10^9 \\leq x \\leq 10^9$ 解答\r$$ \\begin{equation*} f(i) = \\begin{cases} 0 \u0026amp; \\text{if $i \u0026lt; 0$,} \\\\ 0 \u0026amp; \\text{if $A[i] \u0026lt; x$,} \\\\ 1 \u0026amp; \\text{if $x \\leq A[i]$,} \\\\ 1 \u0026amp; \\text{if $N \\leq i$.} \\\\ \\end{cases} \\end{equation*} $$ と定めれば、二分探索に使える関数になります。 範囲外参照をしている場合は右側にはみ出していれば$1$とし、左側にはみ出している場合は$0$としています。 この関数を用いて二分探索することで、$x \\leq A[i]$なる最小の$i$を見つけることができます。 $i = N$であれば$B = \\emptyset$を判定できます。 なぜ範囲外に対しても値を定義しているかというと、$A$の要素がすべて$x$未満であったり、すべて$x$以上であることがあり得るからです。 この工夫をしないと、変な場合分けをする必要が出てきます。 bool f (int i) { if (i \u0026lt; 0) return false; if (N \u0026lt;= i) return true; return x \u0026lt;= A[i]; } int ok = N, ng = -1; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } if (ok == N) { writeln(\u0026#34;B is empty\u0026#34;); } else { writeln(A[ok]); } 図にするとこんな感じです。 Q3 (Advanced Problem): ABC309C - Medicine 問題 高橋君は医者のすぬけ君から$N$種類の薬を処方されました。$i$種類目の薬は(処方された日を含めて)$a_i$日間、毎日$b_i$錠ずつ飲む必要があります。また、高橋君はこれ以外の薬を飲む必要がありません。 薬を処方された日を$1$日目とします。$1$日目以降で、初めて高橋君がその日に飲む必要がある薬が$K$錠以下になるのは何日目かを求めてください。 制約 $1 \\leq N \\leq 3 \\times 10^5$ $0 \\leq K \\leq 10^9$ $1 \\leq a_i, b_i \\leq 10^9$ 出典: AtCoder Beginner Contest 309 - C この問題は二分探索に帰着するまでに考察が必要です。 頭の体操のつもりで考えてみましょう！ (解けなくても心配しないでください。問題を楽しみましょう！) 解答\r$x$日目に処方される薬の数は、 $$ \\sum_{\\substack{1 \\leq i \\leq N \\\\ x \\leq a_i}} b_i $$ で求めることができます。 プログラム的には、 long sum = 0; for (int i = 0; i \u0026lt; N; i++) { if (x \u0026lt;= A[i]) sum += B[i]; } という感じです。 制約から、この値は$x=1$の時最大値をとり、そこから広義単調減少することがわかります。 この性質から、この値が$K$以下になるか？を判定する関数$f$が二分探索の条件を満たしそうだと分かります。 また、$s(x)$を計算するのに$O(N)$しか必要としないため、これまた二分探索で解けそうな雰囲気があります。 結論から言うと、次の関数を用いることで二分探索可能になります。 $$ s(x) \\coloneqq \\sum_{\\substack{1 \\leq i \\leq N \\\\ x \\leq a_i}} b_i $$ とするとき、 $$ \\begin{equation*} f(x) = \\begin{cases} 0 \u0026amp; \\text{if $K \u0026lt; s(x)$,} \\\\ 1 \u0026amp; \\text{if $s(x) \\leq K$.} \\\\ \\end{cases} \\end{equation*} $$ 解答は以下の通りです。 import std; import core.stdc.stdio; void main () { /* 入力 */ int N, K; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;K); int[] a = new int[](N); int[] b = new int[](N); for (int i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); /* sの定義 */ long s (int x) { long ret = 0; for (int i = 0; i \u0026lt; N; i++) if (x \u0026lt;= a[i]) ret += b[i]; return ret; } /* fの定義 */ bool f (int x) { return s(x) \u0026lt;= K; } int ok = 10^^9+1, ng = 0; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(ok); } 時間計算量は$O(N \\log{(\\max{a_i})})$になります。 また、この問題は二分探索以外の解法もあります。 Q4 (Advanced Problem): ABC312C - Invisible Hand 問題 りんご市場に$N$人の売り手と $M$人の買い手がいます。 $i$番目の売り手は、 $A_i$円以上でならりんごを売ってもよいと考えています。 $i$番目の買い手は、 $B_i$円以下でならりんごを買ってもよいと考えています。 次の条件を満たすような最小の整数 $X$を求めてください。 条件：りんごを $X$円で売ってもよいと考える売り手の人数が、りんごを $X$円で買ってもよいと考える買い手の人数以上である。 制約 $1 \\leq N, M \\leq 2 \\times 10^5$ $1 \\leq A_i, B_i \\leq 10^9$ 出典: AtCoder Beginner Contest 312 - C こちらもAtCoderから引っ張ってきました。 ちなみに私はこの問題の読解で詰まって本番で苦しみまくりました。 解答\rりんごを$X$円で売ってよいと考える売り手の人数$P(X)$は、次のように求められます。\r$$\rP(X) = \\sum_{\\substack{1 \\leq i \\leq N \\\\\\\\ A_i \\leq X}} 1\r$$\rりんごを$X$円で買ってよいと考える買い手の人数$Q(X)$は、次のように求められます。\r$$\rQ(X) = \\sum_{\\substack{1 \\leq i \\leq M \\\\\\\\ X \\leq B_i}} 1\r$$\r問題は、$Q(X) \\leq P(X)$を満たす最小の$X$を求めよというものです。 ここで、$P(X)$、$Q(X)$の性質を利用します。 $P(X)$は、$X$に対して広義単調増加し、$Q(X)$は広義単調減少することがわかります。 すなわち、不等式$Q(X) \\leq P(X)$はある値を境目に「それ以上なら常に成立」、「それ未満なら常に不成立」となることがわかります。 これらの考察から、二分探索できそうな感じがします。 実際に$P(X)$及び$Q(X)$を1回求めるのに$O(N)$時間しか必要としないため、うまくいきそうです！ 解答例を示します。 import std; import core.stdc.stdio; void main () { /* 入力を受け取る */ int N, M; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;M); int[] A = new int[](N); int[] B = new int[](M); for (int i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); for (int i = 0; i \u0026lt; M; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;B[i]); /* P(X) */ int P (int X) { int ret = 0; for (int i = 0; i \u0026lt; N; i++) if (A[i] \u0026lt;= X) ret++; return ret; } /* Q(X) */ int Q (int X) { int ret = 0; for (int i = 0; i \u0026lt; M; i++) if (X \u0026lt;= B[i]) ret++; return ret; } /* f(X) */ bool f (int X) { return Q(X) \u0026lt;= P(X); } int ok = 10^^9+1, ng = 0; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid)) { ok = mid; } else { ng = mid; } } writeln(ok); } 時間計算量は$O(N \\log{(\\max{(\\max{A}, \\max{B})})})$となります。 解きなおしてるときにまたWA出してしまった\u0026hellip; この問題苦手です。 終わりに これで記事はおしまいです。 ここまで読んでいただきありがとうございました。 二分探索は、(最近は比較的マシになってきましたが)私がずっっっっと苦手としているアルゴリズムで、いつか自分の理解をまとめたいと思っていました。 良い機会だと思って思い切って書いてみましたが、正直うまくまとめられなかった感を感じています。 もし本記事を読んで、「全然わからん！」と思った方がいれば、多分私の理解や説明が甘いせいです。すみません。 一方で、もし誰かの理解の助けになればうれしいです。 もし本記事に指摘、感想等いただけるなら、 Twitter の方までお願いします。 明日(12月7日)はみのさんによる、「2023年度財政状況報告」と、あかあくさんによる「アニメオタクのためのサイトを作った」です。 興味深いタイトルですね。 更新が楽しみです。 それではよい二分探索ライフを！"
  },
  {
    url: "/post/abc330/",
    title: "ABC330参加記録",
    date: "2023-11-25T00:00:00+09:00",
    body: "ABC330参加記録 はじめに 本稿は、2023-11-25に行われた ABC330 の参加記録です。 眠れない夜にはコンテストの参加記録を書くのが良いと古事記にも書いてあった要出典ので更新します。 戦績 今回の提出記録は以下の通りです。 AからEまでの5問正解できました。パフォーマンスは1420で、レーティング変動は1200→1224(+24)でした。 所感 今回解ける問題を解いたという感じです。 何とか緑落ち回避できてよかった。 雑振り返り A - Counting Passes 問題へのリンク 配列を前からひとつづつ見ていけば良いです。 こういう感じのA問題楽でうれしいですよね。 import std; void main () { int N, L; readln.read(N, L); int[] A = readln.split.to!(int[]); int count = 0; foreach (a; A) if (L \u0026lt;= a) count++; writeln(count); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - Minimize Abs 1 問題へのリンク Bにしては問題文が難しいです。何を言っているのかわからなくて1分くらい固まっていました。 要するに、次のような感じです。 $1 \\leq i \\leq N$に対して次の問題を解け。 $L \\leq X_i \\leq R$を満たす$X_i$であって、$A_i$と最も近いものを求めよ。 これなら少しマシになった気がします。$A_i \\in [L, R]$であれば、一番近い値は当然$A_i$そのものになるので、$A_i$が答えになります。 そうでない時は、$L$か$R$しかありえません。場合分けして解答しましょう。 import std; void main () { int N, L, R; readln.read(N, L, R); int[] A = readln.split.to!(int[]); int[] ans = new int[](N); foreach (i, a; A) { if (L \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= R) { ans[i] = a; } if (a \u0026lt; L) ans[i] = L; if (R \u0026lt; a) ans[i] = R; } foreach (i, a; ans) write(a, i == ans.length-1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Minimize Abs 2 問題へのリンク とりあえず$x$は固定して考えましょう。$D - x^2 = D^\\prime$とおくと、$|y^2 - D^\\prime|$の最小化問題になります。ただし、$D^\\prime \\in [D-1, \\infty)$に留意しましょう。 うーん、絶対値記号が絶妙にキモいですね。多分外さなくてもいいはずですが、外しましょう。 $$\\begin{equation*} |y^2 + D^\\prime| = \\max (y^2 - D^\\prime, D^\\prime - y^2) \\end{equation*}$$ ムっ、この2項は単調性がありそうですね！ 1項目が最小になるときは、$D^\\prime \\leq y^2$を満たす最小の$y$で、2項目が最小になるときは、$y^2 \\leq D^\\prime$を満たす最大の$y$になるはずです。 これ、二分探索で求められそうですね。 というわけで、ある$x$を与えたときに、最適解になる$y$を高速に探索する方針がたったので、これで終わりです。 import std; void main () { long D = readln.chomp.to!long; solve(D); } void solve (long D) { // xは10^6程度まででよいので、それらに対してyを探索 long ans = long.max; long x = 1; while (true) { if (D \u0026lt; x*x) { break; } // このxに対してのyを求める -\u0026gt; 大体x^2+y^2 - D = 0 =\u0026gt; x^2 + y^2 = D となるような感じで long ok = 0, ng = 2*10^^6; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng) / 2; if (x*x+mid*mid \u0026lt;= D) { ok = mid; } else { ng = mid; } } long candi = min(D - x*x - ok*ok, x*x + ng*ng - D); ans = min(ans, candi); x++; } writeln(ans); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } $x$の上限が$\\sqrt{D}$で抑えられることを考えれば、全体$O(\\sqrt{D} \\log \\sqrt{D})$で抑えられているはずです。多分。 これは普通に難しいと思ったんですが、意外にdifficultyが低かったです。私の解よりもシンプルな全探索解が想定解法らしく(計算量も向こうの方が良い)ちょっと残念です。 D - Counting Ls 問題へのリンク まず、行と列を固定して考えます。 そもそもこのような組が取れるのは、固定した行と列の交点がoであるもののみであることが分かります。 そこから、行と列の好きな場所から1つずつoをとればもれなく数え上げられそうです。 被りがないことの正当性は、固定した行と列が一つでも異なれば、角に当たる部分のoは必ず異なるものが採用されることから従います。 漏れがないことの正当性は、信じる気持ちです(は？)。 というわけで、各行と列に何個oがあるかを保持しておけば、グリッド走査分の$O(N^2)$で計算できます。 本番での私は意味不明なことをしていたので、upsolveの方をあげておきます。 import std; void main () { int N = readln.chomp.to!int; string[] S = new string[](N); foreach (i; 0..N) S[i] = readln.chomp; solve(N, S); } void solve (int N, string[] S) { int[] vertical = new int[](N); // vertical[i] := 列iに何個\u0026#39;o\u0026#39;があるか int[] horizontal = new int[](N); // horizontal[i] := 行iに何個\u0026#39;o\u0026#39;があるか foreach (i; 0..N) foreach (j; 0..N) if (S[i][j] == \u0026#39;o\u0026#39;) horizontal[i]++; foreach (j; 0..N) foreach (i; 0..N) if (S[i][j] == \u0026#39;o\u0026#39;) vertical[j]++; long ans = 0; foreach (i; 0..N) foreach (j; 0..N) { if (S[i][j] == \u0026#39;o\u0026#39;) { ans += (horizontal[i]-1) * (vertical[j]-1); } } writeln(ans); } E - Mex and Update 問題へのリンク 一瞬セグメントツリーの香りを感じてビクッ！としましたが、落ち着いて考えます。 そもそもmex計算がややこしい点は、前の方の要素が全埋めされたときに、いきなり解が後ろの方に飛んでいくことがあり得るからです。 それなら、先に候補地を持っておけばよいじゃないという発想で解きました。 初期状態 mex候補は次のいずれかのみ。 $0$ $A_i+1$ 更新 新しくmex候補となるのは次のいずれかのみ。 $x_k+1$ $A_{i_k}$ というわけで、実は候補地点は更新時に$O(1)$個しか変化しないんですね。 あとは雑に優先度付きキューに突っ込んで、mexとして採用できるかどうかは連想配列で判定したら解けます。 import std; void main () { int N, Q; readln.read(N, Q); int[] A = readln.split.to!(int[]); solve(N, Q, A); } void solve (int N, int Q, int[] A) { // セグ木？ いや、実は候補が少ないパターンのやつだ // 新しく更新したとき、mex候補として一つ後ろをキューに積んでおけばよい int[int] mp; foreach (a; A) mp[a]++; BinaryHeap!(int[], \u0026#34;b\u0026lt;a\u0026#34;) PQ = []; foreach (a; A) if (a+1 !in mp) PQ.insert(a+1); PQ.insert(0); int[] ans = new int[](Q); foreach (j; 0..Q) { int i, x; readln.read(i, x); i--; mp[A[i]]--; mp[x]++; if (x+1 !in mp || mp[x+1] == 0) PQ.insert(x+1); if (A[i] !in mp || mp[A[i]] == 0) PQ.insert(A[i]); A[i] = x; while (true) { auto head = PQ.front; if (head !in mp || mp[head] == 0) { ans[j] = head; break; } PQ.removeFront; } } foreach (a; ans) writeln(a); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 最悪計算量の評価全くしてないけどなんか通りました。まあクエリが$2 \\times 10^5$程度しか来ないので、それはそうですね。 また、この問題はもっと賢い解き方が存在します。$N$要素数列のmexは定義から$[0, N]$の区間内に入ります。 なので、実は極端に大きな項は無視してもよかったわけです。 この議論より、$0$から$N$までの$N+1$要素の配列を持ってシミュレーションをすると解けます。 mexを見つけるのは順序付き集合で対数時間です。 import std; void main () { int N, Q; readln.read(N, Q); int[] A = readln.split.to!(int[]); solve(N, Q, A); } void solve (int N, int Q, int[] A) { int[] range = new int[](N+1); // [0, N]をシミュレーション auto rbt = new RedBlackTree!(int, \u0026#34;a\u0026lt;b\u0026#34;, false); foreach (a; A) if (a \u0026lt;= N) range[a]++; foreach (i, r; range) if (r == 0) rbt.insert(cast(int) i); int[] ans = new int[](Q); foreach (j; 0..Q) { int i, x; readln.read(i, x); i--; // 0-indexed if (A[i] \u0026lt;= N) { range[A[i]]--; if (range[A[i]] == 0) rbt.insert(A[i]); } A[i] = x; if (x \u0026lt;= N) { range[x]++; if (range[x] == 1) rbt.removeKey(x); } ans[j] = rbt.front; } foreach (a; ans) writeln(a); } void read (T...) (string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } これ、とても賢いですね。mexは$[0, N]$というのは覚えておきたいです。 F - Minimize Bounding Square 問題へのリンク 難しい！正方形の1辺を二分探索するのかと思っていたけど、判定問題が全然解けない！ どうやら貪欲解も存在するらしく、まだまだ壁は高いなとおもいました。 終わりに 今回の参加記録はこれで終わりです。読んでいただきありがとうございました。 先週の参加記録を書けていなかったのが少し心残りです。 今週はいろいろと忙しくて、それをやるだけの心的余裕がありませんでした。 12月は緑以下オンサイトに行く予定です。もし行く人いたら仲良くしてください。そうでなければ多分ぼっちです。 昨日、 MMA Contest 017 がありましたが、実は私もテスターをさせていただきました。 走っていない人はぜひどうぞ。余裕があれば私も記事書きます(優先度低め)。 適当に近況も書いておきます。 この間のPG battleの景品が届きました。PG battleのステッカーが6枚も入っていてたまげたのですが、これあってますか？ 最近kindleに興味があります。 先日、面白そうな本を見つけたのですが、経験上、本として所有していても読む機会がなかなかないなと思い、電子書籍なら読むのか実験してみたいという感じです。 基本食事中とかスマホばっかり見てるので、そういう時間に見れるブログみたいな本が読みたいな。とか妄想してます。ちなまだデビューしてないです。 いろいろと書き散らしたいことは脳内にあるのですが、いかんせん競技プログラミングのエントリ以外最初の一歩が踏み出せないのが悩みです (そういうアイディアは形にしようとすると崩壊するのが常なので、まあそれはそうという感じかも)。 それではまた。"
  },
  {
    url: "/post/abc328/",
    title: "ABC328参加記録",
    date: "2023-11-12T00:00:00+09:00",
    body: "ABC328参加記録 はじめに 本稿は、2023-11-11に行われた ABC328 の参加記録です。 戦績 今回の提出は以下の通りでした。 AからEの5問正解できました。 今回のレーティング変動は以下の通りでした。 パフォーマンスは1281で、 レーティング変動は1241→1245(+4) でした。 所感 今回はDまでかなり早く解ましたがE問題で詰まってしまい、パフォーマンスがあまり伸びませんでした。 解けないとマズいという問題は解けたので、とりあえず良しとします。 今回のF問題がPotentialized UnionFindというものを利用すれば簡単に解けたらしく、 自分が解法にたどり着けなかったという点と、ちゃんと前もって学習できていなかったということに対してかなり悔しく感じてします。 今週のプロコンは、このデータ構造を理解してD言語による実装を与えることを目標にやろうかなと思います。 学ぶ機会をもらったと思って頑張ります。 問題振り返り A - Not Too Hard 問題へのリンク 最近のA問題の中でも結構簡単な方な気がします。配点をひとつづつ見ていって、X以下なら足しましょう。 import std; void main () { int N, X; readln.read(N, X); int[] S = readln.split.to!(int[]); int ans = 0; foreach (s; S) if (s \u0026lt;= X) ans += s; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - 11/11 問題へのリンク 実装を考えるとき、有効な月/日を生成することと、ゾロ目になることを分けて考えるとやりやすいのかなと思います。 型変換(int -\u0026gt; string)を簡単にできる言語なら、次のような実装がよいかと思います。 import std; void main () { int N = readln.chomp.to!int; int[] D = readln.split.to!(int[]); int ans = 0; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= D[i-1]; j++) { auto S = i.to!string ~ j.to!string; bool ok = true; foreach (s; S) if (s != S[0]) ok = false; if (ok) ans++; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } そうでない言語なら、判定部分を bool ok = true; int basis = i%10; while (0 \u0026lt; i) { if (i%10 != basis) ok = false; i /= 10; } while (0 \u0026lt; j) { if (j%10 != basis) ok = false; j /= 10; } という感じになるかなと思います。 C - Consecutive 問題へのリンク ナイーブに操作すると$r_i - l_i$が大きいクエリばかり飛んでくるときが最悪ケースで、$O(N^2)$です。 区間クエリを高速化する問題は、累積和を考えると良い場合があります。この問題はまさにそうで、 cum[i] := (S[j] == S[j+1]なら1、そうでないなら0 の 0\u0026lt;=j\u0026lt;=iの総和)と定めると、 前処理$O(N)$クエリ$O(1)$で答えることができます。 クエリをどうやって処理するべきかを一回考えると思いつきやすいような気がします。 (連続区間において条件を満たす場所を数える) -\u0026gt; (条件を満たす場所を1、満たさない場所を0と対応させて、Static Range Sum Queryに帰着) -\u0026gt; 累積和 という流れなのかなと思います。 2番目の考察(あるを1、ないを0に対応させること)がかなりad-hocな気がしますが、これはかなり頻出なので覚えるべきことなのかな？ ちなみに、2番目の考察はDynamic Kth Elementとか$O(N \\log N)$の転倒数にも現れるアイデアです。 import std; void main () { int N, Q; readln.read(N, Q); string S = readln.chomp; solve(N, Q, S); } void solve (int N, int Q, string S) { // imosをやる long[] cum = new long[](N); foreach (i; 0..S.length-1) if (S[i] == S[i+1]) cum[i]++; foreach (i; 1..N) cum[i] += cum[i-1]; foreach (_; 0..Q) { int l, r; readln.read(l, r); l--, r--; if (l == r) { writeln(0); continue; } if (0 \u0026lt; l) writeln(cum[r-1]-cum[l-1]); else writeln(cum[r-1]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Take ABC 問題へのリンク ナイーブに操作すると削除の後に「詰める」操作が発生するので、$O(N^2)$になります。これを改善します。 「左から削除していく」という文言を見た時点で、括弧列の対応を見る問題との共通点を感じました。 \u0026quot;ABC\u0026quot;が\u0026quot;()\u0026quot;だったら有効括弧列を消す問題になるんじゃないかな？ 括弧列の問題 -\u0026gt; 文字列を先頭から見ていって(見たやつをスタックに積んでいって) \u0026quot;)\u0026quot;が出てきたらスタックの先頭が\u0026quot;(\u0026quot;かどうかチェックする。 この問題 -\u0026gt; 文字列を先頭から見ていって\u0026quot;C\u0026quot;が出てきたらスタックの先頭が\u0026quot;AB\u0026quot;かどうかチェックする。 みたいな感じで処理できます。一つの文字を高々2回までしか参照しないので、$O(N)$です。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 前から見ていけばよろしい */ char[] ans; foreach (c; S) { ans ~= c; if (3 \u0026lt;= ans.length) { if (ans[$-3..$] == \u0026#34;ABC\u0026#34;) { ans = ans[0..$-3]; } } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Modulo MST 問題へのリンク 全域木(Spanning Tree)とは、与えられた$G$の部分グラフ$G\u0026rsquo;$であって、$G$のすべての頂点$V(G)$を含み、かつ木であるようなものをいいます。 全域木であって、辺の重みの総和が最小であるものを最小全域木(MST)といいますが、本問では総和ではなく総和を$K$で割ったあまりをコストとしています。 最小全域木を求めるアルゴリズム(クラスカル法など)は役に立ちそうにないです。 制約を見ると、不自然に小さいです。また、あまりを含む最小化問題は感覚的に全探索しかなさそうな感じがします。 そこで、全探索を考えましょう。 「$G\u0026rsquo;$が全域木である」 ならば 「$G\u0026rsquo;$は$N-1$本の辺を持つ」 は真です。つまり、 $G$が全部で$M$本の辺を持つ時、 $\\dbinom{M}{N-1}$通りの辺の取り方を全部調べることができたら十分なことは明らかです。 (この組み合わせには全域木にならないケースも含まれる可能性がありますが、それはコスト更新の時に無視したらよいです。) 今回に関しては最大ケースで$\\dbinom{28}{7} = 1184040$になります。これで通せそうです。 import std; struct trio { int u, v; long w; } void main () { int N, M; long K; readln.read(N, M, K); trio[] edge = new trio[](M); foreach (i; 0..M) with(edge[i]) { readln.read(u, v, w); u--, v--; } solve(N, M, K, edge); } void solve (int N, int M, long K, trio[] edge) { /* Nが十分に小さいので、あり得る全域木を全探索すればよろしい */ /* ほげほげのコストを無視すれば、ありうる全域木は28C7 ~ 10^6通りのはず */ /* あほか？28C7列挙すればいいだろう */ int[][] graph = new int[][](N, 0); bool[] visited = new bool[](N); bool check (trio[] edge) { foreach (ref g; graph) g.length = 0; foreach (e; edge) { graph[e.u] ~= e.v; graph[e.v] ~= e.u; } visited[] = false; void dfs (int pos) { visited[pos] = true; foreach (to; graph[pos]) { if (!visited[to]) dfs(to); } } dfs(0); foreach (v; visited) if (!v) return false; return true; } long ans = long.max; foreach (e; enumComb(edge, N-1)) { if (check(e)) { long sum = 0; foreach (ee; e) (sum += ee.w) %= K; ans = min(ans, sum); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } struct enumComb_(T) { import std.exception; import std.format; import std.range.primitives : ElementType, isRandomAccessRange; long N, K; long[] idx; bool isEmpty; enum bool isNumeric = __traits(isIntegral, T); static if (!isNumeric) { static assert(__traits(compiles, isRandomAccessRange!(T)) || is(T == E[n], E, size_t n) || is(T == E[], E), \u0026#34;T must be Integral type or RandomAccessRange. Now T = \u0026#34;, T.stringof); alias E = ElementType!(T); E[] res; T arr; } this (T N, long K) { static if (isNumeric) { auto msgN = format(\u0026#34;Line : %s, N must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, N); enforce(0 \u0026lt;= N, msgN); this.N = N; } else { this.N = N.length; arr = N; res = new E[](cast(uint) K); } auto msgK = format(\u0026#34;Line : %s, K must be greater than or equal to 0. your input = %s\u0026#34;, __LINE__, K); enforce(0 \u0026lt;= K, msgK); this.K = K; idx = new long[](cast(uint) K); init(); } void init () { foreach (i; 0..K) { idx[cast(uint) i] = i; } if (N \u0026lt; K) { isEmpty = true; } } bool empty() const { return isEmpty; } static if (isNumeric) { long[] front() { return idx; } } else { E[] front () { foreach (i, x; idx) { res[i] = arr[cast(uint) x]; } return res; } } void popFront() { long index; (){ foreach (i; 0..K) { if (idx[cast(uint) ($-i-1)] \u0026lt; N-i-1) { idx[cast(uint) ($-i-1)]++; index = K-i-1; return; } } // there is no choice :( isEmpty = true; }(); foreach (i; index+1..K) { idx[cast(uint)i] = idx[cast(uint)i-1] + 1; } } } auto enumComb(T) (T N, long K) { return enumComb_!(T)(N, K); } ちょうど$\\dbinom{N}{K}$を列挙するアルゴリズムを用意していたので、そんなに苦労せず実装できました。 1700msだったのであまりよくない実装をしていたっぽい\u0026hellip;？ F - Good Set Query 問題へのリンク 題意自体はつかめたのですが、いつものトポロジカル順に処理する奴ではうまく列$(X_1, X_2, \\dots, X_N)$ を決められないなーと思い、そこで行き詰りました。 どうやら重み付き(ポテンシャル付き)UnionFindなるデータ構造で解けるようです。 今週中に解法及びデータ構造を理解して、ACします。(時間があれば別記事たてます。) 終わりに 書きたいことは大体書いたので、あとは適当に近況でも書きます。 最近レーティングが1200あたりで収束している感じがあり、上に行くためにはもっとプロコンに力を入れないとなーと感じています。もっといろんな知識を仕入れたいです。 短期的な目標としては来年までに1300到達、もう少し長期的な目標は次のICPCまでに1600到達です。 無理かもしれませんが、Problemsの水色埋めを客観的に見た感じ到達可能にも感じます。 あと、思うこととして、レーティングとかの指標は本来過去の自分と比較すべきだと考えているのですが、 Twitterとかを追っていると意味のない焦りや嫉妬によって無駄なエネルギーが消耗している実感があります。本来こんな無駄なことをせずに研鑽すべきなんですがね。。。 過去の経験も含めて自分はSNS依存の傾向があるので、自制していきたいですね。 最近、品田遊著「名称未設定ファイル」 Amazonリンク(アフィではないです) を読みました。 星新一が好きな人とかおすすめです。あと、普段本じゃなくてネットばっかり見てる私みたいな人にもおすすめです。 それではこのあたりにしておこうと思います。また次のエントリで。"
  },
  {
    url: "/post/abc100d/",
    title: "ABC100D - Patisserie ABC",
    date: "2023-11-06T00:00:00+09:00",
    body: "ABC100D - Patisserie ABC 問題概要 問題へのリンク $N$種類のケーキがある。$i$種類目のケーキは「綺麗さ」$x_i$、「おいしさ」$y_i$、「人気度」$z_i$を持っている。 このうち$M$種類のケーキを選んで食べる。ただし、同じ種類のケーキを2つとることはできない。 選んだ$M$種類のケーキに対して、スコアを $\\left| \\displaystyle\\sum_{i=1}^M x_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M y_i \\right| + \\left| \\displaystyle\\sum_{i=1}^M z_i \\right|$ と定める。 スコアの最大値を求めよ。 制約 $1 \\leq N \\leq 1000$ $0 \\leq M \\leq N$ $1 \\leq i \\leq N$に対して、$-10^{10} \\leq x_i, y_i, z_i \\leq 10^{10}$ 考察 ナイーブに全探索を考えると、とりうるケーキの組み合わせの数は $\\displaystyle\\binom{N}{M}$通りになるが、$N = 1000, M = 500$において非常に大きくなるため現実的でない。 また、各$x_i, y_i, z_i$の値が大きいため部分和問題のようなdpはできない。 どうしようか？ 解法1 典型テクニック: 「絶対値関数はmax関数で外す」を用いる。 頑張って変形していく。 $$\r\\begin{equation*}\r\\begin{split}\r\\left| \\displaystyle\\sum x_i \\right| + \\left| \\displaystyle\\sum y_i \\right| +\r\\left| \\displaystyle\\sum z_i \\right|\r\u0026= \\max \\left( \\displaystyle\\sum x_i, ~ -\\displaystyle\\sum x_i \\right) +\r\\max \\left( \\displaystyle\\sum y_i, ~ -\\displaystyle\\sum y_i \\right) +\r\\max \\left( \\displaystyle\\sum z_i, ~ -\\displaystyle\\sum z_i \\right) \\\\\r\u0026= \\max \\left(\r\\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~\r\\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~\r\\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~\r\\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~\r-\\displaystyle\\sum x_i + \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~\r-\\displaystyle\\sum x_i + \\displaystyle\\sum y_i - \\displaystyle\\sum z_i, ~\r-\\displaystyle\\sum x_i - \\displaystyle\\sum y_i + \\displaystyle\\sum z_i, ~\r-\\displaystyle\\sum x_i - \\displaystyle\\sum y_i - \\displaystyle\\sum z_i\r\\right) \\\\\r\u0026= \\max \\left(\r\\displaystyle\\sum (x_i + y_i + z_i), ~\r\\displaystyle\\sum (x_i + y_i - z_i), ~\r\\displaystyle\\sum (x_i - y_i + z_i), ~\r\\displaystyle\\sum (x_i - y_i - z_i), ~\r\\displaystyle\\sum (-x_i + y_i + z_i), ~\r\\displaystyle\\sum (-x_i + y_i - z_i), ~\r\\displaystyle\\sum (-x_i - y_i + z_i), ~\r\\displaystyle\\sum (-x_i - y_i - z_i)\r\\right)\r\\end{split}\r\\end{equation*}\r$$\rとてもすっきりした式になった。\rよく見ると、最後のmax関数の中にある各項は$O(N\\log N)$で計算できることが分かる。\rよって全体$O(N\\log N)$で解くことができる。\rimport std; alias trio = Tuple!(long, \u0026#34;x\u0026#34;, long, \u0026#34;y\u0026#34;, long, \u0026#34;z\u0026#34;); void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { /* 典型テク: 絶対値記号を外すやつ によって符号を変えた8通りの和で貪欲にとればよい。O(N log(N)) */ long[] val = new long[](N); int[] sign = new int[](3); long ans = -long.max; void calc () { foreach (i; 0..N) { val[i] = 0; foreach (j, c; cake[i]) { if (sign[j] == 0) val[i] += c; if (sign[j] == 1) val[i] -= c; } } val.sort!\u0026#34;a\u0026gt;b\u0026#34;; ans = max(ans, val[0..M].sum); } void dfs (int level) { if (level == 3) { /* 処理 */ calc(); return; } foreach (i; 0..2) { sign[level] = i; dfs(level+1); } } dfs(0); writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 解法2 はまやんさんの解説 で紹介されているdpをすることもできる。 結論から言うと、最初検討した部分和問題ではなく $$\r\\begin{equation*}\rdp[i][j] = (i項目までのうちj項をとったとき、あり得る最大値)\r\\end{equation*}\r$$\rを考える。\rこのdpを考えるに至る考察は大体次のような感じになる。\r$x_i, y_i, z_i$別々だとだるいので、まず$x_i$についてだけ考える。 絶対値をとるので、最適解は$\\sum x_i$が最大または最小になるときだと分かる。 →最大の値が採用されるときは普通にdpで解ける。 最小になるときが最適解になるときは総和が負になるはずなので、符号を反転させた状態でのdpも考える。 3軸に戻す。3軸すべてが最大をとるタイミングを採用できるように、8通りの符号でdpする。 詳しいアルゴリズムは実装例を参考にしてください。 import std; struct trio { long x, y, z; } void main () { int N, M; readln.read(N, M); trio[] cake = new trio[](N); foreach (i; 0..N) { with (cake[i]) readln.read(x, y, z); } solve(N, M, cake); } void solve (int N, int M, trio[] cake) { long[][] dp = new long[][](N+1, M+1); // dp[i][j] := (i項目までからj項選んだ時の最大値) long ans = 0; /* 符号8通りでdp */ for (int a = -1; a \u0026lt;= 1; a++) for (int b = -1; b \u0026lt;= 1; b++) for (int c = -1; c \u0026lt;= 1; c++) if (a*b*c != 0) { foreach (d; dp) d[] = -long.max; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..M+1) { if (dp[i][j] == -long.max) continue; long diff = a*cake[i].x + b*cake[i].y + c*cake[i].z; // 採用 if (j+1 \u0026lt;= M) dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + diff); // 採用しない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } ans = max(ans, dp[N][M]); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 解法1は45度回転と呼ばれるテクニックとも関連がある。 45度回転とは2次元座標平面上においてマンハッタン距離を考えるときに有用になるテクニックである。 1問紹介しておこう。 ABC178E - Dist Max 問題文 2点$(a, b), ~ (c, d)$に対して2点間のマンハッタン距離を$|a - c|+|b - d|$と定める。 $N$点$(x_i, y_i)$が与えられる。2点間のマンハッタン距離としてあり得る最大の値を求めよ。 制約 $2 \\leq N \\leq 2\\times 10^5$ $1 \\leq x_i, y_i \\leq 10^9$ これを同様に処理してみる。 適当な二点についてマンハッタン距離を考えると、次のようになる。 $$\r\\begin{equation*}\r\\begin{split}\r|x_i - x_j| + |y_i - y_j| \u0026= \\max (x_i - x_j, ~ x_j - x_i) + \\max (y_i - y_j, ~ y_j - y_i) \\\\\\\\\r\u0026= \\max ((x_i - x_j)+(y_i - y_j), ~ (x_i - x_j)+(y_j - y_i), ~ (x_j - x_i)+(y_i - y_j), ~ (x_j - x_i)+(y_j - y_i)) \\\\\\\\\r\u0026= \\max ((x_i + y_i)-(x_j + y_j), ~ (x_i - y_i)-(x_j - y_j), ~ -(x_i - y_i)+(x_j - y_j), ~ -(x_i + y_i)+(x_j + y_j)) \\\\\\\\\r\u0026= \\max (|(x_i + y_i) - (x_j + y_j)|, ~ |(x_i - y_i) - (x_j - y_j)|)\r\\end{split}\r\\end{equation*}\r$$\rを得る。\r最後の式から、すべての点に対して$x_i + y_i$と$x_i - y_i$を計算して、\rそれぞれの差分の絶対値の最大値を見つければよい。\rこれは単にそれぞれの最大値と最小値を与える点を見つければよいため、全体$O(N)$で処理できる。\r以上より、マンハッタン距離を代表とする絶対値記号は、max関数を用いて外すとうまく計算できる場合がある。 筆者は解法を理解していないが、 yukicoder No.2520 L1 Explosion も45度回転を用いるらしい。 この問題は今後の課題としたい。 終わりに いつか取り上げたいと思っていたトピックに触れることができてよかった。 ただし、現状私はこの変換がなぜうまくいくのかという数学的背景を知らないため、 さらに勉強ないし応用の余地があると思う。 が、疲れたのでこのあたりにしておく。"
  },
  {
    url: "/post/abc327/",
    title: "ABC327参加記録",
    date: "2023-11-05T00:00:00+09:00",
    body: "ABC327参加記録 はじめに 本稿は、2023-11-04に行われた ABC327 の参加記録です。 戦績 今回の提出状況は次の通りです。 AからEまでの5問正解できました。 パフォーマンスは1513で、 レーティング変化は1207→1241(+34)でした。 所感 今回は割と早解きできた回だったかなという感じです。 5問目は割と非自明だと思ったのですがかなりたくさんの人が通していました。 とりあえず緑色に再び落下しなくてほっとしています。 問題雑振り返り A - ab 問題へのリンク Nが十分に小さいため、全部ナイーブに見ていくことで十分ACできます。 最初勘違いしていたため、サンプルに\u0026quot;ba\u0026quot;の順でYesが出るものがあってよかったです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; foreach (i; 0..S.length-1) { if ((S[i] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;b\u0026#39;) || (S[i] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; S[i+1] == \u0026#39;a\u0026#39;)) { writeln(\u0026#34;Yes\u0026#34;); return; } } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - A^A 問題へのリンク $A^A$はかなり急激に大きくなるので、$A$を1から順番に$A^A$が$B$を超えるまで増やしていけばよさそうです。 実際、$10^{18} \u0026lt; 16^{16} = 18446744073709551616$なので、$A = 15$までを調べればよいです。 import std; void main () { long B = readln.chomp.to!long; for (long A = 1; ; A++) { if (B \u0026lt; A^^A) { writeln(-1); return; } if (B == A^^A) { writeln(A); break; } } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } ちなみに私の提出は通ってはいるものの、かなりまずいことをしています。 というのも、long.maxよりも$16^{16}$のほうが大きいためオーバーフローしています。 しかし、偶然オーバーフローを含めて$10^{18} \u0026lt; A^A$となるAが存在するようです。 ちゃんとACをとる場合はA=15で止めるか多倍長整数を使うと良いです。 C - Number Place 問題へのリンク 条件1と条件2は二重ループで簡単に判定できます。 条件3は少し複雑ですが、3×3領域を9回判定すると考えると比較的楽に判定をつくれます。 具体的には3×3領域のスタート地点(0, 0), (0, 3), (0, 6), \u0026hellip;, (6, 6)をループで列挙して、 判定自体はつかいまわします。 import std; void main () { int[][] A = new int[][](9, 0); foreach (i; 0..A.length) A[i] = readln.split.to!(int[]); solve(A); } void solve (int[][] A) { bool isOk = true; int[] mp = new int[](10); /* 条件1 */ foreach (i; 0..A.length) { mp[] = 0; foreach (j; 0..A[i].length) { mp[A[i][j]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件2 */ foreach (j; 0..A[0].length) { mp[] = 0; foreach (i; 0..A.length) mp[A[i][j]]++; foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } } /* 条件3 */ int SY, SX; SY = 0; foreach (_; 0..3) { SX = 0; foreach (__; 0..3) { /* 処理 */ mp[] = 0; foreach (i; 0..3) foreach (j; 0..3) { int y = SY + i; int x = SX + j; mp[A[y][x]]++; } foreach (k; 1..10) { if (mp[k] != 1) isOk = false; } SX += 3; } SY += 3; } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Good Tuple Problem 問題へのリンク 二つの数列によってXの2項間に制約が課されていきます。 経験上、数列に制約を課していくような問題はグラフ表現に置き換えられないかを検討すると解けることがあります。 この問題はその方針さえ引ければかなり見えやすいと思います。 要はA[i]項目とB[i]項目が違えばよいので、 A[i]項目とB[i]項目の間に無向辺を張ったときに全体が二部グラフを成せばよいです。 二部グラフの判定にUnionFindを使えるらしいですが、よく理解していないので普通にdfsしました。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, A, B); } void solve (int N, int M, int[] A, int[] B) { /* グラフ表現に落とし込んで解く */ /* 要は二部グラフなら良い */ A[] -= 1; B[] -= 1; int[][] graph = new int[][](N, 0); foreach (i; 0..M) { graph[A[i]] ~= B[i]; graph[B[i]] ~= A[i]; } int[] visited = new int[](N); visited[] = -1; bool isOk = true; void dfs (int pos) { foreach (to; graph[pos]) { if (visited[to] == -1) { if (visited[pos] == 0) visited[to] = 1; if (visited[pos] == 1) visited[to] = 0; dfs(to); } else { /* 矛盾がないか判定 */ if (visited[pos] == visited[to]) isOk = false; } } } foreach (i; 0..N) { if (visited[i] == -1) { visited[i] = 0; dfs(i); } } if (isOk) { writeln(\u0026#34;Yes\u0026#34;); } else { writeln(\u0026#34;No\u0026#34;); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E - Maximize Rating 問題へのリンク 式をぐっとにらむところから考察スタートしました。 kがいろいろな値をとると面倒くさいので、とりあえず固定して考えます。 すると、$\\sum_{i=1}^{k} (0.9)^{k-i} Q_i$を最大化する問題になります。 が、変な係数がかかっているせいでQは貪欲にとれそうにありません。どうしましょう。 貪欲に取れない状況下で最適な部分集合を選ぶ問題というのは基本的に「全部見る」しかないはずです。 なので、この段階でdp濃厚だなーという感じです。(もちろん違う方針なときもあります。) ここで天啓が訪れます。 パフォーマンス$P_i$をx番目の項として採用する場合、 それまでにx-1個を採用した部分集合のみを考えればよいはずです。この方針で状態を圧縮します。 あとからとった項が前にとった項に直接寄与することがないので、次のdpができます。 $$\rdp[i][j] = (Pを逆から見て、i項目までにj項とったときの\\sum (0.9)^{k-i} Q_iの最大値)\r$$\r遷移は /* 採用 */ dp[i+1][j+1] = dp[i+1][j+1], dp[i][j] + P[N-i-1]\\*pow(0.9, j)); /* 採用しない */ dp[i+1][j] = max(dp[i+1][j], dp[i][j]); となります。 このようなdpを私は勝手に「とる/とらないdp」と呼んでいるのですが、 圧縮後の値に部分集合の何項目に採用されたかという情報ものせられるのかと勉強になりました。 import std; void main () { int N = readln.chomp.to!int; int[] P = readln.split.to!(int[]); solve(N, P); } void solve (int N, int[] P) { /* いくつとるかを定めると、あとは最適なPの部分集合を見つける作業になる。 */ /* 最近のものほど重みが高い... -\u0026gt; 最適な部分集合は変わりうる。 */ /* 逆から考えれば、i項目まで見て、j個とって...とすると最適解をタプルに縮退できる。 */ /* dpをしましょう。 */ double[][] dp = new double[][](N+1, N+1); // dp[i][j] := 逆からi項目まで見て、j個とったとき、ありうる最大の分子 foreach (d; dp) d[] = -1; dp[0][0] = 0; foreach (i; 0..N) foreach (j; 0..N) { if (0 \u0026lt;= dp[i][j]) { // とる dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + P[$-i-1]*pow(0.9, j)); // とらない dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } } double[] denominators = new double[](N+1); denominators[] = 0; denominators[1] = 1; foreach (i; 2..N+1) denominators[i] = denominators[i-1] + pow(0.9, i-1); double ans = -double.max; foreach (i; 0..N+1) foreach (j; 0..N+1) { if (0 \u0026lt; j) { ans = max(ans, dp[i][j]/denominators[j] - (1200/sqrt(j.to!double))); } } writefln(\u0026#34;%.10f\u0026#34;, ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } F問題以降 難しくてよくわからない。。。 F問題は考察の方針は非常に良かったようですが、解法を理解できるレベルに到達していないので本稿では触れません。 終わりに 最近$O(\\log N)$くらいの演算だからたくさん呼び出してもいいかーという 軽い気持ちでTLがぎりぎりになったりしていて、前計算の重要性を身に染みています。 前計算徹底いたします(ビッグモーター並感)。 近況も軽く書いておきます。 PG BATTLEで10位に入ることができて、商品をいただけるようです。やったね。 私の参加記録 PG BATTLE結果 PG BATTLE10位でしたーやったー 240点の中でトップらしい... あぶねーーー \u0026mdash; In (@UU9782wsEdANDhp) October 28, 2023 ちなみに商品は肉にしました。鍋にしたすぎ。 今年もUEC Advent Calendar 2023に参加します。プログラミングコンテストについて書く予定です。 皆さんも参加してみては？ アドベントカレンダー あと関係ないですが、最近自分の句読点の使い方の下手さにビビっています。 ほかの方が書いた文章や、プロの書いた文章に比べて明らかにリズムが悪い気がしています。 これを読んでいるあなたはどう思いますか？ まともな文章を書く訓練ってどうやってやるんでしょうね。 というわけでこのあたりにしておきます。また次の記事で～"
  },
  {
    url: "/post/abc190f/",
    title: "ABC190F - Shift and Inversions",
    date: "2023-11-01T00:00:00+09:00",
    body: "ABC190F - Shift and Inversions 問題概要 問題へのリンク $0$から$N-1$までの整数をちょうど一つづつ含む数列$A$が与えられる。 $k \\in \\mathbb{Z}$に対して、数列$B$を次のように定める。 $$ \\begin{equation*} B \\coloneqq \\{b_i\\}_{i=0}^{N-1}, ~ b_i = a_{i+k ~ \\mathrm{mod} ~ N} \\end{equation*} $$ $k = 0, 1, 2, \\dots , N-1$のそれぞれに対して、$B$の転倒数を求めよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ 考察 $k$を一つ変える操作は、変える前の数列を左シフトしたようなものになっている。 例えば、$A = (0, 1, 2, 3, 4)$であったとき、 $k=0$ : $B = (0, 1, 2, 3, 4)$ $k=1$ : $B = (1, 2, 3, 4, 0)$ $k=2$ : $B = (2, 3, 4, 0, 1)$ $k=3$ : $B = (3, 4, 0, 1, 2)$ $k=4$ : $B = (4, 0, 1, 2, 3)$ となる。 まずは転倒数について確認しておく。 転倒数とは、簡単に定義するなら、次の条件を満たす組$(i, j)$の個数である。 $i \u0026lt; j$ $B_i \u0026gt; B_j$ 言葉で言うなら、各要素に対しての「自分より左にいる、自分より大きなものの総数」の和である。 さて、操作によって転倒数がどう変化するかを考えよう。 操作は、「一番左の要素を一番右に持っていく」というものになっている。 これを行うと、全体の転倒数は次のように変化することがわかる。 動かした要素より小さい要素の数だけ転倒数が減る。 動かした要素より大きな要素の数だけ転倒数が増加する。 これは転倒数の定義からも簡単に確認できるだろう。 これで、操作1回によって転倒数がどれだけ変化するかはすぐ算出できることがわかった。 後は最初の数列の転倒数を求められればACできそうだ。 典型テク: 転倒数を$O(N \\log N)$で求める。 さて、数列$A$に対してナイーブに転倒数を求めるアルゴリズムを考えると、次のようなものになるだろう。 int InversionNumber = 0; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; i; j++) { if (A[j] \u0026lt; A[i]) InversionNumber++; } } これは明らかに$O(N^2)$で、間に合わない。 さてどうしよう。 実は、転倒数を$O(N \\log N)$で求めるアルゴリズムが存在する。 ここからその説明をする。 転倒数の定義から、次が成立する。 $$ \\begin{equation*} (転倒数) = \\sum_{i=0}^{N-1} ((j\u0026lt;i) ~ \\land ~ (A_i \u0026lt; A_j)を満たすjの数) \\end{equation*} $$ 少し寄り道をする。 まず、非負数列$B$に対して数列$C$を次のように定める。 $$ \\begin{equation*} C \\coloneqq \\{c_i\\}_{i=0}, ~ c_i = (数列Bに含まれるiの個数) \\end{equation*} $$ 具体例を挙げよう。 数列$(0, 1, 2, 3)$に対して、$C = (1, 1, 1, 1, 0, 0, \\dots)$であり、 数列$(1, 1, 3, 5, 7)$に対して、$C = (0, 2, 0, 1, 0, 1, 0, 1, 0, \\dots)$となる。 また、数列$B$に対して定められる数列$C$を$C_B$と表すことにする。 数列$A$の$i$項目から$j$項目までを順番を変えずに切り取った数列を、$A$の連続部分数列と呼び、 $A[i \\dots j]$と表すとする。 これらを用いて先程の転倒数の定義を言い換えると、次のようになる。 $$ \\begin{equation*} (転倒数) = \\sum_{i=1}^{N-1} \\sum c \\in ( C_{A[0 \\dots i-1]}[A_i+1 \\dots \\infty] ) \\end{equation*} $$ 式が最悪すぎるのには目をつぶってほしい\u0026hellip;数学に明るくなく、うまい定式化ができなかった。 さて、ここで$C_{A[0 \\dots i-1]}$については各ケースに対して1から求める必要は無く、 $C_{A[0 \\dots i-2]}$に$A_i$を含めてやればよいことがわかるだろう。 また、数列$C$は(数列$A$の最大値)番目以降は全て0になるため、そこで打ち切って良い。 したがって、各ケースで 「数列の要素を一つだけ変更する。新しく得た数列の$A_i+1$番目から最後までの総和を求めよ」という問題を解けば良い。 この問題は、数列の動的区間和を高速に求めるデータ構造(BITやSegment Tree)を用いることで解ける。 例えば、Segment Treeを使った場合、区間和の更新と取得で$O(\\log N)$かかるため、全体で$O(N \\log N)$になる。 以上で最初の一つの転倒数を$O(N \\log N)$で得ることができた。 補足: 本章では必要以上にややこしい説明を行っていますが、これは自分が後で見返したときのためです。 正直ググって他の資料をあたったほうがわかりやすいと思います。ごめんなさい。 実装例 import std; void main () { int N = readln.chomp.to!int; int[] a = readln.split.to!(int[]); solve(N, a); } void solve (int N, int[] a) { /* 転倒数 O(NlogN) */ auto RSQ = new SegmentTree!(int, (int a, int b) =\u0026gt; (a+b), () =\u0026gt; 0)(a.length); long[] ans = new long[](N); foreach (i; 0..a.length) { ans[0] += RSQ.prod(a[i]+1, a.length); RSQ.set(a[i], RSQ.get(a[i])+1); } /* 左端を右端に動かすとき、(もとの数列がわかれば)転倒数の変化は比較的簡単にわかるので、最初の一回を求められれば後はO(N) */ foreach (i; 1..N) { ans[i] = ans[i-1] - a[i-1] + (N-a[i-1]-1); } foreach (i; 0..N) writeln(ans[i]); } Segment Treeの実装は長いので省略した。 感想 自力でACできたのと、転倒数を$O(N \\log N)$で求めるアルゴリズムに触れたので良かった。 このように、「すでにわかっている結果から少しいじると他の解がわかる」 みたいなタイプの問題を落とさないようにしたい(3戦1勝2敗)。"
  },
  {
    url: "/post/abc235e/",
    title: "ABC235E、あるいはクエリ並列処理",
    date: "2023-10-31T00:00:00+09:00",
    body: "ABC235E、あるいはクエリ並列処理 問題概要 問題 辺の重みがすべて異なる無向連結グラフ$G$が与えられる。 さらに、クエリ$i$で$G$中のどの辺とも異なる重みをもつ辺$(u_i, v_i, w_i)$が与えられる。 クエリ$i$で与えられた辺を$G$に追加したグラフ$G\u0026rsquo;$を考える。 すべての$i$に対して、辺$(u_i, v_i, w_i)$は$G\u0026rsquo;$の最小全域木に含まれるか判定せよ。 制約 $2 \\leq N \\leq 2 \\times 10^5$ ($G$の頂点数) $N-1 \\leq M \\leq 2 \\times 10^5$ ($G$の辺数) $1 \\leq Q \\leq 2 \\times 10^5$ 考察と解法 クラスカル法を考えると、辺を重みと連結性で貪欲にとればよい。 したがって、一つのクエリに対して$O(N \\log N)$で答えることができる。 しかし、このままだと全体$O(QN \\log N)$で間に合わない。 高速化を考える。 一つ一つのクエリは最小全域木に含まれるかどうかのみを判定して、元のグラフ$G$に取り込まれないことを利用しよう。 クラスカル法によると、辺の重みでソートして、辺が結ぶ頂点がまだ連結でない場合にのみ辺を採用すればよい。 そこで、次のアルゴリズムを考える。 すべてのクエリを先読みして、もとからあった$M$個の辺と$Q$個の辺を重みでソートする。 クラスカル法に基づいて、辺を採用するかどうかを判定していく。 ただし、クエリで与えられた辺は採用できる場合でも採用しない。 これでうまくいく。 なぜなら、一つのクエリから見れば、ほかのクエリによる$Q-1$個の辺は必ず採用されないため、 グラフ$G$の連結性に影響を与えていないからだ。 時間計算量は$O((N+Q) \\log (N+Q))$となる。 実装例 import std; struct edge { int u, v; long w; int idx; } void main () { int N, M, Q; readln.read(N, M, Q); edge[] e = new edge[](M+Q); foreach (i; 0..M) { with (e[i]) { readln.read(u, v, w); u--, v--; idx = -1; } } foreach (i; 0..Q) { with (e[i+M]) { readln.read(u, v, w); u--, v--; idx = i; } } solve(N, M, Q, e); } void solve (int N, int M, int Q, edge[] e) { /* 解説AC クラスカル法を適用すればクエリ単品なら簡単に解ける。これをどうするか？ -\u0026gt; クエリ先読みして、全部の辺をまとめてソートしたうえでその辺を採用できるかどうかを見ると行ける。 */ e.sort!\u0026#34;a.w \u0026lt; b.w\u0026#34;; string[] ans = new string[](Q); auto UF = UnionFind!int(N+Q); foreach (ee; e) with(ee) { if (UF.areInSameGroup(u, v)) { if (idx == -1) continue; ans[idx] = \u0026#34;No\u0026#34;; } else { if (idx == -1) { UF.unite(u, v); continue; } ans[idx] = \u0026#34;Yes\u0026#34;; } } foreach (i; 0..Q) { writeln(ans[i]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } UnionFindの実装は長いので省いている。 典型テク: クエリ並列処理 今回の問題のように、あるクエリがほかのクエリに影響を与えない場合、 すべてのクエリを一斉に処理することで高速に解くことができる場合がある。 クエリが飛んでくる問題が来た時に一度は検討したい方針である。 発展 今回の問題は、別の解法もある。 クエリ$i$で$(u_i, v_i, w_i)$が来た時、 この辺が最小全域木に採用されるかどうかは、 $(u_i, v_i)$を結ぶパス(木なので、ちょうど一つ存在)に含まれる辺の最大重みが $w_i$より重いかどうかで判定することができる。 より具体的には、 もし$w_i$より重い辺が存在するなら、その辺をカットして、 $(u_i, v_i, w_i)$を採用することで全域木であることを保ちつつ、より総和が小さくなる。 そうでない場合は必ず総和が増える。 実は、この問題は解くことができる。(らしい) 詳しくは kyopuro_friendsさんの解説 に載っているが、 私はまだ理解できていないため、紹介にとどめる。 終わりに この発想は出なかった。次見たときには解けるようになりたい。"
  },
  {
    url: "/post/pgbattle2023/",
    title: "PG BATTLE 2023参加記録",
    date: "2023-10-23T00:00:00+09:00",
    body: "PG BATTLE 2023参加記録 \r始まりは突然に 10月9日に、やきとりさん(@yktr_drm06)から PG BATTLE に誘われて、 私、やきとりさん、ryotaさん(@95s7k84695a)のチームで参加することになりました。 このコンテストの存在は知っていたものの、学内に競技プログラミングをしている知り合いが存在しないため、どうしようか迷っていました。(最悪電通大競プロサークルのDiscordで募集かけようかと思っていた。) そんな時にお誘いいただいたので、ぜひ！ということで参加させていただきました。 メンバーが私よりも強い方なので、ラッキーだなとか思っていました(すいません。) PG BATTLEについて 普段はAtCoderのコンテスト及び類似のコンテストしか出ていないので、PG BATTLEのルールはちょっと新鮮でした。 要点は以下の通りです。 3人1チーム ひとりひとり解く問題が違う(配点は1/3ずつ) チーム内相談禁止 提出は一回のみ 総得点及び解答提出時間で勝負 ICPCですら提出は何回かできるので、プログラミングコンテストとしてはかなり珍しい方だなと思います。 問題は、ましゅまろ/せんべい/かつおぶしの三種類あり、誰がどの問題を解くかは事前に決めることができます。 私は二番目に簡単なせんべいを担当しました。 せんべい雑振り返り すべての問題は ここ で公開されています。 難易度2 積の符号 ちょっと前にTwitterで話題になっていた、注意力を要求するB問題みたいな雰囲気のする問題です。 符号を当てればよいので、全部掛け算する必要はなく、0があるかどうかで場合分けをすればよいです。 0がなければ、-の要素が偶数個か奇数個かでACできます。 import std; void main () { int N = readln.chomp.to!int; int[] A = readln.split.to!(int[]); int minus = false; A.sort; foreach (i; 0..N) { if (A[i] == 0) { writeln(0); return; } if (A[i] \u0026lt; 0) minus++; } if (minus % 2 == 0) { writeln(\u0026#34;+\u0026#34;); } else { writeln(\u0026#34;-\u0026#34;); } } 難易度3 ABCの個数 期待値を求める系の問題は大体よくわかってないので、 苦手問題来たーって思って身構えました。 ググって何とかならないかなーと思って、 「期待値の線形性」というキーワードで出てきた このサイト を見ていたら、 応用例2がまさにこの問題でした。ラッキー！ どうやら各部分で\u0026quot;ABC\u0026quot;が作れる確率を足し合わせればよいようです。 期待値の線形性ってこうやって使うんだなぁと勉強になったような気がします。 ただ、数学的理解が怪しいのでうーんという感じです。 import std; void main () { string S = readln.chomp; solve(S); } void solve (string S) { /* 期待値の線形性を使う */ /* 場所iをスタートにしてABCができる確率X_iとすると、解はE[Σ(X_i)] */ double ans = 0; foreach (i; 0..S.length) { if (S.length \u0026lt;= i+2) continue; if ((S[i] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i] != \u0026#39;A\u0026#39;) || (S[i+1] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+1] != \u0026#39;B\u0026#39;) || (S[i+2] != \u0026#39;?\u0026#39; \u0026amp;\u0026amp; S[i+2] != \u0026#39;C\u0026#39;)) continue; /* 確率0 */ int UnComfirmed = 0; for (int j = 0; j \u0026lt; 3; j++) if (S[i+j] == \u0026#39;?\u0026#39;) UnComfirmed++; ans += 1./(3^^UnComfirmed); } writefln(\u0026#34;%.10f\u0026#34;, ans); } 難易度4 距離K これは割とすぐ解法が見えました。 まずは数列を次のようにK個のグループに分けます。 $$\\mathrm{group}[i] \\coloneqq \\{ A[x] \\mid \\forall j, ~ x = i+jK \\}$$ 実は、操作によって入れ替わることができるのは同一グループに属する要素だけです。 簡単のため、ある一つのグループ以外を固定して考えます。 この時、数列Aは操作できるグループの「 同じものを含む順列 」通り数になります。 同様の議論をすべてのグループに適用することで、数列Aの変化先の総数は、 すべてのグループについての「同じものを含む順列」の総積であることが分かります。 式におこしましょう。$\\mathrm{group}[i]$が要素$x[j]$を$y[j]$個持つとすると、求める値は $$ \\prod_{i} \\frac{\\left( \\sum_{j} y[j] \\right)!}{\\prod_j (y[j]!)} $$ となります。$\\sum_{j}y[j] \\leq N$なので、 Nまでの階乗及びその逆元をを空間/時間$O(N)$で先に求めておけば、上の式を高速に求めることができます。 import std; void main () { int N, K; readln.read(N, K); int[] A = readln.split.to!(int[]); solve(N, K, A); } void solve (int N, int K, int[] A) { const long MOD = 998244353; /* 階乗前計算 */ long[] fact = new long[](N+1); long[] factInv = new long[](N+1); fact[0] = factInv[0] = 1; for (int i = 1; i \u0026lt;= N; i++) { fact[i] = i*fact[i-1] % MOD; factInv[i] = modInv(fact[i], MOD); } int[][] ModuloKGroups = new int[][](K, 0); foreach (i; 0..K) { if (N \u0026lt;= i) continue; int pos = i; while (pos \u0026lt; N) { ModuloKGroups[i] ~= A[pos]; pos += K; } } /* 最後にprodの総積をとる */ long[] prod = new long[](K); int[int] count; foreach (i; 0..K) { int ElemSize = cast(int) ModuloKGroups[i].length; foreach (m; ModuloKGroups[i]) count[m]++; prod[i] = fact[ElemSize]; foreach (key, val; count) { prod[i] *= factInv[val]; prod[i] %= MOD; } count.clear; } long ans = 1; foreach (i; 0..K) { ans *= prod[i]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } long modPow (long a, long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // simple case if (MOD == 1) { return 0L; } if (x == 0) { return 1L; } if (x == 1) { return a; } // calculate long res = 1L; long base = a % MOD; while (x != 0) { if ((x\u0026amp;1) != 0) { res *= base; res %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return res; } long modInv (long x, const int MOD) { import std.exception; enforce(1 \u0026lt;= MOD, format(\u0026#34;Line : %s, MOD must be greater than 1. Your input = %s\u0026#34;, __LINE__, MOD)); return modPow(x, MOD-2, MOD); } 難易度6 トリオ なんもわからん！こんなの無理だろ！と文句を言っていたらコンテストが終わりました。。。 chokudaiさんが解説を上げていたので見ましたが、これは本番解けるわけないな\u0026hellip;となりました。 しかし、一応状態$O(3^N)$までは見えていたので、悪くはないかな？ 終わりに チーム戦も面白いですね。 またこういうコンテストに出たいなぁと思いました。 チーム合計240点で割とよさげなので、なんか商品もらえるといいなぁ やきとりさん、ryotaさん、お誘いいただきありがとうございました。"
  },
  {
    url: "/post/functional-graph-cycle/",
    title: "Functional Graphのサイクル検出をいい感じに",
    date: "2023-10-13T00:00:00+09:00",
    body: "Functional Graphのサイクル検出をいい感じに はじめに グラフ表現に帰着できる問題を考察していると、Functional Graphと呼ばれるグラフのサイクル検出に帰着する場合があります。 本稿では、Functional Graphのサイクル検出の比較的簡単な実装を紹介します。 前提条件 本稿における、Functional Graphの定義は次のとおりです。 有向グラフであって、各頂点の出次数がちょうど1であるもの。 方法 まず、画像でイメージを掴んでもらいます。 これがFunctional Graphです。各頂点から一つだけ有向辺があるのが確認できると思います。 ここで、頂点{1, 2, 3, 4, 5}は閉路をなしていますが、それ以外は閉路に含まれていません。 これをどうやって検出するかが本題です。 UnionFind(dsu)を使います。 まず、Functional Graphの重要な性質に、連結成分がちょうど一つの閉路を持つというものがあります。 証明(厳密でない)\r連結成分が少なくとも一つの閉路を持つこと 頂点1つから考えて、まだ連結成分でない頂点へ有向辺を張ると、必ず連結成分のサイズが1増えます。 つまり、サイズkの連結成分を成す最小の有向辺はk-1本です。 一方、Functional Graphにおけるサイズkの連結成分は必ずk本の有向辺を持ちます。 これは、少なくとも1本はすでに連結である頂点へと有向辺を張っていることになり、閉路を含みます。 高々1つの閉路を持つこと あるFunctional Graphの連結成分が2つの閉路を持つと仮定します。 閉路が頂点を共有するとき 少なくとも2つの頂点が出次数2になり、違反します。 閉路が頂点を共有しないとき 閉路同士を結ぶ辺が必要ですが、このときに少なくとも1つの頂点が出次数2になり、違反します。 3以上も同様に証明できます(ほんとか？)。よって、閉路は高々1つです。 証明終わり。 UnionFindで連結成分を増やしていくと、どこかですでに同じ連結成分に属する頂点が見つかるはずです。 このとき見つかる頂点は、必ず閉路の中に入っている頂点になります。 Functional Graphにおける連結成分はちょうど一つだけ閉路を持ち、 出次数が必ず1であるため、閉路を構成する1頂点が見つかれば、 閉路に入っている他の全ての頂点もたどっていくだけで全て見つけることができます。 よって、以下のアルゴリズムを得ます。 以下、G[i]は頂点iに隣接する頂点を指す。 i=0,1,\u0026hellip;,Nに対して、次を行う。 頂点iと頂点G[i]が同じ連結成分に属していなければ、頂点iと頂点G[i]をマージして終了。同じ連結成分に属していれば、2に進む。 pos=iとして、再びpos=iとなるまでpos=G[pos]として更新する。 その途中でposに代入された頂点は、全て記録しておく。 記録された頂点は、一つの連結成分の閉路をなす頂点集合と一致する。 時間計算量はO(Nα(N))です。(α(N))はアッカーマン逆関数) また、本稿では詳しく紹介しませんが、強連結成分分解によって時間と空間O(N)を達成することもできます。 しかし、実装のコストは(強連結成分分解ライブラリがなければ)こちらのほうが軽いです。 どちらもおすすめです。 実装例 D言語による実装例を示します。 auto UF = UnionFind!int(); bool[int] NumberInCycle; foreach (i; 0..N) { if (!UF.is_same_group(i, A[i])) { UF.merge_group(i, A[i]); continue; } // 閉路検出 int cur = i; do { NumberInCycle[cur] = true; cur = A[cur]; } while (cur != i); } このコードを実行したあとにNumberInCycleに存在する要素は、Functional Graphのいずれかの連結成分における閉路を構成する頂点である。 練習問題 練習問題を3問用意しました。ぜひ解いてみてください。 1問はまさにこのアルゴリズムを用いる問題ですが、他の2問は考察部分があり、Functional Graphに帰着するのは自明ではないです。 なので、ネタバレが嫌だという方は1問目だけ解くと良いです。 ABC311C 解法\r状況設定はほとんど同じです。\r紹介したアルゴリズムを用いるだけで解くことができます。\rなお、この問題に関しては列を求める必要があるため、強連結成分分解よりもUnionFindの方が直接的に求められます。 ABC296E 解法\rこのゲームにおけるK_i回の操作は、Functional Graphにおける辺を移動していくことだとみなせます。\rそこで、もしこのグラフのある閉路に頂点iが含まれる場合、ゲームiにおいて任意のK_iに対して勝てる初期配置が存在します。 逆に、そうでないとき、十分に大きなK_iを指定するだけで必ず青木くんが勝てます。(例えば、K_i=10^9を考えてみてください。) すなわち、この問題はFunctional Graphの閉路に含まれる頂点の種類数を数える問題に帰着します。 ABC256E 解法\r人iから人X_iに有向辺を張ったグラフを考えます。すると、これはFunctional Graphになります。\rうまく順列を選ぶことで、必ず一つの連結成分あたり一人以外の不満度を0にすることができます。 連結成分は閉路をなしますから、全員を不満度0にはできません。 そこで、連結成分の誰を不満にするかを選ぶ問題に帰着します。 これは明らかに最小の不満度を取る貪欲法が有効です。 よって、Functional Graphの閉路に含まれる頂点を列挙する問題に帰着されました。 終わりに 本アイディアはABC256Eの nyaanさんの公式解説 で紹介されていたものです。"
  },
  {
    url: "/post/yuki407/",
    title: "yukicoder contest407参加記録",
    date: "2023-10-06T00:00:00+09:00",
    body: "yukicoder contest407参加記録 はじめに 本稿は2023-10-06に行われた yukicoder contest 407 の参加記録です。 戦績 雑振り返り A - napsack Problem? 問題へのリンク 重さW以下のナップサックのうち、容量の最大値を見ていくだけです。O(N) この人は単にデカいナップサックが欲しいだけみたいですね。 import std; void main () { int N, W; readln.read(N, W); int[] v = new int[](N); int[] w = new int[](N); foreach (i; 0..N) { readln.read(v[i], w[i]); } int ans = -1; foreach (i; 0..N) { if (w[i] \u0026lt;= W \u0026amp;\u0026amp; ans \u0026lt; v[i]) { ans = v[i]; } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } B - K-th in L2 with L1 問題へのリンク 結構問題文の読解が難しいと感じました。 ユークリッド距離がDであるような点は高々4D個になるので、 全部列挙 すべてに対するユークリッド距離を計算して配列に格納 良い点一つ一つについて、条件を満たすかどうか二分探索 でO(Dlog(D))だと思います。 import std; void main () { int Q = readln.chomp.to!int; foreach (_; 0..Q) { int D, K; readln.read(D, K); solve(D, K); } } void solve (int D, int K) { // マンハッタン距離Dの点集合を列挙 alias coord = Tuple!(int, \u0026#34;y\u0026#34;, int, \u0026#34;x\u0026#34;); bool[coord] DistanceDPoints; for (int i = 0; i \u0026lt;= D; i++) { int y = D-i; int x = i; DistanceDPoints[coord(y, x)] = true; DistanceDPoints[coord(y, -x)] = true; DistanceDPoints[coord(-y, x)] = true; DistanceDPoints[coord(-y, -x)] = true; } int[] dist; foreach (key, val; DistanceDPoints) { dist ~= key.y^^2 + key.x^^2; } dist.sort; // 二分探索 int f (int idx) { if (idx \u0026lt; 0) return -int.max; if (dist.length \u0026lt;= idx) return int.max; return dist[idx]; } foreach (key, val; DistanceDPoints) { int EuclidDist = key.y^^2 + key.x^^2; { int ok = 0, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt;= EuclidDist) { ok = mid; } else { ng = mid; } } if (ok+1 \u0026lt; K) continue; } { int ok = -1, ng = cast(int) dist.length; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (f(mid) \u0026lt; EuclidDist) { ok = mid; } else { ng = mid; } } if (K \u0026lt;= ok+1) continue; } writeln(\u0026#34;Yes\u0026#34;); writeln(key.x, \u0026#34; \u0026#34;, key.y); return; } writeln(\u0026#34;No\u0026#34;); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } おそらくかなり無駄の多い実装になっています。 こういうの結構苦手より。 C - Sum within Components 問題へのリンク 連結成分を列挙していくだけです。 visited[i]をboolにするのではなく、iを含む連結成分の総和が配列の何番目に入っているか？ という情報を入れておくことで、最後x=1, 2, \u0026hellip;, Nについての問題をO(1)で解けます。 割と明らかな問題な気がします。Bより簡単でした。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); int[][] graph = new int[][](N, 0); foreach (_; 0..M) { int U, V; readln.read(U, V); U--, V--; graph[U] ~= V; graph[V] ~= U; } solve(N, M, A, graph); } void solve (int N, int M, int[] A, int[][] graph) { // 連結成分を列挙していけばよいですね～ const long MOD = 998244353; int[] visited = new int[](N); DList!int Q; long[] SumOfComponent; int idx = 0; visited[] = -1; foreach (i; 0..N) { if (visited[i] != -1) continue; visited[i] = idx; Q.insertBack(i); SumOfComponent ~= A[i]; SumOfComponent[idx] %= MOD; while (!Q.empty) { auto head = Q.front; Q.removeFront; foreach (to; graph[head]) { if (visited[to] != -1) continue; visited[to] = idx; (SumOfComponent[idx] += A[to]) %= MOD; Q.insertBack(to); } } idx++; } long ans = 1; foreach (x; 0..N) { ans *= SumOfComponent[ visited[x] ]; ans %= MOD; } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Three Sets 問題へのリンク 式いかつ過ぎです。 |S|は必ず非負整数なので、ΣAとかはなるたけでかい方が良いです。 したがって、部分集合といいつつ、要素を削るなら小さいものから削るのが最適なことが分かります。 これで各列から何個整数を持ってくるかを全探索できます。 累積和を用いてO(N3)です。 全く間に合いませんが、これ以上はわかりませんでした。 import std; void main () { // なるたけどれもデカいほうが良い。部分集合といいつつ、削るなら最小要素から削るべき(要素数は負にならないので、できるだけでかい方がお得) // O(N^3)しかわからんけど... int[3] N; int[][3] X; readln.read(N[0], N[1], N[2]); X[0] = readln.split.to!(int[]); X[1] = readln.split.to!(int[]); X[2] = readln.split.to!(int[]); solve(N, X); } void solve (int[3] N, int[][3] X) { // O(N^3) foreach (ref x; X) x.sort!\u0026#34;a\u0026gt;b\u0026#34;; int[][3] sum; foreach (i, ref s; sum) s = new int[](N[i]+1); foreach (idx, ref s; sum) foreach (i, ref ss; s) { if (i == 0) { ss = 0; continue; } ss = s[i-1] + X[idx][i-1]; } long ans = -long.max; for (int i = 0; i \u0026lt;= N[0]; i++) for (int j = 0; j \u0026lt;= N[1]; j++) for (int k = 0; k \u0026lt;= N[2]; k++) { ans = max(ans, sum[0][i]*j + sum[1][j]*k + sum[2][k]*i); } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } E以降 Dが解けていないのであまり見ていません。 終わりに yukicoderいつも難しくて良くて3問か4問までしか解けません。"
  },
  {
    url: "/post/mod-division-tech/",
    title: "割れるし割りたいのに割れない数を割る方法",
    date: "2023-10-05T00:00:00+09:00",
    body: "割れるし割りたいのに割れない数を割る方法 状況設定 $x, ~ y, ~ z \\in \\mathbb N$ $x\\%y = 0$ $1 \u0026lt; \\mathrm{gcd}(y, z)$ $x$は陽に求められないほど大きく、$y$、$z$は常識的な大きさ 問題 $xy^{-1}$を$z$で割った非負最小剰余を求めよ。 何が厳しいのか $\\mathrm{gcd}(y, z) = 1$が満たされていれば話は終了です。 なぜなら、このような$y$は$\\mathrm{mod} ~ z$上で逆元を持つからです。 普通に拡張ユークリッドの互除法などを用いれば答えられます。 問題はそうでない時です。 この時、$y$は逆元を持ちませんから、先に$\\dfrac{x}{y}$を計算したくなります。 しかし、$x$はデカいので、陽に求めるのは無理です。 さてどうしましょう？ 解答 結論から言います。$\\mathrm{mod} ~ yz$上で考えるとうまくいきます。 もう少し具体的には、次の手順を踏むことで答えることができます。 $x ~ \\mathrm{mod} ~ yz$を求める。 それを$y$で割る。 正当性を追っていきます。 除法定理より、次を満たす整数$q, ~ r$の組がただ一つ存在します。 $x = q(yz) + r$ $0 \\leq r \u0026lt; yz$ ちなみに$r = x ~ \\mathrm{mod} ~ yz$です。 ここで、$x\\%y = 0$を仮定しているので、必ず$r\\%y = 0$となっています。 両辺$y$で割ります。 $$ \\begin{equation} \\frac{x}{y} = qz + \\frac{r}{y} \\end{equation} $$ です。 ここから少し定義に戻って確認します。 $\\dfrac{x}{y} ~ \\mathrm{mod} ~ z$を求めるとは $$ \\begin{equation} \\dfrac{x}{y} = q\u0026rsquo;z + r\u0026rsquo; ~ \\left( 0 \\leq r\u0026rsquo; \u0026lt; z \\right) \\end{equation} $$ なる$r\u0026rsquo;$を求めることです。 ここで、除法定理よりこのような整数の組$(q\u0026rsquo;, r\u0026rsquo;)$はただ一つに定まります。 さて、式(1)を見てみましょう。 $0 \\leq r \u0026lt; yz$でありますから、$0 \\leq \\dfrac{r}{y} \u0026lt; z$であることが分かります。 式(2)と見比べてみましょう。$r\u0026rsquo; = \\dfrac{r}{y}$となっていることが確認できます。 なんということでしょう。求めることができてしまいました。除法定理が強力すぎますね。 応用例 実際にこのテクニックを使える問題を2問紹介します。 ARC111A - Simple Math 2 解法\r$10^N = qM + r ~ (0 \\leq r \u003c M)$と表すと、\r$\\left\\lfloor \\dfrac{10^N}{M} \\right\\rfloor = \\left\\lfloor \\dfrac{qM + r}{M} \\right\\rfloor = q$\rであるから、解は$q\\%M$です。\rこれをもとに変形していきます。\r$$ qM = 10^N - r $$ $$ q = \\frac{10^N-r}{M} $$ ここまで変形すると今回のテクニックに帰着します。 求めたいのは$q ~ \\mathrm{mod} ~ M$ですが、$M$は$\\mathrm{mod} ~ M$上で逆元を持ちません。 また、$10^N-r$も大きすぎて陽に求めるのは無理です。 そこで、$(10^N - r) ~ \\mathrm{mod} ~ M^2$を計算してから最後に$M$で割ってやるとうまくいきます。 実装例(一部抜粋) void solve (long N, int M) { // 10^N = qM + r (0\u0026lt;=r\u0026lt;M) を得たとき、解はq%M // 両辺Mで剰余をとってみると、 (10^N)%M = r%M // 条件より、(10^N)%M = r // 典型テク: mod MK (Mは最後に求めたい剰余、Kは割りたいけど法と互いに素でない数) で考える。 long ans = modPow(10, N, M^^2); ans -= modPow(10, N, M); if (ans \u0026lt; 0) { ans += M^^2; } ans /= M; writeln(ans); } ABC293E - Geometric Progression 解法\r解法がたくさんありますが、kyopro_friendsさんのユーザー解説と同じ方法です。\r丁寧に式変形を追っていきます。 $S(x) \\coloneqq \\displaystyle\\sum_{i=0}^{x}A^i$と定めます。 $0 \\leq N$を用いて、 $$ \\begin{alignat*}{3} A \\times S(N) \u0026amp;= \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N + A^{N+1} \\\\ S(N) \u0026amp;= A^0 + \u0026amp;\u0026amp;A^1 + A^2 + \\cdots + A^N-1 + A^N \\\\ \\end{alignat*} $$ が成立します。そこで、 $$ A \\times S(N) - S(N) = A^{N+1} - A^0 $$ となります。$S(N)$でくくると、 $$ (A-1) \\times S(N) = A^{N+1} - 1 $$ です。$A-1 \\neq 0$ならば、両辺を割れて、 $$ S(N) = \\frac{A^{N+1}-1}{A-1} $$ を得ます。 さて、今回求める値は$S(X-1) ~ \\mathrm{mod} ~ M$にほかなりません。$A-1 \\neq 0$のとき、$0 \\leq X-1$なので、上式を適用できます。 $$ S(X-1) = \\frac{A^X-1}{A-1} $$ ここで、$A-1$は$\\mathrm{mod} ~ M$上で逆元を持つとは限りません。今回のテクを使いましょう。 つまり、$\\mathrm{mod} ~ M(A-1)$で考えるとうまくいきます。 注意点として、この値は法としてはかなり大きくなる(それでも十分常識の範囲ですが)ので、 計算途中で64bit整数型を超える可能性が高いです。128bit整数や、多倍長整数を使いましょう。 多倍長整数とはいえ、そこまで桁数は大きくならないので十分高速です。 よくわからない人はpythonを使うとよいです。 また、$A-1 = 0$の時はすべての項が1になるため、簡単に計算できます。 実装例(一部抜粋) void solve (int A, long X, int M) { // 解は (A^x - 1) / (A - 1) // 場合分けが必要なケース if (A == 1) { writeln(X%M); return; } BigInt a = A, x = X, m = M; BigInt ans = std.bigint.powmod(a, x, m*(a-1)) - 1; if (ans \u0026lt; 0) ans += m*(a-1); ans /= A-1; writeln(ans); } 補足 問題2の解法説明で、 「逆元を持つとは限りません」と書きましたが、逆元を持っていてもよいことに注意してください。 正当性の証明のパートを見ればわかるように、法と除数の関係性は正当性を示すのに用いていないためです。 もちろん$\\mathrm{gcd}(M, A-1)$を計算して、逆元を持つ場合はそちらを経由するという方法でも解けます。 また、問題2に関しては、行列累乗による$O(\\log(X))$解法や、平方分割による解法など勉強になる解法がたくさん紹介されています。 余裕のある人はぜひ学んでみてください。(ちなみに私は学べてないです。コーナーで差をつけろ！) 終わりに いつかまとめようと思っていたネタです。 ほんの思い付きで書き始めたつもりが約2時間たっていて現在深夜1時です。 助けてくれ。 このアイディア自体はまさに上で紹介したABC293Eのユーザー解説から得たものです。 かなり行間が広いと感じたので、そこを埋める目的で作りました。 なので、この主張がどこまで一般化できるのかなどは私はわかっていません。 誤りがありましたら指摘していただければありがたいです。"
  },
  {
    url: "/post/floyd-warshall/",
    title: "ワーシャル・フロイド法について調べて、納得したこと",
    date: "2023-10-02T00:00:00+09:00",
    body: "ワーシャル・フロイド法について調べて、納得したこと はじめに 辺に任意の重みがある$N$頂点有向グラフ(ネットワーク)において、負の長さの閉路が存在しないとき、 全点対の最短経路を$O(N^3)$時間で求めるワーシャル・フロイド法と呼ばれるアルゴリズムが存在する。 本稿では、筆者がワーシャル・フロイド法について調べ、理解したことを記録する。 ワーシャル・フロイド法でできるもの 負閉路が存在しないネットワークにおいて、任意の2頂点間の最短経路を求める。 頂点数を$N$としたとき、空間$O(N^2)$と時間$O(N^3)$を要する。 アルゴリズムの詳細 以降、頂点のインデックスは0を基準とする。 また、頂点iから頂点jへの辺の重みを$w_{i,j}$とする。 $\\mathrm{dist}[i][j]:=$「頂点iから頂点jへの最短経路」とする。 最初、$\\mathrm{dist}[i][j]$を次のように初期化する。 $$ \\mathrm{dist}[i][j] = \\begin{cases} w_{i,j} \u0026amp; \\text{if ~ $i$から$j$への辺が存在,}\\\\ \\infty{} \u0026amp; \\text{if ~ $i$から$j$への辺が存在しない,} \\\\ 0 \u0026amp; \\text{if ~ $i = j$.} \\end{cases} $$ $k = 0, 1, \\cdots{} N-1$に対して、順に次の手順を行う。 全ての$0 \\leq{} i, ~ j \\leq{} N-1$の組に対して、 $$ \\mathrm{dist}[i][j] \\leftarrow{} \\min{}(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k] + \\mathrm{dist}[k][j]) $$ 以上を終えたとき、$\\mathrm{dist}[i][j]$は頂点iから頂点jへの最短経路長が入っている。 アルゴリズムの説明 下準備として、与えられたネットワークの辺が存在しない頂点対には距離無限大の辺が存在するとみなす。 こうすると、N頂点有向完全グラフになる。 そして、到達可能性を距離が有限であるかどうかで判定するとする。 このアルゴリズムは次の部分問題を用いた動的計画法とみなせる。 番号k以下の頂点のみを経由するとき、頂点iから頂点jへの最短経路はいくらか？ この問題が解けるとすると、k=N-1の問題に対する解が求めたい解そのものである。 このアルゴリズムを理解する鍵は、あるkとk+1における問題を考えることであると思う。 適当なkに対して問題を考える。 頂点iから頂点jへの最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j k+1に対して問題を考える。 kに対する問題が解けているという仮定のもとで議論を進める。 このとき、新しく最短経路となりうるのは、途中経路に頂点k+1を含むものに限られる。 (なぜなら、k以下に限った解は上の部分問題で解けているから) つまり、最短経路は次のような構造になっている。 頂点i -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点k+1 -\u0026gt; (頂点i, jを除いたk以下の頂点集合の部分集合の順列) -\u0026gt; 頂点j ここで、負閉路が存在しないことを仮定しているため、 上の経路が最短になるのは、i-\u0026gt;k+1とk+1-\u0026gt;jの経路が最短になるときである。 なぜなら、そうでない場合は経路を最短のものに変えることで距離を必ず改善できるからである。 さて、i-\u0026gt;k+1とk+1-\u0026gt;jの最短経路は、kに対しての部分問題を解いたときにすでに解けていることに気づくだろうか？ わからない人は、部分問題の設定を見直してみてほしい。 したがって、k+1における問題は $$ \\mathrm{dist}[i][j] = \\min(\\mathrm{dist}[i][j], ~ \\mathrm{dist}[i][k+1] + \\mathrm{dist}[k+1][j]) $$ という遷移で解けることがわかる。 まとめ ここまで分かったことをまとめる。 解きたい問題は、k=N-1のときの部分問題である。 kに対して問題が解けるならば、k+1に対して問題が解ける。 あと必要なのは、一番最初のケースを解けるのか？ということである。 k=-1を考える。 これは、始点と終点以外の頂点を一切経由しないときの最短経路問題であり、この部分問題のベースケースである。 この問題は明らかに頂点iから頂点jへ辺が存在するかどうかを見るだけで解くことができる。 以上より、帰納的に問題が解けることが理解できる。 負閉路が存在するとき 負閉路が存在するとき、そこを通ることができる経路に対する最短経路はいくらでも縮めることができる。 しかし、このときワーシャル・フロイド法は$-\\infty$を返さないことがあり得る。(というか、まず$-\\infty$にはならない) 遷移を見ればわかるとおり、ワーシャル・フロイド法により求まるのは最短「パス」であるからである。 つまり、真の最短経路が閉路を含む(同じ頂点を2回以上通る)ものは正しく結果を求めることができない。 追記(2023-10-05) 以下、 アルゴリズムロジック からの情報を追加します。 疲れているときに書いたので、普段以上に内容が怪しいかもしれません。ご注意ください。 負閉路の検出 負閉路が含まれているとき、閉路中の任意の一つの頂点をiとする。すると、iからiへの最短パスは総和が最小となる負閉路をぐるっと一周回ったものが採用される。 負閉路がない時、$\\mathrm{dist}[i][i] = 0$となるはずなので、これを用いて$O(N)$で検出できる。 bool hasNegativeCycle () { for (int i = 0; i \u0026lt; N; i++) { if (dist[i][i] \u0026lt; 0) return true; } return false; } 最短距離の一つを復元 $\\mathrm{prev}[i][j] \\coloneqq$ ($i$から$j$への最短経路で、$j$の一つ前にいた頂点) とすると、空間$O(N^2)$を用いて復元できる。 $\\mathrm{prev}$は$\\mathrm{dist}$と一緒に更新するとよい。 $\\mathrm{prev}$の初期値は次のようになる。 $$ \\mathrm{prev}[i][j] \\coloneqq \\begin{cases} i \u0026amp; \\text{if $(i = j) \\lor (iからjへ辺が存在する)$,} \\\\ -1 \u0026amp; \\text{otherwise.} \\end{cases} $$ -1は異常値として採用しています。 更新は、$\\mathrm{dist}$と一緒に行います。 for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max \u0026amp;\u0026amp; dist[i][k] + dist[k][j] \u0026lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; prev[i][j] = prev[k][j]; } } } 復元は次のようになります。 int[] restorePath (int start, int end) { if (prev[start][end] == -1) return []; int[] res; int cur = end; while (cur != start) { res ~= cur; cur = prev[start][cur]; } res ~= start; res.reverse; return res; } 実装例 次の問題に回答するD言語によるコードを示す。(本問題はワーシャル・フロイド法を用いなくても解けるが、簡単のため採用した。) 問題 頂点$U$から頂点$V$への最短経路を出力せよ。到達不能である場合、-1を出力せよ。 入力形式 N M\rU V\ru_1 v_1 w_1\ru_2 v_2 w_2\r.\r.\r.\ru_M v_M w_M\rimport std; void main () { /* input N, M */ int N, M; readln.read(N, M); int U, V; readln.read(U, V); U--, V--; // 0-indexed /* difine dist[][] */ int[][] dist = new int[][](N, N); foreach (i; 0..N) foreach (j; 0..N) dist[i][j] = int.max; foreach (i; 0..N) dist[i][i] = 0; /* input all edge */ foreach (_; 0..M) { int u, v, w; readln.read(u, v, w); u--, v--; dist[u][v] = w; } solve(N, M, U, V, dist); } void solve (int N, int M, int U, int V, int[][] dist) { /* Floyd-Warshall Algorithm */ for (int k = 0; k \u0026lt; N; k++) { for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) { if (dist[i][k] \u0026lt; int.max \u0026amp;\u0026amp; dist[k][j] \u0026lt; int.max) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } /* output */ if (dist[U][V] \u0026lt; int.max) { writeln(dist[U][V]); } else { writeln(-1); } } ジャッジはないし、veryfyもないです。何ならコンパイルすらしてないので間違っているかもしれないですが、参考程度でお願いします。 練習問題 本記事を読んだ方は、ぜひ挑戦してみてほしい。 大抵の場合、全点対最短距離に帰着するまでのパートはかなり明らかなことが多いので、ネタバレはそこまで問題ではないと思う。 ABC208D ABC79D 参考文献 浅野 孝夫. グラフ・ネットワークアルゴリズムの基礎 数理とCプログラム(初版). 近代科学社, 2017. 様々なグラフアルゴリズムを簡潔に紹介しています。グラフ理論による厳密な証明などは比重が小さく、数学系でない人も気軽に内容を浚える本だと思います。 rp523. \u0026ldquo;ワーシャルフロイド法がなぜうまくいくのか、改めて考えてみる\u0026rdquo;. qiita. 2022. https://qiita.com/rp523/items/8fba3882c4a6ea203757 , (2023-10-02閲覧). この動的計画法がどのようにして状態を圧縮しているのかを丁寧に説明しています。 吉田 雄真. \u0026ldquo;参考文献の書き方\u0026rdquo;. 新潟大学付属図書館. 2021. https://www.lib.niigata-u.ac.jp/learning_support/doc/20210709-3.pdf , (2023-10-02閲覧). 参考文献リストはこの文献を参考に書きました。"
  },
  {
    url: "/post/abc322/",
    title: "ABC322参加記録",
    date: "2023-09-30T00:00:00+09:00",
    body: "ABC322参加記録 はじめに 本稿は、2023/09/30に行われた ABC322 の参加記録です。 戦績 今回の提出状況は次の通りです。 AからDまでの5完でした。パフォーマンス1480で、レーティング変化は1195 =\u0026gt; 1227でした。 所感 遂に水色乗れました。うれしいです。 今回はDEがかなり実装が大変でした。 D問題TLEしてしまって、あきらめそうになりましたが、定数倍高速化をいろいろやってみたら通りました。 E問題はあまり賢くない実装方針をとってしまいかなり大変でしたが、何とか通せてよかったです。 解法 A - First ABC2 問題へのリンク nの定義域が明示されているのは楽でいいですね。 前から力任せ法で見ていけば十分高速です。 スライスがある言語なら、スライスを用いるとちょっと楽かもしれないです。 import std; void main () { int N = readln.chomp.to!int; string S = readln.chomp; solve(N, S); } void solve (int N, string S) { foreach (i; 0..S.length-2) { if (S[i..i+3] == \u0026#34;ABC\u0026#34;) { writeln(i+1); return; } } writeln(-1); } B - Prefix and Suffix 問題へのリンク SがTの接頭辞であるかどうか？とSがTの接尾辞であるか？を判定する方法があればif文で解けます。 N、Mは十分小さい上、制約でSの長さはT以下であることが保証されているので、全部言われたとおりに見ていけばよいです。 実装ではスライスを用いていますが、普通にfor文回しても解けます。 この場合、関数化するとちょっと楽だと思います。 import std; void main () { int N, M; readln.read(N, M); string S = readln.chomp; string T = readln.chomp; solve(N, M, S, T); } void solve (int N, int M, string S, string T) { int ans = 3; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 0; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] == S \u0026amp;\u0026amp; T[$-S.length..$] != S) ans = 1; if (S.length \u0026lt;= T.length \u0026amp;\u0026amp; T[0..S.length] != S \u0026amp;\u0026amp; T[$-S.length..$] == S) ans = 2; writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - Festival 問題へのリンク 二分探索を用いてi\u0026lt;=Ajが初めて成立するポイントを探します。 AM=Nなので、境界を多少雑に扱っても解けます。 普段ならAM\u0026lt;iである可能性があるので、判定関数をA[M\u0026lt;x]=infとするのですが、今回は必要ないです。 import std; void main () { int N, M; readln.read(N, M); int[] A = readln.split.to!(int[]); solve(N, M, A); } void solve (int N, int M, int[] A) { bool f (int i, int x) { return i \u0026lt;= A[x]; } for (int i = 1; i \u0026lt;= N; i++) { int ok = M-1, ng = -1; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng)/2; if (f(i, mid)) ok = mid; else ng = mid; } writeln(A[ok]-i); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } D - Polyomino 問題へのリンク 少し大きな台紙を用意して、はみだし、かぶりのないように張り付けて条件を満たすかを見ていく全探索をしました。 3つあるミノのうちの1つは向きを固定してよいため、そこで少し高速化しています。 1300msかかってるの私だけっぽいので、もう少しマシな解き方を復習しようかなと思います。 import std; void main () { char[][][] mino = new char[][][](3, 4, 0); foreach (i; 0..3) foreach (j; 0..4) mino[i][j] = readln.chomp.dup; solve(mino); } void solve (char[][][] mino) { char[][] field = new char[][](12, 12); void AllClear () { foreach (ref f; field) f[] = \u0026#39;.\u0026#39;; } bool isOver () { foreach (i, ff; field) foreach (j, f; ff) { if (f == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (i \u0026lt; 4 || 8 \u0026lt;= i || j \u0026lt; 4 || 8 \u0026lt;= j)) return true; } return false; } bool paste (int idx, int i, int j) { foreach (y; i..i+4) foreach (x; j..j+4) { if (mino[idx][y-i][x-j] == \u0026#39;.\u0026#39;) continue; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;#\u0026#39;) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; (y \u0026lt; 4 || 8 \u0026lt;= y || x \u0026lt; 4 || 8 \u0026lt;= x)) return false; if (mino[idx][y-i][x-j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; field[y][x] == \u0026#39;.\u0026#39;) field[y][x] = \u0026#39;#\u0026#39;; } //return !isOver(); return true; } bool check () { int count = 0; foreach (i, ff; field) foreach (j, f; ff) if (f == \u0026#39;#\u0026#39;) count++; return count == 16; } // 始点縦と横 foreach (i1; 0..7) foreach (j1; 0..7) { // 1ピースは向き確定でもよい。 //foreach (_1; 0..4) { mino[0] = mino[0].rotate; foreach (i2; 0..7) foreach (j2; 0..7) foreach (_2; 0..4) { mino[1] = mino[1].rotate; foreach (i3; 0..7) foreach (j3; 0..7) foreach (_3; 0..4) { mino[2] = mino[2].rotate; AllClear(); if (paste(0, i1, j1) \u0026amp;\u0026amp; paste(1, i2, j2) \u0026amp;\u0026amp; paste(2, i3, j3) \u0026amp;\u0026amp; check()) { writeln(\u0026#34;Yes\u0026#34;); return; } } } } writeln(\u0026#34;No\u0026#34;); } char[][] rotate (char[][] X) { if (X.length == 0) return []; char[][] res = new char[][](X[0].length, X.length); foreach (i; 0..X.length) foreach (j; 0..X[i].length) res[$-j-1][i] = X[i][j]; return res; } E - Product Development 問題へのリンク こういうのは大抵貪欲は無理だと相場が決まっています。また、とるかとらないかのO(2N)全探索もNが少し大きすぎます。 そこで、パラメータの取りうる値が小さいことに着目します。 一つのパラメーターに対して、P以上になったものはすべて同一視してよいため、本質的に区別すべき状態はパラメーターがP未満のもののみです。 いくつかの開発案を採択したとき、ありうる状態はパラメーター1つあたり0からPまでのP+1通りになり、パラメーターがK個独立に存在するので、(P+1)K通りになります。 これを持ちながら多次元部分和問題のようなことをやります。 私は全ケースK=5に帰着させて解きました。具体的には、K\u0026lt;jであってAi,jが存在しない時、Ai,j=Pと定義してあります。 こうすることで、本来存在しない架空のパラメータを一つ以上の開発案をとれば必ず達成できるとみなしています。 こういうdpは、多次元空間をイメージするよりも「ノードの識別子(一意に特定するために必要なタグ)がK種類ある」という理解が良いと思います。 一応この手のdpは過去にたくさん出題例があります。 その一部を紹介します。 ABC219D yukicoder No.2317 import std; void main () { int N, K, P; readln.read(N, K, P); int[] C = new int[](N); int[][] A = new int[][](N, 0); foreach (i; 0..N) { int[] input = readln.split.to!(int[]); C[i] = input[0]; A[i] = input[1..$]; } solve(N, K, P, C, A); } void solve (int N, int K, int P, int[] C, int[][] A) { long[][][][][][] dp = new long[][][][][][](N+1, P+1, P+1, P+1, P+1, P+1); // dp[i][j][k][l][m] := (i, j, k, l, m)を達成できる最小コスト(ただし、パラメータ=5は達成できている) foreach (dim; 0..N+1) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) dp[dim][i][j][k][l][] = long.max; dp[0][0][0][0][0][0] = 0; int f (int[] a, int idx) { if (idx \u0026lt; a.length) return a[idx]; return P; } foreach (dim, a; A) foreach (i; 0..P+1) foreach (j; 0..P+1) foreach (k; 0..P+1) foreach (l; 0..P+1) foreach (m; 0..P+1) { if (dp[dim][i][j][k][l][m] == long.max) continue; // とる dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)] = min(dp[dim][i][j][k][l][m] + C[dim], dp[dim+1][min(f(a, 0) + i, P)][min(f(a, 1) + j, P)][min(f(a, 2) + k, P)][min(f(a, 3) + l, P)][min(f(a, 4) + m, P)]); // とらない dp[dim+1][i][j][k][l][m] = min(dp[dim+1][i][j][k][l][m], dp[dim][i][j][k][l][m]); } if (dp[N][P][P][P][P][P] == long.max) { writeln(-1); } else { writeln(dp[N][P][P][P][P][P]); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 急いで解いたので、一部コメントが間違っています。そもそももう少しましな方針があるので、そちらを参考にすべきです。 終わりに 最近レーティングに取り憑かれている実感があったので、とりあえず水色に乗って一区切りつけることができてよかった。 純粋にProblem Solvingを楽しめるように努力したいと思った。プロコンを嫌いにならないためにも。"
  },
  {
    url: "/post/abc270e/",
    title: "ABC270E - Apple Baskets on Circle",
    date: "2023-09-26T00:00:00+09:00",
    body: "ABC270E - Apple Baskets on Circle 問題概要 問題へのリンク 円環状に並べてある$1$から$N$の番号が付いた$N$個のかごがある。 かごは$1$から$N$まで順番に並んでおり、かご$N$の隣にはかご$1$がある。 かご$i$にはりんごが$A_i$個入っている。 高橋君は、以下の行動を繰り返す。 目の前にあるかごの中にりんごがあれば$1$個かごから取り出して食べる。その後、りんごを食べたかどうかにかかわらず、右隣のかごの前に移動する。 高橋君がちょうど$K$個のりんごを食べた時点で、各かごに入っているりんごの数を求めよ。 制約 $1 \\leq{} N \\leq{} 10^5$ $0 \\leq{} A_i \\leq{} 10^{12}$ $1 \\leq{} K \\leq{} 10^{12}$ $K \\leq{} \\sum A_i$ 解法 $K$の値が非常に大きいため、高橋君の動きをシミュレートすることはできない。 そこで、高橋君の動きを少しずつまとめよう。 例えば、ある時点において$0$個を除いたりんごの最小値が$x$個であって、かつ$1$個以上のりんごが入ったかごが$y$個であったとする。 この時、少なくとも$x$周している間は$y$は一定になるはずであるから、素直にシミュレートすると$x$周必要なところを$1$周にまとめることができる。 $x$周しても$A_i$における大小関係は逆転しない($A_i \u0026lt; A_j$が$A_i = A_j$になることはあるが、$A_i \u0026lt; A_j$が$A_j \u0026lt; A_i$となることはない)ので、次の最小値$x$を容易に計算することができる。 また、$x$周している間に$K$個を超えてしまうときは、$K$個を超えないで何周できるかを計算するとよい。 具体的には、今まで食べたりんごを$\\mathrm{sum}$として、$\\lfloor{} (K-\\mathrm{sum})/y \\rfloor{}$とすればよい。 最後の一周は高々$N$回の操作で終わるので、シミュレートすればよいだろう。 そこで、次の解法を得る。 解法1 詳しいアルゴリズムは言語による説明よりもソースを見る方が早いかと思うので、D言語による実装を掲載する。 Remainingはその時点で$0$個以上のりんごが入っているかごの数である。 また、現時点で最小のりんごの数を得るために優先度付きキューを利用している。 これは上で説明した大小関係が保存されることを利用している。 void solve (int N, long K, long[] A) { long sum = 0; long Remaining = 0; foreach (a; A) if (0 \u0026lt; a) Remaining++; BinaryHeap!(pair[], \u0026#34;b.val \u0026lt; a.val\u0026#34;) PQ = []; foreach (i, a; A) PQ.insert(pair(cast(int) i, a)); while (sum \u0026lt; K) { auto head = PQ.front; PQ.removeFront; with (head) { if (A[idx] == 0) continue; if (K \u0026lt;= sum + Remaining) { // 一周とれば終了 int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } break; } if (sum + Remaining \u0026lt; K) { // A[idx]が最小なので、これを上限にして、できるだけとる long take = min(A[idx], (K-sum)/Remaining); sum += Remaining*take; foreach (ref a; A) if (0 \u0026lt; a) { a -= take; if (a == 0) Remaining--; } } } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } この解法は確かに正しい解を得るが、実は$\\text{worst} ~ O(N^2)$となっている。(筆者はこれに気づかずに2TLEした。) 例えば$A_i = i$であって、$K = \\sum A_i$であるときがこのケースに当たる。 更新が$N$行われて、かつ更新一回で$O(N)$回の操作が必要であるからだ。 素直にシミュレートするよりはかなり高速化したが、これでは間に合わない。 解法2 さて、少し突飛な発想であるかもしれないが、$x$周したときに何個りんごをとれるかを考えよう。 $x$個に満たないかごからは$A_i$個までしかとれないので、$\\sum \\min{} (x, A_i)$個ということになる。 この値は$x$に対して(適切な区間で)狭義単調増加する。 すると、この値が$K$を超えるかどうかで二分探索ができることが分かる。 要するに、何周までなら$K$を超えないのかを高速に求めることができる。 最後の一周は素直にシミュレートすればよいので、これで解ける。 時間計算量は$O(N \\log{} (\\max{} A_i))$である。 以下にD言語による実装例を載せる。 void solve2 (int N, long K, long[] A) { // A[i]からとれるならX個とるとするとき、その総和がKを超えるかどうかで二分探索 // 二分探索: f(x) := sum( min(x, A[i]) ) に対して、f(ok) \u0026lt;= K \u0026lt; f(ng) // ok \u0026lt;- [0, max(A)] long f (long x) { long sum = 0; foreach (a; A) sum += min(x, a); return sum \u0026lt;= K; } long ok = 0, ng = 10L^^12+1; while (1 \u0026lt; abs(ok-ng)) { long mid = (ok+ng)/2; if (f(mid)) { ok = mid; } else { ng = mid; } } long sum = 0; // 少なくとも(とれるなら)ok個とってよい。 foreach (ref a; A) sum += min(a, ok), a -= min(a, ok); // 端数を一周して合わせる { int i = 0; while (sum \u0026lt; K) { if (0 \u0026lt; A[i]) sum++, A[i]--; i++; } } // output foreach (i; 0..A.length) write(A[i], (i == A.length-1 ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;)); } 振り返り 解法2は解法1をさらにまとめた形だということもできるだろう。 筆者がこの解法に至るまでに次のような手順を踏んだ。 (解法1がTLEして)$A$がばらばらの値の時にまずいのか\u0026hellip; なんか何回も同じ要素を引き算してんな\u0026hellip;どうにかならんかな\u0026hellip; $0$個になったかごは無視してもいいから\u0026hellip;(天啓が下りてきて)可能なら$x$個とる方針で行けば二分探索できそう？ \u0026hellip;うまく言語化できない。というよりは、どうやって思いついたのか詳細にはわからないというのが正しいのか\u0026hellip; ただ、やはり最後の一周とそれまでを区別して考えるのは大事なポイントだと思う。 もし各かごにりんごが無限に入っていたとしたらこのように「何周するのか」に着目する解法を容易に構成できると思う。 が、今回は、りんごの減少に伴って変化が生じるので発想の難易度が上がっていると思った。 より易しい問題設定を考えたり、過去に解いた問題の記憶をためることが重要なのかなと思う。 (2023-09-28追記) 深夜に考えていたら少し思いついたので補足します。 この手の問題は「解の構造」を考えることが大事だと思います。 K個目のりんごを食べるときにかごのりんごがどのように減っているかを考えると、 0になるまで減る、または今まで周回した分だけ減るということが分かります。 すると、何周したかに着目できるのかなと思いました。 何周したかに着目できれば二分探索に帰着するのはそんなに難しくないと思います。 しかし、この手の問題は大抵シミュレーションの高速化で解けることが多いので、解法1を組み切る力も必要かなと思います。 (もちろん、シミュレーションの最悪計算量を一発で見抜く力も) 類似問題 ABC216E"
  },
  {
    url: "/post/abc202d/",
    title: "ABC202D - aab aba baa",
    date: "2023-09-24T00:00:00+09:00",
    body: "ABC202D - aab aba baa 問題概要 問題へのリンク A個のaとB個のbからなる文字列であって、辞書順でK番目のものを求めよ。 制約 1 \u0026lt;= A, B \u0026lt;= 30 辞書順でK番目の文字列が存在する。 解法 まず、問題文の条件を満たす文字列は$\\displaystyle\\frac{(A+B)!}{A!B!}$通り存在する。 これは、単にA+B個を並べたものからAの重複とBの重複を除いたものである。 また、これは二項係数$\\displaystyle\\binom{A+B}{A} = \\binom{A+B}{B}$でもあり、 A+B個の枠のうち、AかBを入れる場所を決めれば文字列が一つ定まると解釈することもできる。 制約下で最も種類数が多くなるのはA=B=30のときで、これは$\\displaystyle\\frac{60!}{30!30!} = \\binom{60}{30} = 118264581564861424$通りである。 したがって、文字列をすべて列挙して解くことはできない。 そこで、先頭からどの文字を使うかを決めていくことを考える。 ちなみにこれは辞書順を考えるときの典型テクニックらしいので、ある程度パターンマッチングとして選択肢に入れておくようにすると良いかもしれない。 先頭にaを入れた時を考える。 このとき、残るA-1個のaとB個のbで作ることができる文字列の種類は$\\displaystyle\\binom{A+B-1}{A-1}$通りになる。 もしKがこの値よりも大きければ、先頭にaを入れた時点でK番目に到達できないことが確定する。 つまり、先頭の1文字目は次の条件分岐で決定できる。 $K \\leq{} \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b 続けて次の文字を決定したいが、その前にやることがある。 上記の条件分岐でbを先頭に入れた場合、aが先頭であったときにあり得た$\\displaystyle\\binom{A+B-1}{A-1}$通りは 必ず自分よりも辞書順で若いはずである。 つまり、現時点で少なくとも$\\displaystyle\\binom{A+B-1}{A-1}$通り分のパディングを持っていることになる。 これを記録しておく必要がある。 さて、2文字目を決定しよう。 実は2文字目もほとんど同様に決めることができる。 1文字目との変化は 1文字目にとった文字の分減らして考えないといけない パディングを忘れないようにする という点だけである。 つまり、2文字目は次の条件分岐で決定できる。 $$ now = \\begin{cases} \\displaystyle\\binom{A+B-1}{A-1} \u0026amp; \\text{if 先頭がbである。} \\\\ 0 \u0026amp; \\text{if 先頭がaである。} \\end{cases} $$ として、先頭の文字に合わせて$A \\leftarrow{} A-1$または$B \\leftarrow{} B-1$とする。 $K \\leq{} now + \\displaystyle\\binom{A+B-1}{A-1}$であるとき、a そうでないとき、b とできる。 これを繰り返すことで文字列を決定できる。 注意として、aかbどちらかを使い切ってしまえば文字列が確定するので、最後まで手順を繰り返す必要はない。 時間計算量は、二項係数1回求める時間を$O(x)$と置くと、$O(x\\cdot{}\\mathrm{max}(A, B))$である。(多分) 提出 import std; void main () { int A, B; long K; readln.read(A, B, K); solve(A, B, K); } void solve (int A, int B, long K) { // 先頭からaとbどっちにするか決めていく。 // n_i個のアルファベットA_i(1\u0026lt;=i\u0026lt;=n)で構成される文字列の種類は多項係数の数だけ存在するので、頭の一つを決めれば後ろに何個存在するかがわかる。 long now = 0; char[] ans; ans.reserve(A+B); while (0 \u0026lt; A \u0026amp;\u0026amp; 0 \u0026lt; B) { if (now + nCk(A+B-1, A-1) \u0026lt; K) { now += nCk(A+B-1, A-1); ans ~= \u0026#39;b\u0026#39;; B--; } else { ans ~= \u0026#39;a\u0026#39;; A--; } } foreach (_; 0..A) ans ~= \u0026#39;a\u0026#39;; foreach (_; 0..B) ans ~= \u0026#39;b\u0026#39;; writeln(ans); } long nCk (int n, int k) { assert(0 \u0026lt;= n \u0026amp;\u0026amp; 0 \u0026lt;= k); if (n \u0026lt; k) return 0L; long res = 1; for (int i = 1; i \u0026lt;= k; i++) { res *= n-i+1; res /= i; } return res; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 発展 3種類以上の文字を含む場合にも同様の手順で辞書順K番目の文字列を求めることができる。 $m$種類の文字に対して、文字$c_i$が$N_i$個含まれる文字列の種類数は多項係数 $$ \\binom{\\sum{}N_i}{N_1, N_2, \\dots{}, N_m} = \\frac{(\\sum{}N_i)!}{\\prod{}N_i!} $$ により求めることができるから、これを用いて上のアルゴリズムを適用すれば良い。 しかし、現実的には多項係数が非常に大きくなるので問題には出にくいと思う。"
  },
  {
    url: "/post/abc321/",
    title: "ABC321参加してきた。",
    date: "2023-09-23T00:00:00+09:00",
    body: "ABC321参加してきた。 久しぶりに参加記録を書きます。 ここ1か月くらい参加記録をずっとさぼっていましたが、hugoに移行したことでだいぶん楽になったので今週はちゃんと書きます。 本稿は ABC321 の参加記録です。 戦績 今回の提出は以下の通りでした。 今回AからEの5問解くことができました。 所感 今回はD問題まではさっと解法が見えました。 C問題は以前にABCの 過去問 で広義単調増加列の全探索をしたことがあったので、パッと見た瞬間に全列挙可能だと分かりました。 E問題はエーッ！やりたくないです！みたいな見た目をしていたが、こういう時に後ろの問題を見に行っていいことがあったためしがないので頑張って取り組みました。 雑振り返り A - 321-like Checker 問題文 書いてある通りにチェックしたらOKです。こういう時は文字列として受け取ると楽です。 import std; void main () { string N = readln.chomp; foreach (i; 0..N.length-1) { if (N[i] \u0026lt;= N[i+1]) { writeln(\u0026#34;No\u0026#34;); return; } } writeln(\u0026#34;Yes\u0026#34;); } B - Cutoff 問題文 制約がデカければ面倒くさそうですが、実は簡単な全探索が通ります。 Nラウンド目に0から100点のどれかしか取れないので、最終結果としてあり得るものは高々100通りです。 よって、これらすべてについて問題文の通りにチェックを入れると解けます。 「全部見る」ということで複雑さを全部破壊するのは気持ちよいですね。 import std; void main () { int N, X; readln.read(N, X); int[] A = readln.split.to!(int[]); int[] B; int ans = int.max; for (int i = 0; i \u0026lt;= 100; i++) { B = A.dup; B ~= i; B.sort; int score = 0; for (int j = 1; j \u0026lt; B.length-1; j++) { score += B[j]; } if (X \u0026lt;= score) { ans = min(ans, i); } } if (ans == int.max) { writeln(-1); } else { writeln(ans); } } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } C - 321-like Searcher 問題文 実は以前もう少し緩い制約で定義される数を探索する問題を解いたことがあって、その時の記憶が残っていたので即座に全探索の判断をとりました。 上の桁から決めていくような感じでdfsで掘りました。 重複とか怖かったので一応対策しています。 1WAでペナってしまったので、おそらくオーバーフローかな？ import std; void main () { int K = readln.chomp.to!int; solve(K); } void solve (int K) { // 狭義単調減少列は少なかったような気がするので全列挙します。 long[] number; void dfs (long current, int last) { for (int i = 0; i \u0026lt; last; i++) { dfs(10*current+i, i); } if (0 \u0026lt; current) number ~= current; } dfs(0, 10); number = number.sort.uniq.array; writeln(number[K-1]); } D - Set Menu 問題文 こういうのは大抵片方を固定するとよいと相場が決まっています。 実際、この問題においてA[i]を一つ固定すると、必ず和がPを超えるかどうかで境界線を引くことができます。 これを二分探索します。 いちいちBの総和をとっているとO(M^2)が乗ってくるので、累積和で1ケースO(1)に落とします。 import std; void main () { int N, M, P; readln.read(N, M, P); int[] A = readln.split.to!(int[]); int[] B = readln.split.to!(int[]); solve(N, M, P, A, B); } void solve (int N, int M, int P, int[] A, int[] B) { // Aを一つ決めたときに境界線を探す。 long ans = 0; B.sort; long[] cum; cum.reserve(M+1); cum ~= 0; foreach (b; B) { cum ~= cum[$-1]+b; } long f (int idx) { if (idx \u0026lt; 0) return cast(long) -int.max; if (M \u0026lt;= idx) return cast(long) int.max; return B[idx]; } foreach (a; A) { // 二分探索: a+f(ok) \u0026lt;= P, P \u0026lt; a+f(ng) // ただし、f(x\u0026lt;0)=-inf, f(M\u0026lt;=x)=inf int ok = -1, ng = M; while (1 \u0026lt; abs(ok-ng)) { int mid = (ok+ng) / 2; if (a+f(mid) \u0026lt;= P) { ok = mid; } else { ng = mid; } } if (ok == -1) { ans += 1L*P*M; } else { ans += 1L*(ok+1)*a+cum[ok+1]; ans += 1L*P*(M-ok-1); } } writeln(ans); } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } 一発で通せて本当に良かった。 E - Complete Binary Tree 問題文 制約は載せていませんが、Tが105で、そのほか1018です。 まず、この木がどうなっているのかを図に書いてチェックします。 すると、これは完全二分木になっていることが確かめられます。 さて、制約がクソでかなので、グラフ上で実際にチェックしてやるのは無理です。 完全二分木の何かしらの性質を使います。 しばらく悩んで、例えばX=1で固定だったらどうだろうという発想に至りました。 この時、割と簡単に解けそうだなという感じです。具体的には、最左のノードと最右のノードの番号を持っておいて、(left, rightとします。) left = 2*left; right = 2*right+1; を深さ分だけ続けていけばよさそうです。 途中でN \u0026lt; leftなら解は0で、そうでなければmin(N, right)-left+1になりそうな感じです。 式で書くと分かりにくいですが、実際はずっと15要素の二分木とにらめっこしていました。 というわけで、自分を根とする部分木に対してなら問題が解けました。 頂点1以外は必ず親を持つので、この部分木に対する問題を解くサブルーチンを適切に親ノードを選んで実行する感じで解きました。 import std; void main () { int T = readln.chomp.to!int; foreach (_; 0..T) { long N, X, K; readln.read(N, X, K); long ans = solve(N, X, K); writeln(ans); } } long solve (long N, long X, long K) { // 自分を根とする部分木の数え上げはできそう /* return: 自分を根とする部分木において、自分との距離がdistであるようなものの数を数え上げる。多分logくらい */ long count (long root, long dist) { enforce(0 \u0026lt;= dist); if (N \u0026lt; root) return 0; if (dist == 0) return 1L; long left = root, right = root; while (0 \u0026lt; dist) { left = 2*left; right = 2*right+1; dist--; if (N \u0026lt; left) return 0; } return min(N, right)-left+1; } bool[long] memo; long ans = 0; ans += count(X, K); memo[X] = true; X /= 2; K--; if (K \u0026lt; 0) return ans; while (1 \u0026lt;= X) { if (K == 0) { ans++; break; } memo[X] = true; if ((2*X) !in memo) { ans += count(2*X, K-1); memo[2*X] = true; } if ((2*X+1) !in memo) { ans += count(2*X+1, K-1); memo[2*X+1] = true; } X /= 2; K--; } return ans; } void read(T...)(string S, ref T args) { auto buf = S.split; foreach (i, ref arg; args) { arg = buf[i].to!(typeof(arg)); } } これがACをとったコードですが、どのように動くかを具体的に見てみようと思います。 1\r2 3\r4 5 6 7\r8 9 10 11 12 13 14 15\rバックスラッシュが円マークになってしまうのでpreに位置関係を書きました。 一例として、X=6の動作を示します。 以下、countは指定した頂点を根とする部分木に対して答えを返す関数になります。 countにX=6とKを渡します。 X=6をメモっておき、X/=2、K--とします(一つ上の階に上がる) 2Xと2X+1のうち、メモに入っていない方、およびK-1をcountに渡します。また、Xもメモっておきます。 これを1 \u0026lt;= Xである間(根にたどり着くまで)繰り返します。K=0になったりしたときには適切に処理します。 という感じです。これでもれなく探索できます。 計算量はcountが1回につきO(log(N))程度で、Xから1になるまで上に登っていくので、大体クエリ1回あたりO(log^2(N))くらいです。多分。 最初の実装では、countに渡した2Xまたは2X+1のノードが存在しない時にバグっていたようで、なかなか気づかなくて大変でした。 最後何とか気づいてギリギリ通りました。 おそらくもっと良い解法があるので、復習します。 F以降はほぼ見てないです。 感想 Eが解けてよかったー これからもできる範囲で精進頑張ります。"
  },
  {
    url: "/post/hugo-setting/",
    title: "InTheDayDreamをhugoに移行するためにやったことたち",
    date: "2023-09-15T00:00:00+09:00",
    body: "InTheDayDreamをhugoに移行するためにやったことたち 手動ブログ運営はしんどい！ さて、皆様はhatenablogなどのサービスを全く介さずに、単にインターネット上の置き場所にWebページを展開したことがありますでしょうか？ 私がしばらく運営している当ブログは、github pagesを利用した完全な手動運用のサイトです。 まあこれが辛いんです結構 具体的に何がしんどいのかと言うと、ページ公開に伴う面倒な作業がとにかく多いんですね。 例えば一つ公開したいページがあるとき、色んな所にリンクを貼り付ける必要があります。 また、すべてのCSSや、各ページのヘッダ(htmlの\u0026lt;head\u0026gt;タグの中身)とかも全部用意しなければいけません。 これがやりたいという人はいいですけど、結構面倒くさくて記事更新のモチベーションがゴリゴリ減らされるわけです。 私は現在競技プログラミングに取り組んでいて、新しい知見を得ることが結構ありますが、わざわざ一つの問題に対して記事を建てるなんて面倒くさくてやりたくないわけです。 これはかなりのデメリットです。 私はフロントエンドエンジニアでもなんでもなく、gitの使い方すらガバガバな初心者ですから、大抵の実装はその場しのぎで後からいじるとかはやりたくないわけです。 現在私のブログはもう触りたくないけどなーみたいなゴミがたくさん転がっているひどい現状です。 しかも、折角書いた記事も全然再利用性がないなーと感じています。 私の理想を言うなら、できるだけmarkdownなどでプレーンテキストデータに近い形で記事をおいておきたいわけです。これにスタイルシートとかを当てたり、他のフォーマットに変換するのは割と容易ですし。 というわけで、このあたりの面倒くさい作業をhugoに丸投げしちゃおうと言う感じです。 hugoとは？ The world’s fastest framework for building websites Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. 以下google翻訳 ウェブサイトを構築するための世界最速のフレームワーク Hugo は、最も人気のあるオープンソースの静的サイト ジェネレーターの 1 つです。 Hugo の驚くべきスピードと柔軟性により、Web サイトの構築が再び楽しくなります。 hugo公式サイト より だそうです。すごく簡単に言うと、WordPressなどのようなCMSと違い、設計図のようなものから静的Webサイトを構築するソフトウェアです。 似たようなソフトウェアに jekyll とかがあります。 実は、以前jekyllをワチャワチャしてみようと思ったのですが、その時はよくわからずに諦めてしまったことがあります。 Jekyllなんか知らんけど動かない \u0026mdash; In (@UU9782wsEdANDhp) March 26, 2023 これはjekyllがプログラミング言語rubyとかなり密接につながっていることが原因の一つです。 jekyllはちょっと動かしてみたいなーってだけでなんだか色々インストールだの何だのを要求されます。 私はプログラミングのことなんか全然わかりませんから、普通にキレてやめました。 一方、hugoはあまりややこしいことをしなければgo言語の処理系を用意する必要すらないということで、割と良さそうだなと思って試しています。 もちろんソースからビルドとかしたいなら処理系が必要ですが、各プラットフォーム向けにバイナリが配布されているようなので、それでなんとかします。 let\u0026rsquo;s try! とりあえずバイナリを ここ からひったくってきます。 Windowsの方などはhugo_extended_0.118.2_windows-amd64.zipっていうやつをパクってきたらいいと思います。(2023/09/15) Linuxなどの方は、ディストリビューションのパッケージとして公開してくれてるやつを引っ張ってきても良いと思います。 私はUbuntu 22.04.3 LTS (64bit)ですので、aptからパクってくることもできます。 sudo apt update sudo apt install hugo ただ、なんか微妙に古かったので、さっきのリンクからパッケージをパクってきて、それをaptに渡しました。 hugo_extended_0.118.2_linux-arm64.debをダウンロード sudo apt install path/to/hugo_extended_0.118.2_linux-arm64.deb インストールできない？俺もわからん hugo version # -\u0026gt; hugo v0.118.2-da7983ac4b94d97d776d7c2405040de97e95c03d+extended linux/amd64 BuildDate=2023-08-31T11:23:51Z VendorInfo=gohugoio だそうです。 使い方は次のリンクをさっと見ていきましょう。ちなみに私は細かい使い方とか難しいことは何も分かっていません。 公式サイト(英語) さくらのナレッジ 私は読んでないけど、なんかドンピシャなやつあった(qiita) こっちは読んだやつ(Zenn) 読んだやつパート2(Zenn) もっとちゃんと知りたい人はちゃんと公式サイトを浚いましょうね。 さて、サイトテーマを決めましょう。hugoは公式サイトで有志が作ったテーマをいっぱい公開してくれています。 ここ で物色しましょう。 テーマってなんやねんと思う方もいると思います。 私の浅いイメージ的には、 hugo : ユーザーが特定のディレクトリに配置したファイルからいろんなデータなどを抜き出し、それを操作する統一的なインターフェースとかを提供する。(例えば、配置したmdファイルからテキストを抜き出して、{{content}}みたいな記法で他のファイルに挿入できるようにするとか) hugoテーマ : hugoが提供してくれる機能をいい感じにデコったりしてくれる。 みたいな感じなのかな？ なので、hugo側でデフォルトで提供されているものの、テーマがそれに対応していないこともあります。readmeとかを見てちゃんと決めましょう。リポジトリを見に行けば大抵デモページが用意されています。 私がやったこと さて、本題です。 ここからは、私がこのサイトを構築するためにやったことを色々書きます。 どちらかと言うと自分が忘れたときのためのものなので、大して参考にならんかもしれません。 正直に言うと、このセクションのためにこの記事を書き始めました。 テーマ選択 テーマは simplog を選択します。 主な選定理由はタグやカテゴリなどの便利機能をサポートしつつ、シンプルで使いやすそうだからです。 さて、今まで構築していたリポジトリをローカルにコピーしておいて、破壊しましょう。 cp -r ./ path/to/archive/ rm * hugo new site . --force # 以下実際のログ Congratulations! Your new Hugo site was created in /home/in/dev/git/myblog. Just a few more steps... 1. Change the current directory to /home/in/dev/git/myblog. 2. Create or install a theme: - Create a new theme with the command \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; - Install a theme from https://themes.gohugo.io/ 3. Edit hugo.toml, setting the \u0026#34;theme\u0026#34; property to the theme name. 4. Create new content with the command \u0026#34;hugo new content \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 5. Start the embedded web server with the command \u0026#34;hugo server --buildDrafts\u0026#34;. See documentation at https://gohugo.io/. 次に、テーマをインストールします。よく分かってないですが、とりあえず書いてあるとおりに進めます。(なんだよsubmoduleって) git submodule add https://github.com/michimani/simplog.git ./themes/simplog # 以下実際のログ Cloning into \u0026#39;/home/in/dev/git/myblog/themes/simplog\u0026#39;... remote: Enumerating objects: 2538, done. remote: Counting objects: 100% (664/664), done. remote: Compressing objects: 100% (262/262), done. remote: Total 2538 (delta 288), reused 625 (delta 280), pack-reused 1874 Receiving objects: 100% (2538/2538), 3.09 MiB | 6.19 MiB/s, done. Resolving deltas: 100% (1201/1201), done. 全体の設定(hugo.toml) さて、驚くべきことに、これで大半の作業は終了です。 後は設定やテーマをいじりましょう。 まず、ルート直下にあるhugo.tomlを設定します。(hugoのバージョンによってはconfig.tomlがデフォだったりする) 私の設定を貼り付けておきますが、このあたりはテーマに依存する項目も多いですから、いろんな情報を見てみると良さそうです。 あと、一応注意喚起ですが、私は雰囲気で設定したので多分いくつかおかしいです。 baseURL = \u0026#39;http://inthebloom.github.io/\u0026#39; languageCode = \u0026#39;ja\u0026#39; DefaultContentLanguage = \u0026#34;ja\u0026#34; title = \u0026#34;InTheDayDream\u0026#34; description = \u0026#34;InTheBloom\u0026#39;s Website\u0026#34; author = \u0026#34;InTheBloom\u0026#34; theme = \u0026#34;simplog\u0026#34; paginate = 10 summarylength = 20 enableInlineShortcodes = true ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;] googleAnalytics = \u0026#34;\u0026#34; disqusShortname = \u0026#34;\u0026#34; [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true [menu] [[menu.main]] identifier = \u0026#34;home\u0026#34; name = \u0026#34;Home\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;Archives\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 4 [[menu.main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; weight = 5 [taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; archive = \u0026#34;archives\u0026#34; [services] [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true [params] subtitle = \u0026#34;\u0026#34; colorTheme = \u0026#34;default\u0026#34; description = \u0026#34;\u0026#34; twitter = \u0026#34;UU9782wsEdANDhp\u0026#34; customCSS = \u0026#34;/css/custom.css\u0026#34; adobeFontsKitId = \u0026#34;\u0026#34; headerImagePath = \u0026#34;\u0026#34; [params.enabled] comment = true summary = true toc = true ポイントとしては、mdファイル中の生のhtmlを反映するようにunsafe機能を有効にしてあります。また、カスタムcssを有効にしてあります。カスタムcssは/static/以下が検索されてるっぽい？ カスタムcss(static/css/custom.css) cssは気に入らないものをオーバーライドしましょう。 ブラウザの調査機能などを使うと比較的簡単にどれを変えればよいかわかります。 img { width: auto; max-width: 100%; height: auto; border: 1px solid black; } #content h2 { padding-bottom: 0.5em; border-bottom: 1px solid gray; margin-top: 3em; } #main-menu-nav-items { grid-template-columns: repeat(5, 20%); } .block-separater { margin-top: 50px; } #content-footer { margin-top: 70px; } テンプレートのオーバーライド(layouts/) テーマに用意されているテンプレートもいじりましょう。 themes/以下のlayoutsではなく、ルート以下のlayoutsに同様のファイルを用意してあげることで、差異があったら優先的に使ってくれます。 cp -r themes/simplog/layouts/* ./layouts/ KaTeXの設定 これ を利用する。 要はCDNからKaTeXを読み込んで、JSでロード時に変換しているっぽい？ 詳しいことはたくさん記事が存在するから各自でやりましょう。 まず諸々の設定を入れ込んだpartialを作成しよう。 touch layouts/partials/math.html 中身はこれ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, // {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, // {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u0026lt;/script\u0026gt; 各ページで読み込むための設定をしよう。 フロントマター(各記事先頭の設定)や、hugo.tomlで記述したパラメータを参照してオンオフを切り替えるようにした。 layouts/partials/header.htmlあたりにでも埋め込もう。 \u0026lt;!-- KaTeX Settings --\u0026gt; {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34;}} {{ end }} これでページ先頭にmath: trueなどと書けばKaTeXを使ってくれる。 余談ではあるが、markdownとKaTeXを同時に運用するのは相性的にあまり良くない。というのも、markdownパーサーがKaTeX記法と衝突することがあり、この場合htmlのロード後に発動するKaTeXが必ず負ける。 いろんなケースがあるので、問題が発生したらその都度解決策を考える必要があり、かなり面倒くさい。 マジで誰かなんとかしてくれ Table Of Contentsを強調する 記事の先頭にTOC(Table Of Contents)を設置してくれる機能がある。しかし、simplogのデフォルトはあまりにもわかりにくいと感じるので、改造する。 TOCはlayouts/_default/single.htmlをいじれば良さそう。 これが元 \u0026lt;!--TOC--\u0026gt; {{ if eq .Site.Params.Enabled.Toc true }} {{.TableOfContents}} {{ end }} 改造後 \u0026lt;!--TOC--\u0026gt; {{ if and .Site.Params.Enabled.Toc (not (eq .Params.Toc false)) }} \u0026lt;div style=\u0026#34;padding: 0em 1em; margin-bottom: 5em; margin-top: 0.7em;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Table Of Contents\u0026lt;/p\u0026gt; {{.TableOfContents}} \u0026lt;/div\u0026gt; {{ end }} ついでに各記事内でTOCを制御できるようにした。先頭メタデータでtoc: true/falseで制御できる。 記事タイトルをh1にする 何故か最大の見出しがh2にされていて、自作cssが適用されちゃうのが嫌なのでh1に差し替える。 いじるファイルは同様にlayouts/_default/single.html あと、ついでに公開日のところをいじる。 before \u0026lt;!--Title--\u0026gt; \u0026lt;h2\u0026gt;{{.Title}}\u0026lt;/h2\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;{{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; {{ end }} after \u0026lt;!--Title--\u0026gt; \u0026lt;h1\u0026gt;{{.Title}}\u0026lt;/h1\u0026gt; {{ if or (not .Params.hideDate) (eq .Params.hideDate false) }} \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Published on {{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;span class=\u0026#34;sub\u0026#34;\u0026gt;Last Modified {{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/span\u0026gt; {{ end }} 何気にパラメータlastmodが追加された。 先頭メタデータ内で、lastmod: 2006-01-01みたいな感じで指定してあげると良さそう なお、lastmodが設定されていないときはデフォルトでdateに合わせてくれた。気が利くなぁ ogpの画像の参照先をいじる ogpというのは、SNSなどにリンクを貼ったときにいい感じにプレビュー画像みたいなのを表示してくれるやつです。 デフォルトでは相対パスで検索しているようなので、ここを絶対パスを使うようにしてみます。 layouts/partials/head.htmlをいじります。 before \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $site.BaseURL }}{{ . }}\u0026#34;\u0026gt; after \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; これで、メタデータでogimage: path/to/imageで指定できます。ただし絶対パスが必要になるので、外部のURLを指定すべきです。 ついでにデフォルトのogpimageを設定しておきましょう。{{ $site.BaseURL }}/images/featured_image.jpgという設定になっているようなので、この場所、名前で適当に作って配置します。 \u0026hellip;と思ったが、メタモンが発生してやる気がなくなったのでやめた。 faviconを用意する ブラウザなどでサイト名の横に表示されるちっちゃい画像のことをファビコンと呼ぶ。 これを用意する。 \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/apple-touch-icon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;32x32\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;16x16\u0026#34; href=\u0026#34;{{ relURL \u0026#34;images/favicon-16x16.png\u0026#34; }}?c={{$cacheHashBase}}\u0026#34;\u0026gt; layouts/partials/head.htmlにこのような記述があった。この名前とサイズで用意しよう。 なんかよくわからないが/static/images/*.pngに用意したら反映された。 aboutページを用意する contents/about.mdを用意すると動きました。 細かいことには触れません。 大体完成！ 後はルートディレクトリでhugo serverを実行するとhttp://localhost:1313にアクセスすると見れます。 ビルドするときはhugoを実行すればpublic/に静的サイトが作成されます。 適当にpushしときましょう。 メタデータのテンプレートはこんなかんじかな？ --- title: title date: yyyy-mm-dd # lastmod: yyyy-mm-dd # ogimage: https://path/to/ogimage.img tags: - categories: - archives: - # math: true # toc: false --- 追記 注意このセクションに書いてあることとそれまでのセクションで書いてあることが重複していたり、矛盾している場合、こちらがより正しい。 実用的にはほとんど何もしなくてもいい感じにしてくれるほうが良いなと思った。 記事作成でメタ情報の追加が面倒くさそうだなと思ったので、分類をタグのみに絞ることにした。 まず、hugo.tomlの内容を修正する。 具体的には、次の内容を消す # [taxonomies]にある category = \u0026#34;categories\u0026#34; # [menu]にある [[menu.main]] identifier = \u0026#34;categories\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/Categories/\u0026#34; weight = 4 すると、上のメニューバーが一枠開くので、CSSを修正する。 /static/css/custom.cssを次のように修正する。 /* #main-menu-nav-itemsにある */ /* 次を消す */ grid-template-columns: repeat(5, 20%); /* 次を追加 */ grid-template-columns: repeat(4, 25%); これでタクソノミーを減らすことができた。hugo的にはカテゴリとタグを特別使い分けてなさそう(知らんけど)ので、許されるんじゃないかな 全文検索をパクる まくまくhugoノート を見ていたら、全文検索を実装できるらしい。 この機能があれば過去記事とかから情報を検索できてすごく便利だなと思ったので、導入することにした。 ほとんど上のコードをパクり、/layouts/shortcodes/search.htmlとしてファイルを作成し、search.mdというファイルでショートコードを取り込むことにした。 内容は省略するとして、search.mdの内容を載せておく。 --- title: サイト内全文検索 hidedate: true toc: false _build: {list: never} --- サイト内の文章からインクリメント検索が可能です。 下の入力欄に入力することで検索ができます。 本ページは検索の対象外になっています。 \u0026lt;!-- searchのショートコードを入れる(ここに入れるとここでも無限再帰になってしまう。) --\u0026gt; _build: {list: never}というのをすると、一覧系のページに表示されなくなるらしい。これをしないとビルドのときに無限再帰になってしまう。 さて、これで上のメニューバーに検索を入れたくなった。 CSSを再度修正し、先程消したカテゴリの分を作る。 grid-template-columns: repeat(5, 20%); [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;Search\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 4 出来上がりは 検索ページ で確認できる。 また、詳細なファイルの内容はgithubのリポジトリにおいてある。 それはそれとして、さっき直したものをまた直すとは計画性のないアホである。 関連タグの表示を調整する 便利な機能として、関連タグの記事を下の自動リンクしてくれる機能があるが、その見た目があまり良くなかった。 ので、改造する。 /layouts/partials/related-tag-posts.htmlを次のように修正する。 \u0026lt;!-- 次を削除 --\u0026gt; \u0026lt;h4\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h3\u0026gt; \u0026lt;!-- 次を追加 --\u0026gt; \u0026lt;h4 style=\u0026#34;font-size: 1.3em;\u0026#34;\u0026gt;Other posts tagged by \u0026#34;{{ $t }}\u0026#34;\u0026lt;/h4\u0026gt; これ修正して気づいたが、オリジナルのコード閉じタグ間違ってない？ それと同時にCSSに次のものを追加する。 .related-tag-category-list { margin-top: 5em; } これで幅と可読性がいい感じになった。 過去記事の移植 今日(9月23日)、まだ完了していませんが、pandocでhtmlをmarkdownに変換して手作業で移植しています。つらたん。 (デプロイ後に発覚)faviconの謎の不具合 なんかlayouts/partials/head.htmlのfaviconのhrefの後ろにc=?\u0026lt;謎の文字列\u0026gt;みたいな謎の処理が入っているが、何故かgithub pages上でうまく動かなかった。 よって、これを削除した。 どういう影響があるのか知らない。 2023-09-23追記: 多分キャッシュ関連の何かだと思うんだけど、調べてもよくわからなかった。まあ動かなかったのは事実なのでfaviconくらい別にいいでしょの顔 ただ不思議なのは、cssとかもこれをやる設定になっているように見えること。なぜかfaviconだけうまく動かない。 win機でpullしたときに発覚したこと (これはhugoの記事として適切ではないかもしれません。) 最初にsimplogをgit submoduleしてとってきましたが、他のPCでこのリポジトリをクローンした場合、自動的にsubmoduleまでとってきてくれるわけではないようです。 これ を参考にして、次のコマンドを打ったらうまくいきました。 git submodule init git submodule update フロントマターのテンプレート 最後に改訂版フロントマターのテンプレートを載せておく。 --- title: hogehoge # description: hogehoge date: yyyy-mm-dd # hidedate: true # lastmod: yyyy-mm-dd # ogimage: https://hoge/fuga/piyo.img tags: - hoge archives: - yyyy - yyyy-mm # math: true # toc: false # build: {list: never} --- 終わりに なんだかんだ1週間以上色々やってた。 疲れました。 これでいろんな記事を作りやすくなった。嬉しい。"
  },
  {
    url: "/post/abc315/",
    title: "ABC315参加記録",
    date: "2023-08-24T00:00:00+09:00",
    body: "ABC315参加記録 はじめに 本稿は2023/8/19に行われた ABC315 の参加記録です。 戦績 今回の提出は以下のとおりです。 レーティング変化は以下のとおりです。 A, B, C, D, Eの5完で、レーティング変動は 979=\u0026gt;1032(+53)でした。 所感 今回でついにレーティング1000の大台に乗ることができました！かなり嬉しいです。 最近のABCでかなり手痛い負け(負けでないにしろ、解けないとダメだった問題を落としたり)が続いていたため、 今回で多少モチベが回復したような気がします。 コンテストに対する感想としては、今回D問題がかなり重実装(?)の問題だったようです。 当たりの方針を引いて、かつうまく実装できないと解くのが難しかったようで、difficultyが水色になっていました。 私は運良く筋の良い方針を見つけることができたため、なんとか通すことができました。 これが今回のパフォーマンスの上ブレに繋がったようです。 E問題は解けはしましたが、割と試行錯誤して通した感じがあります。 もっと問題の本質を見極められるようになりたいなと思います。 解法 A - tcdr Sの長さが十分に短いので、一つづつチェックするだけで良いです。 一文字のチェックに5回の同値判定をすれば良いので一回の判定がO(1)、全体O(|S|)です。 提出 B - The Middle Day 制約から、必ず真ん中の日が存在して、それは(Dの総和+1)/2になります。 D_1から順に総和をとっていき、初めて(真ん中の日)\u0026lt;=(総和+D_x)となるxが真ん中の日を含む月になります。 また、その月の(真ん中の日)-(総和)日目が真ん中の日になります。 混乱してしまう場合は、一旦紙に書いて一つづつ数えるとわかりやすいと思います。(自分もこういうの苦手です。) 計算量は、総和でO(M)、前からのシミュレーションでO(M)であるから、全体O(M)です。 提出 C - Flavors 素直にやるなら、N個から2つ選ぶ全探索のO(N^2)です。 これは間に合いません。 この手のO(N^2)(だけではないが)が通らないタイプの問題にはいくつかパターンがあり、よくあるのは 何らかの前計算をしておき、各ケースの計算量を落とす。 分割統治で擬線形時間に落とす。(例: ソートなど) 動的計画法により前進的に(そうでない場合は、トポロジカル順に)求める。 実は探索するべきものはそんなに多くない。 とかです。 今回は、問題をよく見ると、全探索を減らすことができそうだとわかります。 場合分けしましょう。 2つのアイスの種類が同じ: 美味しさのトップ2を取ればよい。 2つのアイスの種類が違う: (異なるアイスの)美味しさのトップ2を取れば良い。 さて、1番はO(N)個の候補しかなく、2番は高々一つの候補しかありません。 ただし注意として、これらのうちどちらか片方は候補が一つも存在しないことがありえます。(両方候補がなくなることはないです。) 前処理をさくっとできれば、残りは線形時間で処理できそうです。 というわけで、アイスを種類ごとに振り分けてソートし、(存在すれば)それぞれの候補値のmaxを取れば良いです。 提出 私は候補が存在しないケースに気づかずに2WAしました:( D - Magical Cookies 今回の激ヤバ問題です。 色々考えました。 最初は印をつけたやつを即時消してよいのかと思っていました。 しかし、サンプル2を見て、定義された操作の順番に操作しないとダメなケースがあるなと気づき、 シミュレーションで解く方向に舵を切りました。 完全にそのままシミュレーションしてしまうと、 一回の操作あたりO(HW)となり、全体O((HW)^2)になりそうだなーという感じでダメそうです。 というわけで、配列で各行、各列の「残っている色の種類数」「クッキーの総数」を管理しながらシミュレーションしました。 削除する列(行)となくなるクッキーの色をキューで管理して、楽に削除クエリを処理できるようにしました。(説明が難しい) 自分の文章力だと限界なので、提出例から読み取ってくれ(丸投げ) 提出 E - Prerequisites 順番を考えなければ、必要な本を見つけるのはそれほど難しいことではないです。 具体的には、「その本が必要とする本」へ辺を張って、本1から辿れる連結成分が必要な本です。 無向グラフにしてしまうと変な本を取り込んでしまうおそれがあるので、有向グラフでやりましょう。 変な本を取り込む例: 本1が本2を必要とし、本3が本2を必要とするとき、連結成分に本3も含まれるが、別にいらない。 この連結成分をいい感じの順番で出力すればACです。 ある時点で読むことのできる本の条件は、その本が必要とする本を全部読んでいることです。 これをグラフで表現すると、その本から有向辺でつながっている本を全部読み終わっていることといえます。 ここで、出次数をうまく扱います。 先程の条件は、出次数を用いると、「出自数が0の本なら読んでも良い」になります。 読んだ本へと伸びている辺を切っていけば(辺の始点の出次数を減らせば)順番に上がっていくことができます。 すまん、うまく説明できない。「トポロジカル順序」でググってくれ(丸投げ)(最悪) 提出 自分の提出では、有向辺を逆向きにたどるために、後から逆方向の辺を張って無向グラフに変えています。 終わりに ブログエントリ作るの時間かかる上に、問題をちゃんと解けないとネタがないから割と大変です。。 このブログはかなりメチャクチャな構造をしているので、最近どうにか改装しようと頑張っているのですが、こっちも思った以上に大変で心が折れそう。 まあなんにせよ引き続き競プロがんばります。"
  },
  {
    url: "/post/modpow/",
    title: "繰り返し二乗法について",
    date: "2023-08-05T00:00:00+09:00",
    body: "繰り返し二乗法について はじめに この度私のライブラリに冪乗の余りを求める、いわゆるmodPow関数を追加しました。 丁度いい機会ということで、本稿ではmodpowの仕組みを説明し、詳細な実装方法と実装例を示します。 数学をガバっていたらすみません。 modpowとは 以下、$\\times{}$は整数の積を表します。 まず、剰余を定める重要な定理を紹介します。 定理1 (除法定理)\r$\\forall{} n, m \\in{} \\mathbb{Z} ~ (m \\neq{} 0)$に対して、 $q, r \\in{} \\mathbb{Z}$が存在して、次を満たす。 $$ n = qm+r, ~ 0 \\leq{} r \u0026lt; |m| $$ また、このような$q, r$は$m, n$に対してただ一つに定まる。 ::: (証明略) ここで、$q, r$をそれぞれ、「$n$を$m$で割った商」、「$n$を$m$で割った非負最小剰余」と定めます。 次に、$\\forall{}x \\in{} \\mathbb{Z}$と非負整数$n$に対して、冪乗$x^n$を次で定めます。 $$ x^n = \\begin{cases} x \\times{} x^{n-1} \u0026amp; \\text{if $n \\geq{} 1$} \\\\ 1 \u0026amp; \\text{if $n = 0$} \\end{cases} $$ 本稿で紹介するmodPow関数で求める値は、$a^x$をMODで割った非負最小剰余です。 (数式苦手な方へ)これは何を求めているのかをできるだけ形式的に定めているだけなので、あまり気にしなくても良いです。 「$a$ を $x$ 回掛け算して、MODで割った余りを求める。」でOKです。 (注意): 便宜上、$0^0=1$ としています。 計算原理 以下、割る数は$0$を含まない正整数とします。 割る数とはプログラムにおけるMODのことです。 (定義を考えれば負の整数に対しても非負最小剰余はただ一つに定まりますが、実用上正整数を用いることが多いのかな？) 通常、冪乗は比較的簡単に非常に大きな値になります。 例えば、$2^{10}=1024$ ですが、$2^{64}=18446744073709551616$ であり、 上の定義をそのまま計算するだけでは非常に厳しいことがわかります。 そこで、まず次の定理が大事になります。 定理2\r$(a ~ \\text{mod} ~ m)$と書けば、$a$を$m$で割った非負最小剰余を表すとする。 このとき、整数$x, y$に対して次が成立する。 $$ ((x \\times{} y) ~ \\text{mod} ~ m) = ( ((x ~ \\text{mod} ~ m) \\times{} (y ~ \\text{mod} ~ m)) ~ \\text{mod} ~ m) $$ 証明:\r上で示した定理により、次が成立する。 ある整数 $q_{1}, q_{2}, r_{1}, r_{2}$ が存在して、$x = q_{1}m + r_{1}, ~ y = q_{2}m + r_{2}$ また、 $$ \\begin{split} x \\times{} y \u0026amp;= (q_{1}m + r_{1}) \\times{} (q_{2}m + r_{2}) \\\\ \u0026amp;= q_{1}q_{2}m^2 + (q_{1}r_{2} + q_{2}r_{1})m + r_{1}r_{2} \\\\ \u0026amp;= (q_{1}q_{2}m + (q_{1}r_{2} + q_{2}r_{1}))m + r_{1}r_{2} \\\\ \\end{split} $$ であるから、 $$ \\begin{split} (左辺) \u0026amp;= ( ((q_{1}q_{2}m + (q_{1}r_{2} + q_{2}r_{1}))m + r_{1}r_{2}) ~ \\text{mod} ~ m ) \\\\ \u0026amp;= ((r_{1}r_{2}) ~ \\text{mod} ~ m) \\end{split} $$ 一方、 $$ (x ~ \\text{mod} ~ m) \\times{} (y ~ \\text{mod} ~ m) = r_{1}r_{2} $$ であるから、 $$ (右辺) = ((r_{1}r_{2}) ~ \\text{mod} ~ m) $$ 証明終わり。 この定理は、積に関してなら どのタイミングで非負最小剰余に変換しても最後は同じ値になるということを示しています。 また、定理では右辺は両方非負最小剰余に変換していますが、もちろん片方だけで行っても同様の結果が得られます。 これで $a^x$ の大きさに関する問題は解決します。 なぜなら、一回 $a$ を掛け算するたびに非負最小剰余に逐次変換していけば良いので、 $(割る数) \\times{} (割る数)$さえ正しく計算できれば $a^x$ の非負最小剰余もまた計算可能になるからです。 プログラム的には、用いる整数の型が $k$ bitであるとき、MODの大きさが $k/2$ bit程度であれば計算できます。 したがって、次のようなプログラムは正しく動作します。 long long modPow (long long a, long long x, const int MOD) { // 不正な入力を弾く assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // aを正規化 a %= MOD; a += MOD; a %= MOD; long long res = 1; for (long long i = 0; i \u0026lt; x; i++) { res *= a; res %= MOD; } return res % MOD; } $a$ の正規化というのは、底を最初の段階で非負最小剰余に変換しているということです。 上のコードは積や剰余演算を$O(1)$でできると仮定すれば、全体で$O(x)$で抑えられます。 しかし、(競技プログラミングなど)実用上はxは$10^9$程度であったりすることが多く、このままでは使えません。 そこで、通常は次に説明するような高速化を施します。 まず、以下の定理を導入します。 定理3 ($p$ 進法)\r2以上の整数 $p$ を固定する。任意の非負整数 $x$ に対して、 長さ$1$以上の整数列 ${c_{i}} ~ (c_{i} \\in{} {0, 1, \\cdots{}, p-1})$ が存在し、 $$ x = \\sum_{i=0} c_{i}p^{i} $$ と表すことができる。 また、このような表し方(すなわち、数列 ${c_i}$)は $x=0$ を特別扱いするとき、先頭の余計な $0$ の項を除いて一意に定まる。 証明:\rまず、任意の非負整数が上の形で表されることを示す。 (1) $x=0$ のとき、すべての項が $0$ であるような整数列 ${c_{i}}$ を用いれば良い。 (2) $x=1$ のとき、整数列 ${c_{i}}$ であって、 $$ c_{i} = \\begin{cases} 1 \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$ であるようなものを用いれば良い。 (3) $x\u0026gt;1$ に対して $x$ 未満の正整数が上の形で表されると仮定する。 このとき、$x = qp + r$ と表示すると、 (i) $q=0$ のとき、$0 \\leq{} r \u0026lt; p$ であるから、整数列 ${c_{i}}$ であって、 $$ c_{i} = \\begin{cases} r \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$ であるようなものを用いれば良い。 (ii) $q \\neq{} 0$ のとき、$q \u0026lt; x$ であるから、仮定より長さ1以上の整数列 ${d_{i}}$ が存在して $$ q = \\sum_{i=0} d_{i} p^{i} $$ よって、$x=qp+r$としていることを思い出せば $$ pq = \\sum_{i=0} d_{i} p^{i+1} $$ であるから、ここで新しく整数列 ${c_{i}}$ を次のように定める。 $$ c_{i} = \\begin{cases} r \u0026amp; \\text{if $i=0$} \\\\ d_{i-1} \u0026amp; \\text{otherwise} \\end{cases} $$ すると、 $$ x = pq+r = \\sum_{i=0}^{m} c_{i} p^{i} $$ と表すことができる。 数学的帰納法により、任意の整数を表すことができる。 次に、このような表し方が非負整数$x$に対して一意に定まることを示す。 まず、$x=0$ のとき、すべての $c_i$ が $0$ である。 これは「先頭の余分な $0$」のみで構成されている唯一の数字なので、これを特別扱いして、一意に定まっているとみなす。 (1) $0 \u0026lt; x \u0026lt; p$ のとき $$ x = \\sum_{i=0} c_i p^i $$ とすると、$1\\leq{}i$ なる $i$ に対して $c_i \\neq{} 0$ であるとき、明らかに $p \\leq{} x$ となる。これは仮定に反する。 したがって、 $$ c_i = \\begin{cases} x \u0026amp; \\text{if $i=0$} \\\\ 0 \u0026amp; \\text{if $i \\neq{} 0$} \\\\ \\end{cases} $$ 以外の表し方は存在しない。 (2) $p \\leq{} x$ のとき $x$ 未満の数は、すべて一意的に表されると仮定する。 このとき、 $$ \\begin{split} x \u0026amp;= \\sum_{i=0} c_i p^i \\\\ \u0026amp;= \\left( \\sum_{i=1} c_i p^{i-1} \\right) p + c_0 \\end{split} $$ とできる。定理1により、$\\sum_{i=1} c_i p^{i-1}$ と $c_0$ はただ一つに定まる。 ここで、明らかに $\\sum_{i=1} c_i p^{i-1} \\leq{} x$ である。 仮定より、$c_i ~ (1\\leq{}i)$ は一意に定まる。 以上より、数学的帰納法により任意の非負整数 $x$ は一意に表される。 証明終わり。 少々天下り的ですが、$p=2$ を選んで、$x = \\sum_{i=0} 2^i c_i ~ (c_i \\in{} {0, 1})$ とします。 定理より、非負整数 $x$ はこのような表示を先頭の $0$ の自由を除いて一意に持ちます。 このとき、 $$ \\begin{split} a^x \u0026amp;= a^{\\sum_{i=0} 2^i c_i} \\\\ \u0026amp;= a^{c_0 + 2 c_1 + 2^2 c_2 + \\dots{}} \\\\ \u0026amp;= a^{c_0} \\times{} a^{2 c_1} \\times{} a^{2^2 c_2} \\times{} \\dots{} \\\\ \u0026amp;= \\prod_{i=0} a^{ 2^i c_i} \\\\ \u0026amp;= \\prod_{i=0} \\left( a^{2^i} \\right) ^{c_i} \\end{split} $$ となります。 (式変形がわからない人は こちら を参考にしてください。) 実は、この形まで変形すると非常に高速に計算できるようになっています！ 先程の定義通りに計算する方法では、$x$ が大きいときに時間がかかるということが問題でした。 上の変形は、視覚的に説明するなら、 $$ a^{100} = a^{64} \\times{} a^{32} \\times{} a^{4} $$ のように分解しているということです。 定理3は、このような分解をしたときに、右辺の指数が必ず $2^k$ と表せるということを保証しているとも言えます。 この定理のおかげで $a^{2^k}$ の形の数さえ高速に列挙できれば良くなり、結果的に冪乗を求めるのも高速になるということです。 また、$a^{2^k} = a^{2^{k-1}} \\times{} a^{2^{k-1}}$ という関係が成立するため、$a^{2^k}$ の形の数は簡単に求められます。 以上より、次のアルゴリズムを得ます。 $a^x ~ \\text{mod} ~ m$ を高速に求めるアルゴリズム\r$x$ を2進法展開する。つまり、$x = \\sum_{i=0} c_i 2^i$ と表す。 $base \\leftarrow{} (a ~ \\text{mod} ~ m), ~ ans \\leftarrow{} (1 ~ \\text{mod} ~ m), ~ i \\leftarrow{} 1$ とする。 すべての $k ~ (i \\leq{} k)$ に対して $c_k = 0$ であれば、$ans$ を出力し終了。 $c_i = 1$ であれば $ans \\leftarrow{} ((ans \\times{} base) ~ \\text{mod} ~ m)$ とする。 $base \\leftarrow{} ((base \\times{} base) ~ \\text{mod} ~ m), ~ i \\leftarrow{} i+1$ とする。 3に戻る。 このアルゴリズムの時間計算量は、手順3から手順6のループ1回あたり $O(1)$ とみなせば、 $x \u0026lt; 2^k$ となった時点で停止するため($k$ 以降の数 $l$ において $c_l = 0$ となるから)、全体で $O(log(x))$ になります。 元々の $O(x)$ のアルゴリズムからかなり改善されました！ 実装 実は、$x$ を2進法展開するのはほとんどのプログラミング言語で必要ないです。 というのは、コンピュータは内部的に整数を2進法で表現しているからです。 ビット演算と言われるような機能を持つプログラミング言語ならこの過程を飛ばすことができます。 具体的には、$x$ を2進法展開したときの $c_0$ は、プログラム上ではx\u0026amp;1 で得ることができます。 更に、x \u0026gt;\u0026gt;= 1などで「ビットシフト」をすると、次にx\u0026amp;1をしたときには $c_1$ が得られます。 (ただし、このあたりはプログラミング言語によります。) 負の数が関わると2の補数表現など少しややこしくなりますが、$0\\leq{} x$ を仮定しているので問題ありません。 以下にC言語、C++、D言語、python3での実装例を示します。 C言語/C++ #include \u0026lt;assert.h\u0026gt; // C言語なら\u0026lt;assert.h\u0026gt; // C++なら\u0026lt;cassert.h\u0026gt; long long modPow (long long a, long long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // calculate long long ans = 1L % MOD; long long base = a; while (x != 0) { if ((x\u0026amp;1) != 0) { ans *= base; ans %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return ans; } D言語 long modPow (long a, long x, const int MOD) { // assertion assert(0 \u0026lt;= x); assert(1 \u0026lt;= MOD); // normalize a %= MOD; a += MOD; a %= MOD; // calculate long ans = 1L % MOD; long base = a % MOD; while (x != 0) { if ((x\u0026amp;1) != 0) { ans *= base; ans %= MOD; } base = base*base; base %= MOD; x \u0026gt;\u0026gt;= 1; } return ans; } python3 def modPow (a, x, MOD): # assertion assert 0 \u0026lt;= x, \u0026#34;x must be an integer greater than or equal to 0\u0026#34; assert 1 \u0026lt;= MOD, \u0026#34;MOD must be an integer greater or equal to 1\u0026#34; # normalize a %= MOD # calculate ans = 1 % MOD base = a while x != 0: if (x\u0026amp;1) != 0: ans *= base ans %= MOD base = base*base base %= MOD x \u0026gt;\u0026gt;= 1 return ans 終わりに まとめるのすごく大変だった... 内容に不備があれば 著者のtwitter に連絡していただければ助かります。 どれだけ些細な内容でも大歓迎です。 参考文献 本稿における主張、紹介した定理及びその証明はほとんど以下に依ります。 尾関和彦、 情報技術のための離散型数学入門、 共立出版(2023) 主に第5章、第6章を参考にしました。"
  },
  {
    url: "/post/abc310/",
    title: "ABC310参加記録",
    date: "2023-07-17T00:00:00+09:00",
    body: "ABC310参加記録 はじめに 本稿は、2023/7/15に開催された ABC310 の参加記録となっています。 戦績 まずは、今回の戦績です。 A,B,Cの3完で、パフォーマンスは1142で、 レーティング変化は961=\u0026gt;981(+20)でした。 今回の提出は以下の通りです。 所感 今回久しぶりに本番中にD問題が通せませんでした。 かなり悔しいとともに、何故かパフォーマンス1000以上が出て割とレートがプラスになったのは少し腑に落ちない感じです。 後で発覚したのですが、実はD問題は解けていて、配列の範囲外参照によるREで落ちていたようです。(上の提出記録にあるように、どこでRE引いてるのかわからなくて提出でバッグを試みていました。) というのも、実はD言語はAtCoder側でコンパイルオプションがリリースモードになっているようで、配列の範囲外参照を拾ってくれないんですよね。 なので、try-catchでエラーを捕まえてデバッグしようとしても無駄でした。 これマジでどうにかしてほしいんですが... 更にいうとE問題も正直ムズいと思います。 適当にDPもどきみたいなものを書いて通したんですが、解説が難解でよくわからなかった(小並感) こういうのを適当な理解で済ませると後で痛い目を見ると思うので、ちゃんとなんで解けてるのか究明しないといけないわけです。 しかし、より広い問題設定に耐えうるような包括的な理解というものは難しいものですよね。(諦観) 問題と解法 解けた問題について振り返ろうと思います。 今回試験的に問題文を丸コピしてみます。特にことわりがなければ、問題名のリンク先が引用元になっています。 A - Order Something Else 問題文 高橋君は、レストランで「AtCoder ドリンク」というドリンクを飲もうとしています。 AtCoder ドリンクは定価である $P$円を払えば飲むことができます。 また、高橋君は割引券を持っており、それを使うと AtCoder ドリンクを定価より安い価格である $Q$ 円で飲むことができますが、 その場合には AtCoder ドリンクの他に、$N$ 品ある料理の中から 1 つを追加で注文しなければなりません。$i=1,2,\u0026hellip;,N$ について、$i$ 番目の料理の価格は $D_i$ 円です。 高橋君がドリンクを飲むため支払う合計金額の最小値を出力してください。 解法 仮に他に料理を頼むなら、一品だけ頼むのが最適になります。 したがって、料理を頼まないときの金額と、一品だけ料理を頼むときの金額を全部見て、それらの最小値が解になります。 制約も十分小さいのでこれでACできます。 提出 B - Strictly Superior 問題文 AtCoder 商店には $N$ 個の商品があります。 $i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品の価格は $P_i$ です。 $i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品は $C_i$ 個の機能をもち、$i$ $(1\\leqq{}i\\leqq{}N)$ 番目の商品の $j$ $(1\\leqq{}j\\leqq{}C_i)$ 番目の機能は $1$ 以上 $M$ 以下の整数 $F_{i,j}$ として表されます。 高橋くんは、AtCoder 商店の商品で一方が一方の上位互換であるものがないか気になりました。 $i$ 番目の商品と $j$ 番目の商品 $(1\\leqq{}i,j\\leqq{}N)$ であって、次の条件をすべて満たすものがあるとき Yes と、ないとき No と出力してください。 $P_i\\geqq{}P_j$ である。 $j$ 番目の製品は$i$ 番目の製品がもつ機能をすべてもつ。 $P_i\u0026gt;P_j$ であるか、$j$ 番目の製品は $i$ 番目の製品にない機能を $1$ つ以上もつ。 解法 問題が結構ワチャワチャしていて読解が大変ですが、やること自体はシンプルです。 しっかり読み取るべき情報は、 各商品の「機能」は、1以上M以下の値からなる100項以下の数列で表される(以後、「機能数列」と呼ぶ) 「商品iと商品jが機能xを持つ」とは、どちらの商品の機能数列もxを含むことである ということです。 これを踏まえた上で、「商品iが商品jの上位互換である」ということを次のどちらかの条件を満たすことと定めます。 すべての商品iの持つ機能を商品jが持ち、逆に、すべての商品jの持つ機能を商品iが持つ。 かつ、商品iの値段が商品jの値段未満である すべての商品jの持つ機能を商品iが持ち、かつ、ある機能が存在して、商品iはその機能を持ち、商品jはその機能を持たない。 かつ、商品iの値段が商品jの値段以下である。 堅苦しく書いたのはそっちのほうが実装に落とし込みやすいかなと思っているからです。 これを正確に実装すればACが取れます。 なお、機能を持っているかのチェックは二重ループなどによる全探索でも余裕で間に合います。 提出 C - Reversible 問題文 ボールがいくつか刺さった棒が N 本あり、各ボールには英小文字が $1$ 個書かれています。 $i=1,2,\\cdots{},N$ について、$i$ 番目の棒に刺さった各ボールの英小文字は、文字列 $S_i$ によって表されます。 具体的には、$i$ 番目の棒には文字列 $S_i$ の長さ $|S_i|$ に等しい個数のボールが刺さっており、 刺さっているボールの英小文字を、棒のある端から順に並べたものは文字列 $S_i$ と等しいです。 $2$ つの棒は、一方の棒に刺さっているボールの英小文字をどちらかの端から並べた列と、もう一方の棒に刺さっているボールの英小文字をどちらかの端から並べた列が一致するとき、同じ棒とみなされます。 より形式的には、$1$ 以上 $N$ 以下の整数 $i,j$ について、$i$ 本目の棒と $j$ 本目の棒は、$S_i$ が $S_j$ と一致するか、$S_i$ が $S_j$ を前後反転したものと一致するとき、かつそのときに限り、同じとみなされます。 $N$ 本の棒の中に、何種類の異なる棒があるかを出力してください。 解法 ややこしいですが、言ってることはこうです。２つの文字列a, bが等しいということを次で定める。 aとbが等しい aを逆順にしたものとbが等しい いくつか文字列が与えられます。相異なる文字列はいくつありますか？ 素直に全探索するとO(N^2)で間に合いません。 そこで、連想配列などを利用します。 解法1: 全部の回分でない文字列と、全部の回分でない文字列の逆順を連想配列に登録して、登録数を2で割ったものと回分の和を取る。 解法2: 全部の文字列を登録する。 その後、それぞれ回分でないものを逆順にしたものが連想配列に登録されているかを見ていき、 登録されていたら、逆順にする前の文字列を連想配列から除去する。 最後に登録数を出力。 解法1はほぼ自明です。解法2は、これを行うことでもとの文字列を逆にしたものだけが残ります。 ある文字列と、その逆順文字列がどちらも与えられるパターンと、そうでないパターンについて考えると証明できそう(知らん) 回文が色々とコーナーケースになっているので気をつける必要がありますが、サンプルに載っています。 自分はアホなので解法2を取りましたが、普通に考えて解法1のほうが楽です。 提出 D - Peaceful Teams 問題文 $N$ 人のスポーツ選手がいます。 $N$ 人の選手たちには互いに相性の悪い選手のペアが $M$ 組あり、相性の悪い組のうち $i$ $(1\\leqq{}i\\leqq{}M)$ 組目は $A_i$ 番目の選手と $B_i$ 番目の選手です。 あなたは、選手を $T$ チームに分けます。 どの選手もちょうど一つのチームに属さなければならず、どのチームにも少なくとも一人の選手が属さなければなりません。 さらに、どの $i=1,2,\u0026hellip;,M$ についても、 $A_i$ 番目の選手と $B_i$ 番目の選手が同じチームに属していてはいけません。 この条件を満たすチーム分けの方法は何通りあるか求めてください。 ただし、チーム分けの方法が異なるとは、ある二人が存在して、彼らが一方のチーム分けでは同じチームに所属し、もう一方では異なるチームに所属することをいいます。 解法 私は公式解法2通りのどちらでもない解法で無理やり通したので、それを書きます。 まず、少なくとも一人がチームにいないといけないということなので、nCtを全列挙します。 nCtで選ばれたT人を、前からチーム0,1,2,...,T-1に割り当て、 残ったN-T人をN-TビットT進数と見てビット全探索します。 ビットがiの人をチームiに割り当てることにすると、 すべてのチームの分け方を探索できます。 しかしこのままだと、チームの分け方が重複する場合が存在します。 重複の数はチームiのメンバー数を$m_i$とすれば、$\\displaystyle\\prod_{i=0}^{T-1} m_i$となります。 よって、重複数で分けて総和を取り、最後に重複数で割った総和が答えになります。 最初にnCtをしているのはビット全探索パートの計算量を落とすためです。 計算量は全体で$O(N*({}_n\\mathrm{C}_t)*(N-T)^T*(チーム分けがOKかどうかの一回の判定分))$くらいかなぁ...よくわからん。 細部を説明するのは大変な上、かなり怪しい解き方なのでこれ以上は言及しません。 提出 余談ですが、公式解説の全探索とdpはもっと一般化した主張にできるんじゃないかな(できたら便利そうだな)と思っていますが、 数学無理なので無理です。(は？) E - NAND repeatedly 問題文 0 と 1 からなる長さ $N$ の文字列 $S$ が与えられます。 $S$ は長さ $N$ の数列 $A=(A_1,A_2,\u0026hellip;,A_N)$ の情報を表しており、$S$ の $i$ 文字目 $(1\\leqq{}i\\leqq{}N)$ が $0$ のとき $A_i=0$ 、$1$ のとき $A_i=1$です。 $$ \\sum_{1\\leqq{}i\\leqq{}j\\leqq{}N} (\\cdots{}((A_i\\bar{\\land{}}A_{i+1})\\bar{\\land{}}A_{i+2})\\bar{\\land{}}\\cdots{}\\bar{\\land{}}A_j) $$ を求めてください。 より厳密には、次のように定められる $f(i,j) (1\\leqq{}i\\leqq{}j\\leqq{}N)$ に対して $\\displaystyle\\sum_{i=1}^N \\displaystyle\\sum_{j=i}^N f(i,j)$ を求めてください。 $$ \\begin{equation*} f(i,j)= \\begin{cases} A_i \u0026amp; \\text{$(i=j)$} \\\\ f(i,j−1)\\bar{\\land{}}A_j \u0026amp; \\text{$(i\u0026lt;j)$} \\end{cases} \\end{equation*} $$ ただし、否定論理積 $\\bar{\\land{}}$ は次を満たす二項演算子です。 $0\\bar{\\land{}}0=1,0\\bar{\\land{}}1=1,1\\bar{\\land{}}0=1,1\\bar{\\land{}}1=0$ 解法 普通にやるとO(N^2)で間に合いません。そこで、何かしらの性質を利用する必要がありそうだとわかります。 演算が左結合であり、演算の結果取りうる値が0か1しかないということを利用して計算します。 $dp[i][j]:=$(左からi文字目まで見て、値がjであるような場合の数) としてやるとうまく行きます。 $\\displaystyle\\sum_{i=0}^{N-1} dp[i][1]$が答えになります。 正直よくわかっていませんが、始点を固定したとき同じ領域を何回も計算しているのを圧縮しているっぽいです(適当) この辺もちゃんと解けるようになりたいなぁ 提出 終わりに 今週のABCは色々とだめなところが多かったなと反省です。 ここ最近精進をちょっとサボってしまっていたのが悔やまれるので、今週はしっかり取り組みたいです。 今回出題された問題は最近の中でも特に学びが多そうな雰囲気があるので、復習もがんばります。 あと、問題文コピってくるのラクかなーって思ってやってみましたが、クソ大変でした。二度とやりません。"
  },
  {
    url: "/post/abc309/",
    title: "ABC309参加記録",
    date: "2023-07-13T00:00:00+09:00",
    body: "ABC309参加記録 始めに 本稿は2023/7/8に開催された、 ABC309 の参加記録です。 戦績 今回の戦績を紹介します。 A, B, C, D, Eの5完で、 パフォーマンスが1130で、レーティング変化が964=\u0026gt;982でした。 以下は今回の提出です。 解いた問題 A - Nine 問題概要: 各マスに異なる数字が書かれている3*3の盤面がある。整数A, Bが与えられるので、横方向で隣接しているかをせよ。ただしA\u0026lt;Bが保証される。 また、盤面は以下のとおりである。 1 2 3\r4 5 6\r7 8 9\r解法: 法則性を見るなら、Aが3の倍数の時、条件を満たすBをとることができない。したがって、必要十分条件はB-A==1かつA%3!=0となる。 また、あり得る入力のパターンが少ないので、解をすべて埋め込むのも手である。 提出 B - Rotate 問題概要: N行N列のマスが与えられる。外周を一マス右回りに動かした結果を出力せよ。 次は操作の例である。 次が操作前のマスである。 0101\r1101\r1111\r0000\r次が操作後のマスである。 1010\r1101\r0111\r0001\r解法: 解法自体は言われたことをやるだけである。計算量的には全くネックではない。 ただし、インプレースで置換しようとすると面倒くさい処理が発生することが予測される。 そこで、マス目をコピーして、片方は読み取りだけを行うようにした。 ただし、高次元の配列を参照で持つpythonなどの言語はシャローコピーとディープコピーの違いに気を付ける必要がある。 D言語も単に代入をすると同じメモリを指す参照のコピーとなるので、プロパティ関数.dupを利用して確実にコピーをする必要がある。 提出 C - Medicine 問題概要: N種類の薬を考える。薬iは処方された日を含めてa_i日間、毎日b_i錠ずつ飲む必要がある。 ここで、今日は1日目であり、すべての薬を処方された。 1日に飲む必要のある薬の総和が初めてK以下となる日を出力せよ。 解法: 薬を飲む量が減る日は全部でN日あり、それらはa_i+1日目である。よって、次のような解法で解くことができる。 始めに1日目に飲む必要のある薬の量を求める。これはb_iの総和である。 もし最初の時点でこれがK以下となっていれば、1を出力し終了する。 a_i, b_iのペアをa_iをキーにした昇順ソートし、a_iが小さい順にペアのb_iを総和から引いていく。 K以下になったとき、a_i+1を出力し終了する。 計算量はソートが支配的になり、O(NlogN)となる。 また、もう一つの解法としては、X日目に飲む必要のある薬の量がO(N)でわかるので、解についての二分探索で解くことができる。 計算量はO(NlogK)である。 どっちの解法も個人的にかなり好きであるが、二分探索のほうが汎用性がありそうだなと思う。 提出 D - Add One Edge 問題概要: N_1+N_2頂点M辺の無向グラフが与えられる。ここで、次の条件が保証される。 1\u0026lt;=u, v\u0026lt;=N_1となるような任意の2頂点は連結で、 また、N_1+1\u0026lt;=u, v\u0026lt;=N_1+N_2となるような任意の2頂点は連結である。 頂点1と頂点N_1+N_2は連結でない。 次の操作を一度だけ行う。 1\u0026lt;=u\u0026lt;=N_1, N_1+1\u0026lt;=v\u0026lt;=N_1+N_2なるu, vを選び、辺を追加する。 操作を行った後、頂点1と頂点N_1+N_2間の最短パスの長さを最大化せよ。 解法: グラフは二つの連結成分に分けられている。したがって、連結成分内で目的の点から一番遠い点同士を結ぶことで、明らかに最大化することができる。 重みが均一なグラフのパスの長さはBFS(Breadth-First search)を用いて解くことができる。計算量はO(N_1+N_2+M)となり、ネックにはならない。 提出 E - Family and Insurance 問題概要: N頂点の木が与えられる。いくつかの頂点は正の整数であらわされる「保険」を持っている。 頂点1を根として、「保険」を持つある頂点から距離が「保険」の値以下であり、かつその子孫であるようなノードは「被保険者」とする。条件を満たさないノードはは保険対象外である。 「被保険者」は何人存在するかを出力せよ。 解法: 保険の影響が親に波及することはない。したがって、根から保険の影響が及ぶかどうかを調べていけばよい。現在の保険の影響力が今いるノードの保険の影響力より小さい場合、より影響が大きいほうに乗り換えていけばよい。 実装自体はほとんどDFS/BFSそのものである。よって計算量はO(N+N-1)となる。 また、最も影響力の強いノードを優先度付きキューで管理する多点ダイクストラ法でも解くことができる。詳しくは この問題 の解説が詳しい。 提出 終わりに 今回5問解くことができた。 最近ABCで調子が良いが、気を抜かずに取り組みたいと思う。 実際、F問題は全く解法が分からなかった。 毎回画像を張り付けるのはユーザビリティ的にどうかなと思っていたので、今回は問題の概要をすべてテキストで書いてみた。 今後のエントリのスタイルは検討中である。 近況としては、 電気通信大学からチーム「A.N.Serenade」でICPC国内予選に出場した。 この感想などもやる気があれば近日中にエントリを公開したいと思う。 また、このコンテストの翌日のARC164でかなり手痛い負けをしてしまった。 普段ARCのエントリは作成していないが、忘れないようにという意味も込めてエントリを書くかもしれない。 あとから読み返して気が付いたが、ですます体が混在していて最悪なことになってしまった。"
  },
  {
    url: "/post/sorttech/",
    title: "unstableをstableにする小技",
    date: "2023-07-03T00:00:00+09:00",
    body: "unstableをstableにする小技 はじめに 先日(2023/7/1)の ABC308 のC問題にややこしいソート問題が出ました。 本稿はその問題を簡潔に解く実装のアイディアの紹介です。 無理やりstable化 標準ライブラリで一番簡単に使えるソートは安定ソートでないことが多いです。 このため、競技プログラミングでよくある2値以上を取る要素のソートのときなどに、 もとの順序が破壊されて困ることがあります。 これを解消するには、比較関数を自炊してソートに渡してあげればよいです。 例えば、以下のような構造体のソートを考えます。 struct pair { int age; int id; } この構造体を次のルールに従って並べ替えます。 ageが若いほうが先頭 ageが同じなら、idが小さいほうが先頭 このとき、次のような実装で解決することができます。 pair[] person = new pair[](N); // ... // 省略 // ... bool Less (pair x, pair y) { if (x.age == y.age) { return x.id \u0026lt; y.id; } return x.age \u0026lt; y.age; } // 比較関数を渡す。 person.sort!(Less); これ、賢いです。 多分3変数以上に拡張可能です。 さらに、stableにしたいという目的以外でも応用可能です。 例えば、 この問題 で、 構造体に座標を突っ込んでいき、このソートをかければ 隣接要素が等しいものが一つでもあればYesというふうにできます。 (とは言ったものの、特に理由がなければ普通にstd::mapなりなんなりを使いましょう) おまけ: C言語での文字列ソート C言語から始めた人は文字列のソートに 結構苦戦したことある人が多いんじゃないかと勝手に思っています。 せっかくソート小技のエントリなので、サンプルコードを貼り付けときます。 次の問題を解け N個の長さが10以下の文字列が与えられます。これを辞書順に出力してください。 入力形式 N\rS_1\rS_2\r.\r.\r.\rS_N-1\rS_N\r解法1: 二次元配列で楽するアレ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // T[i]へのポインタが引数なので、char **への変換からのデリファレンスが必要 int mystrcmp (const void *x, const void *y) { return strcmp(*(char **)x, *(char **)y); } int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char S[N][11]; char *T[N]; for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%s\u0026#34;, S[i]); T[i] = S[i]; } // ソートする qsort(T, N, sizeof(char *), mystrcmp); // 出力 for (int i = 0; i \u0026lt; N; i++) { printf(\u0026#34;%s\\n\u0026#34;, T[i]); } return 0; } 解法2: 一次元配列で文字列を受け取る #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // T[i]へのポインタが引数なので、char **への変換からのデリファレンスが必要 int mystrcmp (const void *x, const void *y) { return strcmp(*(char **)x, *(char **)y); } int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char S[11*N]; char *T[N]; int idx = 0; for (int i = 0; i \u0026lt; N; i++) { T[i] = \u0026amp;S[idx]; // 入力を受け取る char input[11]; scanf(\u0026#34;%s\u0026#34;, input); for (int j = 0; input[j] != \u0026#39;\\0\u0026#39;; j++) { S[idx] = input[j]; idx++; } // 終端文字も忘れずに S[idx] = \u0026#39;\\0\u0026#39;; idx++; } // ソートする qsort(T, N, sizeof(char *), mystrcmp); // 出力 for (int i = 0; i \u0026lt; N; i++) { printf(\u0026#34;%s\\n\u0026#34;, T[i]); } return 0; } どちらも自動変数に文字列を積んでおいて、それらへのポインタを並べ替えることによってソートを実現しています。 解法1は楽ですが、一つの文字列あたりの長さが不定のときには取り回しが悪いです。 解法2は拡張性がありますが、シンプルに面倒くさいです。 結論: 動的配列が簡単に利用できる言語を使おう！(すみません) 余談 方法2は競プロフレンズさんの実装で知りました。 C言語はこういう謎テクが多くて困っちゃう。"
  },
  {
    url: "/post/abc307/",
    title: "ABC307参加記録",
    date: "2023-06-27T00:00:00+09:00",
    body: "ABC307参加記録 はじめに 本稿は、2023年6月24日に行われた ABC307 の参加記録です。 戦績 今回の戦績です。 今回はパフォーマンス1166で、 レート変動は842-\u0026gt;879でした。 コンテスト中にA,B,C,Dの4完することができました。 また、コンテスト後にE問題を通すことができました。 解いた問題 A - Weekly Records 問題文に書いてあることをそのまま行います。$A_i$があまり大きくないので普通にintでOKです。 私は前から足していって、7の倍数番目の番号のとき出力とリセットをしました。 ただし、通常プログラミング言語では0-indexedなので、i+1を考える必要があります。 (詳細は提出コードを参照) 提出 B - racecar $N$が十分に小さいので、すべての$i$,$j$について$S_i$と$S_j$の連結が回文になるかどうかをチェックする方法でOKです。 二重ループなどで解くと良いでしょう。 C言語で解くなら、不定長の文字列を受け取るテクニックが使えます。 まず、charの配列を$51*N$程度で宣言します。 その後、char*の配列を$N$要素で宣言して、 各char*の$i$番目の要素が$S_i$の先頭を指すようにすると省メモリで扱えます。 具体的には次のようにします。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); char SS[51*N]; char *S[N]; int len[N]; int idx = 0; for (int i = 0; i \u0026lt; N; i++) { char tmp[51]; scanf(\u0026#34;%s\u0026#34;, tmp); int j = 0; S[i] = \u0026amp;SS[idx]; for (; tmp[j] != \u0026#39;\\0\u0026#39;; j++) { SS[idx++] = tmp[j]; } len[i] = j; SS[idx++] = \u0026#39;\\0\u0026#39;; } } うーん、C言語辛い！w 提出 (C言語ではないです。) C - Ideal Sheet 今回の激ヤバ問題です。 C問題なのにdifficultyが1200を超えています。(結構な人がスルーしたみたいです。) 要は、いい感じに文字列を組み合わせて、与えられた模様を作れるか？という問題です。 結構激重実装問題っていう風に言われていますが、 私はむしろ、どうやって解くか？という部分が一番大事になるんじゃないかと思いました。 というのも、シートAとシートBを張り合わせる土台を適当に超巨大に作ってしまうと 計算量がエラいことになってしまうからです。 私の方針としては、概ね次のような感じです。 シートA, B, Xの透明部分を長方形であることだけを保ったまま可能な限りカット 土台としてX(をカットしたもの)と同じサイズのものを用意する シートA, Bをはみ出さないように貼り付ける手順を全探索 土台とXが一致しているかチェック というような感じで解きました。 ポイントが、土台をXのカットと同じサイズにすることです。 明らかにこれが土台の限界の小ささになります。 マージンを取りすぎると全探索が多くなりすぎてTLEするみたいです。 というわけで気合でACできました。 こういう「カットできるとこをカットする」みたいな操作は絶対にC言語で実装したくないです。(強い意思) 提出 D - Mismatched Parentheses 文字列から「有効な括弧列」を削除する問題です。 有効な括弧列を処理するのにはスタックが非常に向いています。 というのも、その定義の一つに 「連続する()を削除することを0回以上繰り返して空文字列にできるもの」 というものがあるので、 明らかに)を見つけたら(までスタックから取り除く という方法で有効な括弧列を除去することができてしまいます。 後は現在スタックの中に(が何個あるかという情報を持っておくと、 )からスタックを削っていって(が見つかるかどうかを判定することができ、 残すべきところと残すべきでないところを判断することができます。 ただ、私は(の個数を管理するということまで思い至らなかったため、 「たどっていってる途中で(が見つかる前にスタックが空になってしまったらansに追加する」 という感じで解きました。計算量はO(N)です。 提出 E - Distinct Adjacet 見た目がなんかいかつそうな問題です。 まず、問題を単純化してみます。 例えば、輪っかになっていないという仮定をしてみます。 左から一人ずつ決めていくとして、 受け取ってはいけない数字は一つ左の人のみに依存するので、最初の人がM通り、 次の人からは全員M-1通りになり、答えは$M*(M-1)^{N-1}$になりそうです。 フムフム、結構自由度が高いんだなと考えながら、 輪っかの方の考察に戻ってみます。 輪っかの方もほとんど同じで、最後の一人以外は一つ左の人のみに依存するので、$M-1$通りになりそうです。 最後の一人は、最初の一人にも依存するので、状況が少し複雑になります。 最初の一人と最後から二番目の人が同じ数字のとき このとき、明らかに$M-1$通りになります。 最初の一人と最後から二番目の人が違う数字のとき このときは$M-2$通りです。 最後から二番目の人が最初の人と同じ数字である場合の数を考えるには、 最後から三番目の人が最初の人と同じ数字かどうかを知る必要があります。 アレ、ややこしくなってきましたね。 それならいっそ「$i$番目の人が、最初の人と同じ数である場合の数」と、 「最初の人と違う数である場合の数」を考えればよいのではないでしょうか？ これなら順々に計算できそうです。 というわけで、DPします。 $dp[i][j] := i人目が状態jであるような場合の数$ とします。ここで、$j=0$は一人目と同じ数字、$j=1$は一人目と違う数字であるとします。 初期値は、 $dp[0][0] = M$, $dp[0][1] = 0$となります。 漸化式は $dp[i][0] = dp[i-1][1]$ $dp[i][1] = (M-1) * dp[i-1][0] + (M-2) * dp[i-1][1]$ となります。 これをあまりを取りながら計算して、$dp[N-1][1]$が解になります。 DP難しいよ〜 提出 終わりに 最近緑になれましたーヤッター 競技プログラミング死ぬほど難しいけどなんとかがんばります。 あと、ICPC出れそうです。そっちの方も適当にがんばります。"
  },
  {
    url: "/post/katex/",
    title: "KaTeX導入してみる",
    date: "2023-06-23T00:00:00+09:00",
    body: "KaTeX導入してみる KaTeXを使ってみる $\\LaTeX{}$風の数式を表示できるJavaScriptライブラリ(らしい)である$\\KaTeX{}$を導入してみました。 本稿では、$\\KaTeX$の紹介と、自分がどうやって導入したかを説明します。 注意！ 筆者は$\\KaTeX{}$及び$\\LaTeX{}$に全く詳しくありません。 内容がガバガバかもしれないです。 使い方 ここ に丁寧に書いてあるので、こっちを参考にしてください。 私は手元で動かしたい人向けにリポジトリから窃盗する手順だけ紹介します。 リポジトリは こちら です。 アクセスするとこんな画面になるはずです。 右下の方のReleasesの中のlatestがついてるやつをクリックしましょう。 こんな画面になるはずです。(私が作成してるときはv0.16.7でした。) tarballかzipをダウンロードして解凍しましょう。 こんなファイル群が出てくるはずです。 これらをhtmlファイル内で読み込めば使用できます。 下は実際にこのページで使用されている設定です。 (上で貼ったページのものをちょっぴり差し替えただけです。ファイルパスは自分の環境に合わせて変える必要があります。) \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../katex/katex.css\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/katex.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;../katex/contrib/auto-render.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false}, ] }); }); \u0026lt;/script\u0026gt; 数式のフォントサイズが気に入らなかったら、head内に次を足してください。(数字はお好みで) \u0026lt;style\u0026gt; .katex { font-size: 1em !important; } \u0026lt;/style\u0026gt; もしくはdivとかの中だけフォントサイズをいじるっていう方法もあります。 KaTeXテンプレート $\\KaTeX{}$を使うときは、インライン数式なら$で囲みます。 行単位なら$$で囲みます。 そうしないとうまく動かないです。 基本の使い方は$\\LaTeX{}$と同じなので、$\\LaTeX{}$記法はググると良いです。 よく使いそうな数式を紹介します。 行番号あり数式 $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ $$ \\begin{equation} \\int_0^{2\\pi{}} \\sin{}x dx = 0 \\end{equation} $$ 複数行に渡る数式(行番号一つ) $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ $$ \\begin{equation} \\begin{split} \\sum_{k=0}^{n} {}_n \\mathrm{C}_k \u0026amp;= {}_n \\mathrm{C}_0 + {}_n \\mathrm{C}_1 + \\dots \\\\ \u0026amp;= 2^n \\end{split} \\end{equation} $$ デカ括弧 $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ $$ T = 2\\pi{} \\sqrt{ \\frac{h}{g} \\left( 1+\\frac{2r^2}{5h^2} \\right) } \\left( 1+\\frac{\\theta{}^2}{16} \\right) $$ なお、絶対値やその他の括弧も基本上の例に従う。 インラインデカ数式 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ 通常 $\\frac{a}{b}$ $\\sum_a^b$ $\\int_a^b$ デカ $\\dfrac{a}{b}$ $\\displaystyle\\sum_a^b$ $\\sum\\limits_a^b$ $\\displaystyle\\int_a^b$ $\\int\\limits_a^b$ これはinline表示をdisplayモードに矯正するコマンドです。一番適したものを使いましょう。 単位をつけるために微妙に間あけるやつ $1.0\\,\\mathrm{m}$ $1.0\\,\\mathrm{m}$ 数式環境下での立体は基本的に\\mathrm{}を使っておけば良い。 $\\KaTeX{}$が対応してるかなどは知らないが、 物理単位などによっては組み込みやパッケージ等でより良いものが用意されていることがあるので、 それらを調べてから使うとなお良い。 終わりに あくまでテキストベースなの良いですよね。($\\TeX{}$記法が再利用性が高いかは置いておくとして) ただ、思ったより色々と大変でした。 特に、markdownのパースのせいで$\\KaTeX{}$が崩されたりするのはかなり罠だと思います。 個人的な使い方としては、htmlに変換した後厳重にチェックした後放流するって感じになりそうです。"
  },
  {
    url: "/post/abc99c/",
    title: "ABC99C - Strange Bank",
    date: "2023-06-13T00:00:00+09:00",
    body: "ABC99C - Strange Bank はじめに 個人的に比較的難しく、教育的な動的計画法の問題に出会ったので、メモを残しておく。 防備録的な色合いが強いので、私にとって明らかなことは書かない。 問題 ABC99C Strange Bank 思考 もし仮に、6冪の金額のみを用いることができるという制約なら単純な6進数変換の問題である。 しかし、本問では9冪の金額も用いることができるため、最適解が自明な貪欲法でない可能性が高い。 例えば、 「6冪と9冪のなかで今の金額に一番近い値を採用し、それを続ける」 という貪欲法を考える。 実はこの貪欲ではテストケースすら突破できない。(確認済み) 貪欲で解ける可能性が低そうなので、次に全探索を考えてみる。 自明な全探索は、log_6(N)ビット6進数とlog_9(N)ビット9進数によるビット全探索だと思われる。 計算量はO(6^{log(N)}9^{log(N)}) これは明らかに間に合わない。(実は少し工夫した全探索による解法が存在するので後述する) 解法 一回引き出したら口座に戻せないという制約上、部分問題に分割することができる。 すなわち、x円を引き出す最小手順がわかっていれば、もう少し大きな金額yに対して、y円を引き出す最小手順がわかる。 このことに気づくのは比較的用意だと思う。 さて、部分問題を精査していく。 私は次に述べる点に気づかなかったため、動的計画法を構築できなかったのだが、具体的な遷移は「1手前」を考えるだけで良い。 私はずっと、6冪と9冪が使えるということは、「6冪と9冪に引っかからないけど6や9の倍数である数」への遷移を毎回考える必要があると思いこんでいた。 つまりは、 dp[x]を計算するときに、min(dp[x-6]+1, dp[x-12]+2, dp[x-24]+4, ...)というようなことをしなければだめだと思っていたということだ。 しかし実際は、dp[x-12]やdp[x-24]の値はdp[x]に到着する前に計算されており、更にそれを織り込み済みでdp[x-6]が計算されている。 つまり、遷移のときに気にする必要があるのは1回で引き出せる金額の更新だけなのである。 結論として、 dp[x] = min(dp[x-diff]) (diff := {x | a \u0026lt;- N, 6^a, 9^a}, k \u0026lt; 0 (dp[k] = infinity), dp[0] = 0) という遷移で計算可能である。 ある金額xに対して、高々logN通りの更新候補が存在するため、計算量はO(NlogN)で抑えられる。 また、全探索でも解くことができる。 「任意の引き出し方は、6進数成分と9進数成分に分解できる」 という事実を用いると、引き出す金額を2つに分割して、6進数/9進数表現に直したときのビットの総和が候補値になる。 分割の全探索がO(N)、各ケースO(logN)でx進数に変換できるから結局O(NlogN)で解くことができる。 上で述べた自明な全探索よりも少し工夫が入っている。 どちらが難しい解法かと言われると微妙だが、個人的には部分問題に分けるほうが自然かなと感じる。 追記 上の遷移式におけるNは、自然数全体の集合です。また、\u0026lt;-は集合の元であることを示す記号です。 提出 参考文献 けんちょんさんによる解説 動的計画法について"
  },
  {
    url: "/post/abc304/",
    title: "ABC304参加記録",
    date: "2023-06-05T00:00:00+09:00",
    body: "ABC304参加記録 はじめに 競技プログラミングに対してやる気がわかない夜は、コンテストの参加記録を書こう。 そうしよう。 というわけで、 ABC304 の参加記録です。 戦績 残念ながらジャッジにトラブルがあったようで、今回のコンテストはunratedになってしまいました。 そのため特にレート変動はありません。 今回の提出結果はこちらです。 AからEまでの5問正解することができ、全部で3ペナルティ食らいました。 問題と解法 コンテスト中にACできた問題についてかるーく振り返ります。 A - First Player A問題です。難しかった\u0026hellip; やること自体は簡単(に理解できるもの)ですが、この問題プログラミング始めたばっかりの人結構大変なんじゃないんですかねとか思いました。 この問題は剰余演算を用いることで簡単に解くことができます。 具体的にはx番目に最年少の人が来たとするとき、0\u0026lt;=i\u0026lt;=N-1であるiを用いて(x+i)%N番目の人の名前を出力することでACできます。 要はインデックスの余りをとってあげることでちょうどテーブルを一周できるわけです。 これよりもシンプルで初心者向けの解法が思いつきません。 提出 B - Subscribers 見た目がヤバいですね。ちなみに実際ヤバいです。 私の脳裏に これ が思い浮かびました。 「切り捨てる」という操作を、「元の数から、元の数を10^x^で割った余りを引く」という操作に置き換えます。 これを頑張ってifやswitchなどで場合分けするとACできます。 途中で混乱しないようにしましょう(1敗) これWA出たとき台パンしそうになった() あと関係ないですが、この問題名が「Subscribers」になっているのはYoutubeの登録者数表示に準拠してるのかな？とか思ったり(知らんけど) 提出 C - Virus これもなかなか難しい！ AtCoder Problems上で確認したところ、difficultyは366らしいです。 まず、制約を見ます。 割と制約がゆるそうなので、雑な全探索が通りそうな気がします。 ある感染者から感染する人を探したいとき、自分自身以外のN-1人を1回ずつ見れば十分なことが分かります。 また、探索の基準にする感染者をいちいち記録しておかなければいけません。 そこで、キューを使ったアルゴリズムを考えました。 キューに人1を入れる。 キューから人を取り出し、その人に対して、「調べ済み」の印をつける。 「調べ済み」のしるしがついていない人で、キューから出した人との距離がD以下の人を見つけたらその人に「調べ済み」の印をつけてキューに入れる。 キューが空でなければ手順2に戻る。空なら手順5に進む すべての人について、「調べ済み」の人はYes、そうでない人はNoを出力する。 よくよく見るとこれは「距離がD以下の人同士で無向辺をつないだグラフのBFS」とみなせます。 解いてるとき全く気付かなかった。。。 グラフとして見れたらもっと早く処理できたかもしれないなぁと思います。 提出 D - A Piece of Cake これ、難しくないですか？？？ 私は結構苦戦しました。 まず、制約を見た感じ長方形領域を一つ一つ見ていく方法は絶対に不可能なことが分かります。 ということで、「同じ領域に存在するイチゴならば同じ情報になる」というような情報の圧縮を考える必要があります。 逆に言うとイチゴの数はそこまで多くないわけですから、そのような圧縮が存在すれば簡単に解けるということです。 結論から言うと、「ケーキを切り分ける直線のインデックス」を用いるとうまくいきます。 例えば、一つのイチゴに対して順序対(X, Y)を以下のように定義します。 X := (イチゴのx座標よりも小さい最小のaのインデックス) Y := (イチゴのy座標よりも小さい最小のbのインデックス) 一つ注意として、制約が0 \u0026lt; a, bなのでa, bの配列の先頭に0を追加しないと上の定義ができません。 私は0を追加して解きました。 このようにすると、同じ領域に存在するイチゴは同じ順序対が割り当てられます。 あとはこれらを連想配列などで管理します。 mを求めるときにも少し注意する必要があります。 上の方法では切り分けた領域をすべて見ているわけではないので、一つもイチゴが乗っていない領域が存在するかどうかが分からないという問題があります。 これは、(連想配列の登録数)と(A+1)*(B+1)の大小関係で確定させることができます。 後者がより大きい時は必ずイチゴが乗っていない領域が存在します。 ということでACをとることができます。 提出 E - Good Graph なんか奇跡的に解けた問題です。 「頂点x_iとy_iを結ぶパスが存在しない」という条件は、まさしくx_iとy_iが連結でないということを示しています。 そのような予想の元、クエリにどうこたえるかを考えてみます。 頂点p_iとq_iを結ぶことでよいグラフが崩れるかどうかを判定するということは、 p_iとq_iの所属する連結成分が分かれば判定可能です。 具体的に言うと、あるjに対して、p_iとx_jが同じ連結成分に属していて、かつq_iとy_jが同じ連結成分に属していたらだめですね。 グラフGのそれぞれの連結成分を、ある代表元を用いて管理することで上の判定問題を高速に解くことができます。 \u0026hellip;はい、まんまUnion-Find Forestです。 具体的な解法としては以下のようになります。 グラフの連結成分を構築。 x_iとy_iの代表元を見つける。それをX, Yとして、(X, Y)と(Y, X)を連想配列などに追加しておく。 p_iとq_iの代表元を見つける。それをP, Qとして、(P, Q)が連想配列に登録されていたらNo、されていなければYesを出力する。 このようにしてACできます。 最近Union-Findもといdsuを用意したので、ドンピシャで使いどころが来てくれてなかなかうれしいです。 ただ、私のUnion-Findやたら動作が遅いのですごく心配です。 経路圧縮とUnion by sizeやってるはずなんだけどなぁ 提出 終わりに 最近D問題とかE問題が解けるときがあってうれしい！ 引き続き競技プログラミング(というかAtCoder)に取り組んでいきたいと思います！ ここまで読んでいただきありがとうございます。 それではまた次のエントリで。"
  },
  {
    url: "/post/mmacontest15/",
    title: "MMA Contest 015 参加記録",
    date: "2023-06-01T00:00:00+09:00",
    body: "MMA Contest 015 参加記録 はじめてのオンサイト、行ってキタ！ 電気通信大学にはMMAという格闘技みたいな名前のサークルがあります。 先日2023年5月28日、そのサークルの有志がオンサイトコンテストを開いていたので、(ヒマなので)参加してきました！ MMA Contest 015というオンサイト競技プログラミングコンテストを開催します！ 大学HPにもリンクを貼ってもらうことができました��� 教室は200人が余裕で入る教室のB202で実施します。 まだまだ参加枠に余裕があるので、参加登録お待ちしております！https://t.co/Jrqil1Yvpg \u0026mdash; 電気通信大学 MMA (@uecmma) May 8, 2023 明日，東京都調布市にある電通大でレート不問初中級者向け予選なし誰でも来てくれオンサイトコンテストを開催します！ コンテストページはYukicoderを使います．まだ間に合うので明日あいていればお越しください～https://t.co/0lkHO7Xeb8 \u0026mdash; Nafmo@固定イベント (@Nafmo2) May 27, 2023 参加した感想(?) コンテストが行われた教室は、電気通信大学の中でもかなり大きい方の教室だったのですが、思っていたよりもたくさん人がいてびっくりしました。 また、僕よりも若い方から社会人の方まで様々な方がいらっしゃったそうです。 すごい非日常感で面白かったです。(小並感) その日にARCがあるということと、参加者に知り合いが一人もいないという事情から終了後即帰ってしまったので、 他の方がどのような交流をしていたのかよくわかっていませんが、とても楽しそうな雰囲気でした。 ↑ココです。 初心者向けコンテストと謳っていたものの、私にとって難しい問題が多く、良い練習になりました。 運が良かったのか、12問中5問正解することができ、全体83位で終わりました。 2時間を超えるコンテストは初めてだったので、結構疲れました。 解けた問題の概要と解法 自分が解けた問題をてきとーに振り返ります。 コンテストページ(yukicoder) A - MMA文字列 コンテストが始まった瞬間から会場中「ｶﾀｶﾀ\u0026hellip;」という音が響きだし、結構焦りながら解きました。 シンプルな問題ですが、S[0] == S[1] \u0026amp;\u0026amp; S[1] == S[2]というケースが意外と落とし穴になっています。(1WA) 提出 B - Nafmo、A+Bをする 繰り上がりをしない2進数の足し算です。 私は配列に値を入れて、XOR演算(片方が1、片方が0のときのみ1)をシミュレートする感じで解きました。 注意点としては、文字列Sをbit列と見立てたとき、S[0]はその見た目に反して最上位bitになります。 AtCoderのコンテストの方でこれに気づかずに一生WAしていたことがあるので、今回はしっかり対応できました。 提出 C - Two Countries within UEC 作問のsepa_38さん曰く、「皆さんにWAをお配りするために作りました」だそうです。 クソむずかった\u0026hellip; はじめはC問題ということもあって、ちょっと考えたら解けるだろう！と思って考察していました。 実際、$f$が$x$の倍数であるときにはシンプルになります。 この問題を言い換えると、「xが与えられる。法をPとして$xy=f$であるようなyの個数を求めよ」となるので、 前述のようなケースでは法をPとしてy=f/xであるようなyを求めるだけです。 これは割り算ですぐできます。 しかし、その他のケースについてはどうしても難しいです。 上の条件を更に噛み砕くと、「$x$、$f$が与えられる。ある(0を含む)自然数$k$が存在して、$xy=f+kP$が成立するような$y$を数え上げよ」 という問題になります。 これを変形していって、「$y=(f+kP)/x$が成立するような$(k, y)$の組を数え上げよ」とまで持っていきました。 しかし、これは普通にやったらめちゃくちゃ計算量がかかります。 少なくとも私は全探索以外わかりません。 ということで、方針転換。 もしかしたら逆元というものが使えるのではないか？と考え、google先生に聞きました。 結果、$x$と$P$が互いに素であるとき、 $[0, P-1]$にただ一つの$x^{-1}$が存在して、$P$を法として$x\\cdot x^{-1}=1$である。 という結果を得ました。やった！これならPを法として$y=f \\cdot x^{-1}$(右辺は整数)が成立するようなyを数え上げる問題に帰着できる！ ということで実装します。 とはいっても逆元なんて使ったことなく、 実装方法よく知らなかったので、ネット上に落ちてたc++のコードをD言語で動くように改造して無理やりACしました。 なんかふぇるまーのしょうていり(？)を使っているそうです(バカ) また、$x$と$P$が互いに素でないとき、任意の$y$に対して友好度が0であることに気をつける必要があります。 modpow関数をバグらせまくってかなりペナを喰らいました。 提出 D - Skill Tree 問題文がゴツくて一瞬ビビりましたが、理解してしまえばそこまで複雑なことを聞いていないことがわかります。 ポイントは2つです。 ある技を覚えるために、事前に覚えておく必要のある技がある。 ある技を覚えるために、一定のレベルに達している必要がある。 これは技を覚える順番に依存関係があるということです。 グラフ表現に落とし込むことで機械的に処理できそうな感じがしますね。 まず、有向グラフを構築します。 技一つ一つを一つのノードと見て、その技を覚えることでアンロックされる技へと有向辺を張ります。 まずは覚えられるかどうかをどう判定するか考えます。 最初に覚えているのは技1のみであるので、ある技が習得可能な必要十分条件は、 技1を含む連結成分にその技が含まれていることです。 これはdfsなどを用いて簡単に判定できます。 また、ある技を覚えるために依存している技はちょうど1つです。 つまり、技の依存関係は一本道になり、分岐しません。 この性質から、技を覚える必要コストも容易に算出できます。 (ある技を覚えるために必要なレベル)=max((それが依存している技を覚えるのに必要なレベル), (それ自身を覚えるために必要なレベル)) というように、一種の動的計画法のように計算することができます。 これでクエリ2に答える目処が立ちました。 残りはクエリ1です。 まず愚直に考えます。 これを判定するには、技1のノードから順番に技を見ていって、 初めてxを超えるコストを持つノードについたときに今までたどったノードの数を答えることで達成できます。 換言すると、「技を覚えるためのコストを昇順に並べたとき、xは列の何番目に入りますか？」というものです。 よって、配列にコストを全部入れてソート→xの入る位置を2分探索で求めるという操作で答えることができます。 計算量は言及しませんが、これで十分高速に動作し、ACが取れました。 クエリ1の解法が面白かったです。 提出 E - Factorial to the Power of Factorial to the\u0026hellip; 見た目がゴツい！ 怖すぎる！ さて、まず指数部分がデカすぎてよくわからないので、条件を弱めた問題を考えます。 「N!はPで何回割れますか？」 という問題は典型問題で、 ルシャンドルの定理 を用いて解くことができます。 さて、残りの問題を考えましょう。 N!をx乗するとき、明らかにN!の素因数の個数はx倍になります。 (明らかにと言っていますが、私の中ではココが一番の山場かなと思います。) そこで、答えは上の問題の答えを$N!^{N!}$倍したものになります。 $N!:=N \\cdot (N-1) \\cdot (N-2) \\cdot (N-3) \u0026hellip; 2 \\cdot 1$であるから、指数部分をほぐすことができて、 $N!^{(N!)} = N!^{(N \\cdot (N-1) \\cdot \u0026hellip;2 \\cdot 1)}$ $= N!^{N^{{N-1} \\dots ^{2^{1}}}}$ となります。(二番目の変形は指数法則を用いています。) N乗の計算は繰り返し2乗法で高速にできるので、これで$N!^{N!}$を$O(NlogN)$で求められました。 というわけで適宜余りをとっていけばACになります。 ABCのD問題に出そう！解けてｳﾚｼｲ\u0026hellip; 提出 終わりに コンテスト面白かったです。また開催してほしい\u0026hellip; 参加記録の更新をずっとサボっててごめんなさい。 更新をサボっている間にメイン言語を切り替えたり、longest streakでトップ1000に入ったり、400ACカウント達成したり、色々ありました。 最近は大半をmarkdownで書いてサボっているので、もっと更新できたらなと思います。 競技プログラミング以外の話題も書きたいとは思っているんですが、なんか面倒くさくてサボってしまいます。助けてくれ。 それでは次のエントリで。"
  },
  {
    url: "/post/abc300/",
    title: "ABC300参加記録",
    date: "2023-05-01T00:00:00+09:00",
    body: "ABC300参加記録 ABC参加しました。 今回も ABC300 に参加してきました。 久しぶりに参加記録を書きます。 戦績 まずは、今回の戦績をざっくり振り返ります。 以下は今回の提出です。 今回は時間内にA, B, Cの3問を解くことができました。 また、コンテスト後にD問題を解くことができました。 レート変動はこちらです。 何とかプラスのレートを得ることができました。速く700行かせてくれー 問題と概要 今回解けた問題の軽い解説(?)をしていきます。ざっくりです。 A - N-choice question 問題文は以下の通りです。 問題文に書いてあることをその通りにやります。A+Bを変数に持っておいて、何番目のC[i]と一致するかを見つければよいです。 ループとstdinの扱いができればACできると思います。 提出例です。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int N, A, B; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;N, \u0026amp;A, \u0026amp;B); for (int i = 0; i \u0026lt; N; i++) { int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); if (tmp == A + B) { printf(\u0026#34;%d\\n\u0026#34;, i + 1); break; } } return 0; } B - Same Map in the RPG World 問題文は以下の通りです。 この問題はB問題のわりにかなり難易度が高かったようで、 AtCoder Problems 上で400くらいのdiffがありました。 シンプルに言うと文字列の一致判定問題といえるでしょう。 ただし、片方の文字列に対して2つの操作を許されています。 列を一つずつ右にずらす。一番右の列は一番左にワープする。 行を一つずつ上にずらす。一番上の列は一番下にワープする。 サンプルが問題ページに乗っているので気になる人は見に行って見てください。 さて、この問題は十分に制約が緩いので、操作1, 2のすべての組み合わせを行うことができます。 具体的には、操作1をH回、操作2をW回行う2重ループをすることで正誤判定をすることができます。 典型テク「全探索ができるならやろう」です。 C言語での実装例 C - Cross 問題文は以下の通りです。 なかなかいかつい見た目ですね。 少し整理しましょう。 まず、問題文において「サイズnのバツ印」は(ざっくり)以下のように定義されています。 あるマスが#で、斜め4方向にn個の#が隙間なく続いている。 斜め4方向にn+1こ#が続いてはいけない。(これを許すとサイズ1~nのバツ印とn+1のバツ印が被っちゃう) サンプルです。 #...#\r.#.#.\r..#..\r.#.#.\r#...#\rこれはサイズ2のバツ印です。サイズ1のバツ印を含んでいますが、ルール2により却下されます。 .#...#\r..#.#.\r...#..\r..#.#.\r.#...#\r#.....\rこれは一辺だけサイズ3ですが、ルール1によりサイズ2と判定されます。 問題としては、(よくわからんけど)割と親切な文字列が与えられるので、「サイズ1~min(H, W)」のバツ印が何個あるか判定してくださいというものです。 解法としては、あるマスが#だった時にそこを中心としてバツ印がつくれるか？をすべてのマスに対して適用しました。 制約が比較的緩いので、上のルールでも十分動作します。 関数化したらこんな感じです。 int cross_size (int W, int H, int x, int y, char C[][W + 1]) { for (int i = 1; ; i++) { if (W - 1 \u0026lt; x + i || x - i \u0026lt; 0 || H - 1 \u0026lt; y + i || y - i \u0026lt; 0) { return i - 1; } if (C[y + i][x + i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y + i][x - i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y - i][x + i] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; C[y - i][x - i] == \u0026#39;#\u0026#39;) { } else { return i - 1; } } } 提出例 D - AABCC 問題文は以下の通りです。 出、出た～！数学問題奴～www なんかNの制約が割と大きそうなので、単純な探索だと厳しいという予想を立てました。 手元のカードとして「エラトステネスの篩」というものがあったので、素数を探索するのは下準備さえあればできるということを考えながら思案。。。 典型テクニック「変数が一つ以外決定されているときを仮定」をやってみると、b以外を固定すればすぐに答えられそうというのがわかる。 また、aとcは大体10^3^~10^6^くらい探索すればよいので二重ループしても間に合いそうだな\u0026hellip;という考えに至る。 求めたNが被ることは\u0026hellip;素数だから多分ヨシッ！ したがって、以下のアルゴリズムを考えた。 エラトステネスで大体10^6^くらいまで素数列挙 a, cをa^2^+c^2^ \u0026lt; Nの範囲で探索、それぞれのケースに対してbをいい感じに数え上げる。 さて、具体的にどうやってやるべきだろうか。 例えばあるa, cに対してbのとりうる最大と最小を考えると、数直線上の閉区間の素数の数を即座に答える必要がある。 アッ！累積和使えるやん！ ということで、あとは実装したら完成。AC取れました。ただし、手順2のbをいい感じにっていうところがちょっと面倒くさいので、ここは丁寧に考える必要あり。 提出例 D問題はコンテスト中に間に合いませんでした。残念。 また、解説を見た感じ、素数の数があまり多くないからエラトステネスからのa, b, cの全探索で解けるそうです。 実際に、やってみた。 全探索の提出例 これは今の私には思いつかないですね。 E - Dice Product 3 何ともならんかったわ。(事後報告) (画像は ここ から剽窃してきた。) 終わりに まず、一か月くらい記事更新をさぼってしまって本当に申し訳ない。 なかなか記事更新にも時間がかかってしまうというのもありますが、できるだけ参加記録を公開したいな～(願望) 私事ですが、Bootcamp For Beginnersのmediumが終わりました。 あと、longest streakが100日超えてました。 これからも頑張ります。 それではまた次のエントリで。"
  },
  {
    url: "/post/abc296/",
    title: "ABC296参加記録",
    date: "2023-04-03T00:00:00+09:00",
    body: "ABC296参加記録 ABC参加してきました。 こんにちは。今回の ABC296 も参加してきましたので、軽い参加記録です。 戦績 今回の戦績についてです。 今回はA, B, Cの3完、パフォーマンス650で、レート変動は627→630(+3)でした。 ギリ勝ちでした。 問題と解法 A~Dの4問の解法を紹介します。 A - Alternately 問題分は以下のとおりです。 男性または女性同士が隣り合っているかどうかを判定する問題です。シンプルに解くなら、文字列長をNとして、1文字目からN-1文字目までのそれぞれに対して以下の判定を行います。 i文字目とi+1文字目が一致しているか？ YES→Noを出力し、プログラムを終了 NO→何もしない この判定をN-1文字目まで行い、それでもプログラムが終了していなければYesを出力しプログラムを終了することで正しく判定することができます。 ほぼ自明な操作なので、文字列操作が適切に行えるならACが取れると思います。 実装例 B - Chessboard 問題分は以下のとおりです。 チェス盤の状態が文字列として渡されるので、コマが存在するマスを適切なフォーマットで出力する問題です。 制約から、コマが一つしかないことがわかるので、いわゆるオンラインアルゴリズムにて解くこともできます。 解法としては、文字列を一つづつ見ていき、*が存在する行番号と列番号を適切に変換すればよいです。注意点として、行数を表す番号は一番下が1番になっているため、出力するときには8-○のような形にする必要があります。 実装例 C - Gap Existence 問題分は以下のとおりです。 任意のi, jを全探索することで解を得ることができますが、この解法では解が存在しなかったときにおよそ10^10程度の探索が必要になります。したがって、この方針ではACを取ることは現実的ではないです。 そこで、次のように問題を言い換えます。「あるA_iに対して条件を満たすA_jが存在するなら、A_j=A_i+Xを満たす。」 つまり、「与えられた配列の中に値がA_i+Xと等しいものはあるか？」という問題に変わります。 事前に配列をソートしておくことで配列の中から値を探すという典型問題に落とし込めます。この時、全体の計算量はO(Nlog(N))で抑えることができます。定数倍を考えなければ約10^6回程度の探索で解を得ることができます。 二分探索を自分で実装する場合、この問題のようにキーが配列中に存在しないことも考慮したコードを作成しておくと良いと思います。 実装例 D - M\u0026lt;=ab 問題分は以下のとおりです。 かなりシンプルな問題です。こういうの苦手です。 まずは私が試していたダメな解法を紹介します。 制約から、N*N\u0026gt;=Mならば、-1ではない何かしらの解が存在します。なぜなら、N*Nが解の候補の一つだからです。 そこで、まずN*N\u0026lt;Mとなるようなケースはすべて-1を出力して終了。それ以外のケースについて考えることにします。 解となる可能性があるXに対して、両方がN以下となるような因数分解を見つける方針で考えます。まず、Xの範囲を絞ります。仮定から、M\u0026lt;=Xです。 色々考えた結果、Xの上界は「M以上になるもののうち最小の平方数」であることがわかりました。理由は単純で、この値を上界とする時明らかにN*N以下となり、少なくとも「その平方数」が解の候補になるからです。 以上より、M\u0026lt;=X\u0026lt;=(平方数)に対して、2つともN以下になるような因数が存在するかを判定する問題になりました。 ここからは単純に、「Xの平方数に一番近い整数」からX=1になる、または割り切れるまで「Xを」順番に試し割をすればよいです。こうすれば2数の差が一番小さくなるような因数分解ができます。 試し割りで見つかった因数が両方N以下ならXを出力して終了、そうでないならXを1増やして同じことをすれば良いです。 この解法は正しく動作しますが、 制限時間内に終わりませんでした。結果としては10ケースでTLEが出てしまい、コンテスト中に通せませんでした。 雑な計算量解析をすると、まず私の絞り込んだXの範囲が、最悪ケースのときに連続する平方数の差とほとんど同じになります。これは(a+1)^2 - a^2 = 2*a + 1程度です。制約から、aは最大で10^6程度までありえます。そして試し割りは最悪ケースのとき、つまりXが素数の時には√X回程度かかります。流石に素数が密集しているとは思えませんが、平均的に見て√Xの定数倍程度になっているだろうと予想できます。これも10^6程度までありえます。以上より、最悪ケースのときには十分10^8回程度を超える計算が行われる可能性があります。 (ダメな方の)実装例 さて、この問題を解くためには別のアプローチが必要になります。 まず、重要な事実は次の2つです。 解となる可能性のあるX=abに対して、a\u0026lt;=bを仮定すれば因数aの上界は10^6である。 あるaを一つ定めると、解となる可能性のあるbはただ一つ存在する。 それぞれについて検討していきます。まず1つ目です。制約より、M\u0026lt;=10^12となりますから、Xの因数a,bがどちらも10^6であれば、それは必ず解の候補になります。また、a,bどちらも10^6を超えるようなケースは存在しません。a=b=10^6がより優れた解の候補だからです。 2つ目に対しては、あるaに対して、a*bがMを超えるようなbのとり方は無数に存在しますが、解となり得るのはそれらのうち最小のものだけです。つまり、一つのaに対して必ず条件を満たしうるbが一つだけ存在します。 以上より、以下のアルゴリズムにてO(1)で解くことができます(10^6程度で抑えられるという意味です。)。 最初、a=1とする。解はans=-1としておく a*bがM以上になるような最小のbを求める。具体的にはM%a=0の時b=M/aで、それ以外のときb=M/a+1となる。 a\u0026gt;bとなっていたらansを出力し、プログラムを終了する。 b\u0026lt;=Nならばans=min(a*b, ans)とする。 aを1増やし、2に戻る 私の解法が、「Xの取りうる値に対して、条件を満たすように因数分解できるか？」だったのに対して、こちらの解法は「解になり得る因数を全探索する」というような解法になっています。Xを構成的に見つけていくことで、各aに対して数回の演算でbを求めているのが高速化に寄与している点だと思いました。 この問題から学べる教訓としては、 復数の変数が出現する問題では、ある一つ以外の変数が事前に定まっているという仮定のもとでなにか得られないか考えてみる。 できるだけ天下り的ではなく構成的に考える。 暗に大小関係を定めてしまえば探索範囲の重複を防ぐことができる(ことがある) と言ったところでしょうか？次出会ったら解けるようになりたいですね。 実装例(ほぼ公式解説の通り) 終わりに 今回の参加記録はここまでです。読んでいただきありがとうございます。 最近4完がほぼできておらず、大体茶色MAXdiffあたりから解けるかどうか怪しくなっているような感じです。早いところそのあたりの難易度帯の対策もしたいですね。 サラッと先週分サボってごめんなさい。やる気があったらD問題だけでも記事書きます。 あと、現在私のC言語ライブラリのサイトをgithubで構築中です。近いうちに宣伝するかも？(宣伝の宣伝) ではまた次の記事で"
  },
  {
    url: "/post/abc294/",
    title: "ABC294参加記録",
    date: "2023-03-21T00:00:00+09:00",
    body: "ABC294参加記録 ABC294に参加しました。 こんにちは。今週も ABC294 に参加してきましたので，その参加記録です。 戦績など まずは，今回の戦績です。 A, B, C, Dの4完でした。今回のパフォーマンスは626で，レート変動は633→632(-1)でした。 実は今回コンテスト開始に少し遅れてしまいました。それも相まって少しパフォーマンスが下がってしまいました。今回のE問題が普段に比べて簡単だったので5完チャンスだったのですが，少し間に合いませんでした。 問題の紹介 今回はコンテスト後にACをとることができたE問題まで紹介します。 A - Filter 問題文はこちらです。 この問題は，標準入力を適切に扱えるならすぐに解くことができます。制約も特に厳しい部分がないので，単純に一つずつ入力を受け取っていくときに，偶数ならそのまま出力することでACをとることができます。重複を考える必要も無いようです。 ACコード B - ASCII Art 問題文はこちらです。 この問題は，二次元配列やそれに準するデータ構造を使えるかを問うもののように見えます。計算量などは気にする必要がなさそうなので，入力を受け取り問題文の操作を適切に行うことでACをとれます。 C言語なら二次元配列を利用するのが一番自然です。char A[H][W]のような配列を宣言して，二重ループで入力の受け取りと出力をします。 A~i,j~番目の大文字アルファベットはASCIIコードの性質を利用することで簡単に出力することができます。ASCIIコードにおいて，大文字アルファベットはAから昇順に数値が割り当てられてあります。したがって，printf(\u0026quot;%c\u0026quot;, A[i][j] + 'A' - 1);のような形で実現することができます。(よくわからないという人は，C言語のprintfとASCIIコードについて調べてみるとよいと思います) W個出力するたびに改行するのを忘れないようにしましょう。 また，二次元配列を使用するのが自然といいましたが，実は使用しなくても解くことができます。各入力をどのように置き換えるかはそれぞれの入力のみで決まり，ほかの入力のことを考慮する必要がありません。つまり，受け取った数が0なら即座に.を，それ以外なら'A' - 1を足したものを文字として出力すればよいです。 ACコード C - Merge Sequences 問題文はこちらです。 少し問題文を要約します。「二つの数列が与えられる。これらの要素をひとまとめにして，昇順に並べ替えた数列を作る。元の数列のi番目の要素は，新しく作った数列の何番目にあるでしょう？」という感じです。 制約から，要素のダブりはないです。したがって，求めたいもの(何番目か)はただ一つに定まります。シンプルに行くなら新しく作った数列を最初から順番に見ていき，等しくなった時にインデックスを出力すればACをとれるはずです。 ただしこのやり方では時間が間に合いません。最悪ケースを考えてみると分かりやすいです。元の二つの数列をA, Bとするとき，もしBの要素がAのどの要素より大きいとすると，結合して並べ替えた数列においてBの要素を探すときに必ずAの要素数分の無駄な探索が行われます。制約から，元の数列の要素数は10^5^個まであり得るので，このようなケースではBの要素を探そうとすると10^10^程度の操作が必要になります。どう考えても間に合いません。 ここで，新しい数列が整列済みだという事実を利用します。このようなときには 二分探索 をすることができ，一つの値を高速に探すことができます。知らなかった人は覚えておくとこの先役に立つと思います。 二分探索は要素数nに対して，およそlog(n)程度の計算量で値の探索をすることができます。また，全体をソートするためにおよそnlog(n)程度の計算量がかかります。以上より，nlog(n)程度の計算量で解くことができます。これは今回の制約下の最悪ケースで10^6^超えるかな～っていう程度です。 ACコード (前半は私のお手製ソート関数群です) また，元の数列が整列済みだということを利用して，マージソートをするような感じでn + m程度の計算量でACをとることができるようです。(あえてACサンプルは載せません) D - Bank 問題文はこちらです。 よくあるクエリを処理するやつです。今回は銀行の待合のアレみたいな問題です。 各クエリの処理方法を考えましょう。クエリ1はまだ呼ばれていない人のみが対象なので，単純にクエリ1が来た回数が分かればO(1)で答えることができます。クエリ2は実際に人が受付に向かう操作です。これ以外のクエリで受け受けに向かうことはないです。クエリ3は呼ばれている人のうち番号が一番若い人を再度呼び出すクエリです。 明らかにクエリ2, 3の処理が面倒くさそうです。簡単な解法を考えると，クエリ1で呼ばれた番号を集めておき，クエリ2で呼ばれたら削除，クエリ3が来たらその集合の最小値を出力すればよいです。これをシンプルに実装するなら順序付きの集合のようなデータ型を用いるのが良いです。(解説ではstd::setを勧めていました)なぜなら，指定した番号のデータに対して削除と最小番号の出力を同時にこなす必要があるからです。(キューや連想配列などだとどちらかの要件が面倒くさいです。) 私は少し違う方法をとりました。まず，制約からNの上限がそこまで大きくないので，全部配列に載せることができます。したがって，順序付き集合の代わりに配列を使用することができます。具体的にはこうです。要素数Nの配列を用意しておく。クエリ1は呼ばれた回数を出力，クエリ2が呼ばれたら配列のx番目に-1などを代入しておく。クエリ3が呼ばれたら-1の入っていない最小インデックスを出力する。この時，-1の入っていない最小インデックスの位置を常に保持しておくことで，クエリ3をO(N)で求めることができます。(O(N)と言っていますが，一回通過した場所には戻らないのでクエリ3のすべてを処理したとしてもN回以下の操作で答えることができます。)実はこの方法は上の解法と同等以上に高速です。 ACコード E - 2xN Grid 問題文はこちらです。 連続文字列が(数字)(長さ)という風に圧縮されている，元の長さLの文字列2つに対し，同じ位置で同じ数字が存在する場所の数の総和を求める問題です。 ランレングス 圧縮...ってコト！？ シンプルな問題ですが，この文字列をそのまま復元しようとすると，元の文字列長が長すぎてTLEします。(というか普通にメモリも使いすぎると思います。)したがって，何らかの方法で圧縮を戻さずに解を得る必要があります。 正直私にとって少しレベルの高い問題だったので，すっきりした解法ではないかもしれませんが，一応紹介します。 私はいたちごっこをしながらシュミレートする方法で解くことができました。まずは，各数字と圧縮長さをそれぞれv1[n1], len1[n1]とv2[n2], len2[n2]に格納します。 そしてn1のインデックスをi，n2のインデックスをjとします。基準点baseを最初0にしておきます。そして以下のアルゴリズムで解きます。 現在の総和sum1, sum2を用意し，最初にlen1[0], len2[0]を入れておきます。答えをans=0とします。 v1[i]==v2[j]ならば「sum1とsum2のうち小さいほう - base」をansに足す。 sum1 == L \u0026amp;\u0026amp; sum2 == Lならばansを出力し，終了 baseをsum1とsum2のうち小さいほうで更新し，より小さいほうにlen〇[△ + 1]を足し，△ += 1としてインデックスを更新する。 2に戻る。 下にこのアルゴリズムの簡単な図解を載せておきます。元画像は AtCoderのコンテストページ からお借りしました。 正直難しかった(小並感) ACコード 完走した感想 今回は4完でしたが，少しだけレートマイナスになってしまい残念です。今自分が使えるデータ構造が配列しかないので，今回のような問題に対応するためにもいくつかライブラリを整備しておこうかなと思いました。 あと地味に私は二分探索を書くのが下手だということが分かったので，実装について少し研究したいなと思っています。 コンテスト関係ないですが，今回のエントリ書くの結構時間かかりました。疲れた。 それではまた次回のエントリで"
  },
  {
    url: "/post/abc293/",
    title: "ABC293参加記録",
    date: "2023-03-17T00:00:00+09:00",
    body: "ABC293参加記録 ABC293参加してきました。(今更感) もっとエントリ更新に力を入れると言っておきながらABC292の分をサボってしまいました。ABC293からすでに6日くらい経過していますが、一応有言実行ということで参加記録です。(すまんかった) 総評 今回の戦績です。 A, Bの2完でした。パフォーマンス375、レート変動553→535(-18)でした。 結果だけを見ると正直結構やらかしてしまったなという感じですが、ほとんど理解していないアルゴリズムが問われているので当然の帰結だと思います。あと、これで3週連続冷えなのでじわじわレートが下がっています。 問題など 今回は解けてはいないけどC問題まで紹介します。 A - Swap Odd and Even 問題文はこちらです。 操作によって文字列長が変化しない上、制約も優しいので普通にシュミレートすれば解けます。C言語等を使っている人はバッファオーバーランに気をつけましょう。この問題の制約下では文字列長が偶数になることがわかっているのでループ変数に2を加えていく方針でACできます。バッファオーバーランに気をつけるなら、操作に使う変数とループ変数を分けるのが良いでしょう。 ACコード B - Call the ID Number 問題文はこちらです。 こちらも基本的には言われたとおりにシュミレートすれば解ける問題になっています。ただし、A問題と比べて複雑になっているので注意深く問題分を読むべきだと思います。 「すでに番号を呼ばれた人」は割り当てられた番号を読み上げることができないので、これをシュミレートするために以下のような実装が考えられます。 人iが呼ぶ番号Aiを配列に格納する。(配列のi番目に人iの情報を入れる) 配列を最初から順に見ていって、「その要素番目」にある要素を-1(インデックスとして無効な値なら何でも良い)で上書きする。 最後にもう一度最初から見ていって、要素が-1になっていない人がまだ呼ばれていない人で、これはすでに昇順になっています。 配列が強すぎる ACコード (前半はソート関数郡です。(必要なかった)) C - Make Takahashi Happy 問題文はこちらです。 経路上に存在する数字がかぶるかどうかを判定するためには、すべての経路を具体的に知っていなければいけません。すなわち、重複順列の全列挙です。そこで、いくつか方法があります。 私の取った方法はbit全探索です。0と1を「右に進む」「下に進む」に対応させることで重複順列をすべて列挙することができます。ビット数はw + h - 2になります。たぶん知らないとできません。 具体的には、最下位ビットの加算を行うたびに全ビットを見ていって、「下に進む」を表しているビットの総数がh - 1に到達したときに求めたい組み合わせの一つになります。高校数学を履修した人にとっては馴染み深い考え方かもしれません。(経路の数を求める問題で出てくるはずです。) pythonやc++であれば、順列の列挙をするライブラリが利用できるはずなので、使い方を知っていればACしやすいと思います。C言語にそんなものはありません。(血涙) ACコード 完走した感想 今回のコンテストはちょうど対策が薄かったところばっかり出てきて中々苦しかったです。特に、組み合わせの列挙は近いうちの目標だったのですが、面倒くさくて放置していました。 D問題はグラフに関する問題が出ていました。まじでグラフをなんとかしないと茶色から落ちそうなのでがんばります。(C言語は動的配列のサポートが薄く、隣接リストを微妙に作りにくいからずっと面倒臭がって放置しています。) 全然関係ないけど200AC超えました。 それではまた次のエントリで"
  },
  {
    url: "/post/abc291/",
    title: "ABC291参加記録 ~ DPお前もう船降りろ ~",
    date: "2023-02-26T00:00:00+09:00",
    body: "ABC291参加記録 ~ DPお前もう船降りろ ~ はじめに 今週も AtCoder Beginners Contest 291 に参加してきましたので、軽く参加記録です。 戦績 今回の戦績は以下の通りです。 A, B, Cの3完で、パフォーマンス439でした。レート変動は571→557です。 D問題ゆ゛る゛さ゛ん゛(大迫真) 問題とか 出た問題紹介します。 A - camel Case 大文字が出現する位置を答える問題です。私の解法では、asciiにおいて小文字を数値表現したときに90を上回ることを利用して判定するというものです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { char s[101]; scanf(\u0026#34;%s\u0026#34;, s); for (int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if (90 \u0026gt;= s[i]) { printf(\u0026#34;%i\u0026#34;, i + 1); } } return 0; } B - Trimmed Mean バラバラに渡される数値の上からと下からN個を抜いて平均を取るという問題です。おそらく出題意図としては、O(N^2)でもいいからソートを実装してみてというものだと思います。 何らかの手段でソートをかけて、真ん中の3N個のデータについて平均を取ることでACをとれます。私はC言語の標準関数(qsort())を使わずに、自作関数でやってみました。 ACコードはやたらと長いので、実際の提出を載せます。 提出 C - LRUD Instructions 2 二次元座標平面のグリッド上を動き回る人が、二回以上同じ座標に来ることがあるかを判定する問題です。 正直結構悩みました。一番先に思いついたのは、訪れた座標をキーにして、連想配列に入れることです。pythonなどの組み込みのデータ構造がリッチな言語なら多分この方法でやっていました。 残念なことに、現状C言語で私がすぐに利用できる連想配列はないため、他の方法を取りました。 しばらく唸っていると、同じ座標を訪れるということは、訪れた座標をすべて記録しておき、ソートをかけることですぐに判定できるのではないかという天啓が訪れます。早速実装しましたが... 座標のxとyでソートをかけると、片方のソート結果までぐちゃぐちゃにされることを忘れていました。対策として、一旦xでソートをかけてから、xが同じ奴らに対してyソートをかけるように修正したら通りました。というわけで以下AC提出です。(やたら長いのでこちらも提出で) 提出 D - Flip Cards 2^Nの組み合わせの中から条件を満たすものの数を考える問題です。制約から明らかに全探索したら間に合いません。(原理的にはbit全探索すれば解けますが)というわけで何らかの簡略化を行う必要が出てきます。 組み合わせ + 全探索だと不可能 ← これ大体DP説 というわけでDPの線を疑いながら考えました。結果... 典型dpの攻略は春休み中の課題の一つです。がんばります... 解説 に「配るDP」とか書いてあってビビっちゃいました。くやしいので解けたら別記事建てるかもしれません。 終わりに 参加記録は以上です。ここまで読んでいただきありがとうございました。 レートはモチベーションの一つではありますが、レートによってモチベーションが下げられるのはもったいない気がするので、今回の失敗はなかったことにしときます。春休み中に緑行けるといいなぁって思っています。それでは次のエントリで。"
  },
  {
    url: "/post/abc290/",
    title: "ABC290参加記録",
    date: "2023-02-21T00:00:00+09:00",
    body: "ABC290参加記録 ABC290参加した。 お久しぶりです。最近AtCoderコンテストの参加記録をサボりがちなので、流石にエントリを生成します。 今週行われた Toyota Programming Contest 2023 Spring Qual B（AtCoder Beginner Contest 290） は、どうやらオンサイトのコンテストに向けての予選を兼ねているそうで、希望者は好成績を出すことができれば3/18日に行われる決勝イベントに招待されるそうです。なんかすごいですね。 まあ私はそんな実力には程遠いので、いつもどおり参加してきました。 成績とか 軽く今週の戦績を振り返っておきます。今回はA,B,Cの3完でパフォーマンス611, レート変動511→523でした。 微増ですがまあ勝ちは勝ちなので() あと前回の参加記録からしばらく時間が立っているので、いつの間にか入茶しています。(多分色変記事は書きません) 問題と解法 サラッと流します。今までの記事では結構このパートに力を使っていたんですが、比較的難しい問題などは 前回の記事 のようなスタイルで記事を立てようかなと思っているので、あまり深入りはしないことにします。 A - Contest Result 問題文はこちら すぬけくんの解いた問題番号は配点のあとに渡されるので、一旦配点はすべて記録しておく必要があります。*✙最強のデータ構造✙*である配列を用いれば一発です。ただしアクセスするインデックスは一つずれますから気をつけましょう。 C言語的なことを言うとしたら、制約からすぬけくんの総得点はintで大丈夫だし、何なら配点はcharで収まります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, m; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); int a[n]; for (int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } int ans = 0; for (int i = 0; m \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); ans += a[tmp - 1]; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } B - Qual B 問題文はこちら 予選コンテストにちなんだ問題でしょうか？意外とAtCoderの問題って遊び心のあるものが多いような気がします。 さて、予選を突破するための条件は、「決勝希望者であり、希望者のの中で上位K人である」ことなので、単に上からoのついている人をK人分だけoにして、あとはxにするとオーケーです。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char s[n]; scanf(\u0026#34;%s\u0026#34;, s); int sum = k; int count = 0; for (int i = 0; n \u0026gt; i; i++) { if (sum == 0) { break; } if (s[i] == \u0026#39;o\u0026#39;) { printf(\u0026#34;o\u0026#34;); sum--; } else { printf(\u0026#34;x\u0026#34;); } count++; } for (int i = count; n \u0026gt; count; count++) { printf(\u0026#34;x\u0026#34;); } return 0; } C - Max MEX 問題文はこちらです。 MEXってなんだよ(正論) MEXというものをほとんど聞いたことがなかったので「MEX 数学」でgoogle検索してみましたが、あまりヒットしなかったのでそこまで有名なものでもないようです。 さて、このMEX演算は自明な性質として、「数Xを生成したければ、最低でもX個の元が必要である」というものがあります。本問題ではK要素を抜き出してくるという操作を行うため、どんなに頑張ってもMEX(B)の最大値はKになります。 最大値がそれより小さくなるケースは、「0~K-1に至る途中の数のどれかが一つでも欠けている」というものになります。 以上より、数列Aに0~K-1までの数字がすべて含まれているときに答えはKになり、それ以外のときは「欠けている」最小の数字が答えになります。 以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main (void) { int n, k; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;k); char check[k + 1]; for (int i = 0; k + 1 \u0026gt; i; check[i++] = 0) {} for (int i = 0; n \u0026gt; i; i++) { int tmp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;tmp); if (k \u0026gt; tmp) { check[tmp] = 1; } } for (int i = 0; k + 1 \u0026gt; i; i++) { if (check[i] == 0) { printf(\u0026#34;%i\u0026#34;, i); break; } } return 0; } 余談ですが、ARC156にもMEX関連の問題が出ていましたね(全く解けませんでした) D - Marking 結構引っかかった問題なので、(もしやある気があれば)別記事をたてます。 終わりに 参加記録はこれでおしまいです。読んでいただきありがとうございました。 いつかの参加記事でも言及しましたが、最近はAtCoder Problemsが提供している Boot camp for Beginners に取り組んでいて、Easyの100問を解ききることができました。また、それに伴ってLongest Streakも50日を達成しました。ヤッター 個人的におすすめなので、みなさんもやってみてはいかがでしょうか？ それと今後の方針としましては、記事更新をもうちょっと頑張りたいな〜とか考えてます。それではまた次の記事で"
  },
  {
    url: "/post/arc155a/",
    title: "精説ARC155A",
    date: "2023-02-07T00:00:00+09:00",
    body: "精説ARC155A はじめに 先日1月29日に AtCoder Regular Contest 155 がありました。ARCのA問題は，ARCがA~Fの6問体制になったARC104から現在に至るまでdifficultyの最大値は緑でした。しかし，今回のA問題は水色でした。 AtCoder\rProblemsより\r現在レート400+程度の私にとって，ARCにおいては一問解くだけでパフォーマンス700+くらいが望めるので非常に「コスパのいい」大会だと思っていたのですが，今回のA問題が思いのほか難しく，一問も解くことができませんでした。 コンテスト後にもう少し粘ってみたら解けたので，(公式解説が思いのほかよくわからないこともあり)解法を残しておくことにします。 問題の概要 問題文は以下の通りです。 要約すると，「与えられた文字列をSとする。この時，Sの前にくっつけてもSの後ろにくっつけても回文になるような長さKの文字列が存在するか？」というものになります。 上の画像はビジュアル化したものになります。 方針 まず制約を見てみましょう。特筆すべき点は，Kがかなり大きくなる可能性があるということでしょうか。また，一つの入力に含まれるテストケースについて，Nの総和が2×10^5以下というのも重要そうです。一つの入力に与えられるテストケースの数が非常に多いからです。 さて，この問題を解くためにどうすればよいのでしょうか？数多くの方針があると思いますが，私はこういう時は最もシンプルな方針を試してみます。この問題に対して最もシンプルな方針は何でしょうか？それは与えられた条件からできるだけ実際にK文字のS'を構成するというものです。 幸い文字列Sは与えられるので，この考え方は試すことができそうです。 シンプルに考えてみる さて，「実際に構成する」といったものの，どのようにすればいいのでしょうか？まずは以下の図をご覧ください。 回文の定義を考えれば，「一番左にある文字」は「一番右にある文字」と同じで，それがずっと続くわけです。つまり，「左から〇番目にある文字」は「右から〇番目にある文字」と同じわけです。 すなわち，問題の題意を満たすような文字列S'が存在するなら，それは与えられた文字列Sの逆順の一部分に他ならないわけです。 さて，ここで一つ疑問がわきます。もし「与えられた文字列」が「構成しようとしている文字列」よりも長かった場合，今言った方法で構成しきることができます。しかし，もしそうでないなら？すなわち，構成しようとしている文字列が与えられた文字列よりも長い時に，残りの部分がどうなるのかを考える必要が出てきそうです。 K \u0026lt; N の場合 まずはややこしいパターンを考える前に，比較的簡単なパターンを処理してしまいましょう。 この時、前述のとおり各ケース実際にk文字分すべてを構成することができます。したがって、確認する必要があるのはS -\u0026gt; S'の順番で考えた時のS'と、S' -\u0026gt; Sの順番で考えた時のS'が一致するかどうかです。 上にある画像の通り、回文となるようなS'が存在することを仮定すると、S'はどちらのケースでも同一であるという仮定から、 文字列Sの先頭K文字と末尾K文字が一致する 文字列Sの先頭N-K文字と、末尾のN-K文字が回文を成す というSが要請される条件が見えてきます。このチェックにかかる計算量はO(N)になるので、制約的にも問題なさそうです。 K = N の場合 場合分けは漏らさずに考えることが必要です。イコールも忘れずにチェックします。先ほどのケースにこれを含めなかった理由は、場合分けはできるだけ細切れのほうが一ケース当たりに考えることが減るからです。 この時も同様に考えてみます。 S S'が回文: S'はSの逆順そのもの S' Sが回文: S'はSの逆順そのもの というわけで、Sに対してまったく条件が課されないことがわかります。単にS'をSの逆順として定めてしまえば任意のSに対して条件を満たすS'となります。この判定はO(1)なので当然オーケーです。 もしよくわからなかったら具体的に一ケース挙げて考えてみるといいと思います。(ex. S = \u0026quot;12345\u0026quot;) K \u0026gt; N 以降 小休憩 ここから少し複雑になります。そこで、今まで何のために場合分けをしていたのかを再確認しておきます。 ここまで、「最もシンプルな手」すなわち、「与えられた条件から実際にS'を構成してみて、そこから考える」という手段をとってきました。 ここで問題になるのは、「Kが非常に大きいケースにおいては、S'を構成するのに少し手間がかかりそう」という事実です。なぜKが小さいときにS'を構成しやすいかは ここ を見返してみてください。 よく見直してみると、K \u0026gt; Nのケースにもまだ比較的シンプルにS'を構成できるものが残っています。まずはそれを片づけましょう。 2N \u0026gt; K \u0026gt; N の場合 この時も、Sが与えられたらすぐにS'を構成することが可能です。なぜなら、以下の画像の通り、前からN文字、後ろからN文字が確定するのでS'が(存在するなら)一つに定まるからです。 一見するとK \u0026gt; Nの場合と変わらないように見えますが、このケースにおいて回文の判定をするのはS'の中になるという違いがあります。従って、直接Sを評価して答えを出すことができるわけではなく、「S'が存在するなら、Sから構成したこの文字列は-な条件を満たす。」という説明付けになっています。最後はプログラムに落とし込まないといけないわけなので、やはりできるだけ分割は細かくしておくべきだとと思います。 この時、S'の満たすべき条件は以下の2つになります。 S'の中心付近の(上図にも示されている)「重なり合う場所」で、互いに打ち消しあわない S'の先頭K-N文字と末尾K-N文字が回文を成す 前述のとおり、これは実際にS'を構成して確かめる必要があります。このチェックにはO(N+K)が必要ですが、十分間に合います。(計算量の見積もりあってるか自信ないです) K = 2N の場合 今回も一応イコールを分けておきました。この時、S'を構成しても「互いに重なり合う場所」が発生しません。なので、条件は非常にシンプルになり、「Sが回文」が構成可能になる必要十分条件となります。 これも上の議論を考えれば直ちに従うので、もしわからなければ具体例を考えてみるといいかもしれません。(ex. S = \u0026quot;1234321\u0026quot;, K = 14) また、このケースは2N \u0026gt; Kのケースと全く同じ判定法を使うことができます。したがって、実際に実装するときは統合してもよいかもしれません。 K \u0026gt; 2N の場合 まず、これまでの議論から、S'が存在すると仮定すると次のことが言えます。「S'は先頭と末尾のN文字はSの逆順そのものである」「S'の先頭と末尾のK-N文字は回文を成す」 この情報から残りの部分がどうなる必要があるか考えます。 上に示した画像の通り、これらの情報からS'の不明だった場所が少しだけ確定させることができます。これと全く同じ議論をS' -\u0026gt; Sのパターンでも考えることによって、S'はSの逆順 \u0026gt; Sの正順 \u0026gt; Sの逆順 \u0026gt; ...という風に、2NずつSの逆順か正順のどちらかに挟まれていることがわかります。 これは、S'の残りの部分が2N未満になるまでまったく同様に続けることができます。結果的に、以下の図のようになります。 結局、この「あまり」の部分の周りについてのみ考えればよいことになります。この余りは0~2Nまでの値をとりますが，このあまりの部分の長さによって場合分けが発生することに注意する必要があります。 上の画像に示したように，あまりの周辺を考えるとは，「Sの逆順または正順と余った部分を左右に結合したもの」どちらもが回文をなすかどうかをチェックすればよいことになります。 場合分けが発生するというのは，K \u0026gt; Nと2N \u0026gt; Kで分けたのとちょうど同じような事情が発生するからです。したがって， 「あまり」がN以上の時: この判定 を使うことができる 「あまり」がN未満の時: この判定 を使うことができる というようになります。この計算量は，Kがいくら多くてもざっくりO(N)に近いはずなので，おそらく大丈夫です。以上により，この問題を解くことができます。 実装例(C言語) 以下に私の実装例を示しますが，可読性をあまり考慮して書いていないので，実装に詰まったときの参考程度が良いと思います。 実装例(AtCoder上での提出) あとがき 今回新しい試みとして解説を作ってみましたが，改めて自分のアイデアを説明するということの難しさを実感します。また，画像の作成が思ったより面倒くさいので，競プロ勢の解説が短文+実装例だけになりがちなのはある程度しょうがないのかなとも思いました。 誤り，「ここが分からんからもっと細かく」等があれば Twitter のほうに連絡いただけると幸いです。ここまで読んでいただきありがとうございました。 前回の記事から気が付いたら一か月くらいかかってしまいましたが，ABCとかにはちゃんと参加しているのでこれからはまた参加記録毎週書こうかなと思っている所存です。それでは次の記事でお会いしましょう。"
  },
  {
    url: "/post/abc284/",
    title: "ABC284参加記録",
    date: "2023-01-07T00:00:00+09:00",
    body: "ABC284参加記録 今週もABCのお時間になりました。 みなさん，あけましておめでとうございます。本日2023年1月7日は記念すべき新年最初の AtCoder Beginners Contest でした。今週も参加してきたのでいつも通り参加記録です。 早速余談ですが，皆様は正月休みを有意義に使えましたか？私は久しぶりに帰省して，運動不足解消にと 鍋蓋山 に登りました。 鍋蓋山の道中にある林\r登頂成功。これ元旦です。いいでしょ？\r冬ということもあって，道中も結構寒い時がありました。普通に服着ててこれなので，中学高校の持久走で言われた「走ってたら寒くないから」とか言うクッソ無責任な言葉を思い出したりしてました。 長距離深夜バスにて東京に再召喚...(実家に帰りたい)\rまた，我らが UEC は1月5日から授業なので，年明けてすぐ帰りました。なお新年初授業は来てる人少なかった模様 閑話休題。それでは本編行きましょう 今回の結果 今回の提出はこんな感じでした。 今回はA, B, Dの三完でした。めちゃくちゃWAが多いのは気にしないでください。傷つきます。 なお，今回は初めてコンテスト中にD問題を解くことができました！ うれしい！でもお前C解けないじゃん 今回のコンテストによるレーティング変動は以下の通りでした。 遂に茶色までの折り返しを超えることができました！ やはりD問題が解けたのが大きかったようです。Cが解けなかったのに今までで最高のパフォーマンス(732でした。)を出すことができました。 各問題に対する解法など いつも通りに私の考えたことなどを書いていきます。 A - Sequence of Strings 問題文は以下の通りでした。 文字列をN個受け取って，逆順で出力する問題でした。 一旦文字列をすべて保持して，あとから出力していけばオーケーです。ほかの言語についてはよくわかりませんが，C言語ならとりあえずいっつも理解が浅いせいで事故るからできるだけ避けたいけど二次元配列を使うと比較的アッサリ解けます。 具体的に言うと，char s[n][11]みたいなものを宣言して，scanf関数で\u0026amp;s[i][0]から受け取ればいいです。以下はAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n][11]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } for(int i = n - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%s\\n\u0026#34;, s[i]); } return 0; } ちなみに，この問題の制約下では各文字列は10文字以下です。したがって，配列は終端文字'\\0'を含めて11以上で宣言しなければいけません。私は普通に忘れててWA食らいました。 B - Multi Test Cases 問題文は以下の通りでした。 複数のテストケースに対して判定していくというちょっと変わった問題ですね。私がAtCoderに参加し始めてから初めて見るタイプでした。 幸い判定することは偶奇判定なので，2で割った余りを見ていけばOKです。ポイントを挙げるとするなら，答えはテストケースの順番に出力する必要があるので，入力を受け取るごとに出力をしていく感じで実装するとスマートです。以下ACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); for(int i = 0; t \u0026gt; i; i++) { int n; int ans = 0; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = 0; n \u0026gt; i; i++) { int temp; scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); if(temp % 2 == 1) { ans++; } } printf(\u0026#34;%i\\n\u0026#34;, ans); } return 0; } 完全に余談ですが，最近変数のスコープの管理が少しだけうまくなったような気がします。 D - Happy New Year 2023 問題文は以下の通りでした。 一言でいうなら素因数分解をする問題です。ただし，今回の問題では対象となる数が2つの素数p, qによってp2qと表せることが分かっています。あと，この問題でもB問題と同じく複数のケースの判定を行う問題でした。 この問題を最も単純なアイデアから膨らませて考えていきます。 最も簡単な解き方は，単純にすべて試し割りしてみることです。「ある自然数は，それ以下の素数の積としてただ1通りに表すことができる」という事実を利用しています。要は素因数分解の一意性ってことです。換言すると，「ある数Nは，2からNまでのいずれかの素数で割っていくといずれ1になる」ということです。 例を挙げましょう。例えば2023は17×17×7，63は3×3×7に分解することができます。このことを利用すると以下のような実装が可能です。 for(int i = 2; n \u0026gt;= i; i++) { if(n % i == 0) { // nを割ることができる数を発見 while(n % i == 0) { // 同じ数が複数回掛け算されている可能性もある n /= i; } } } これをいい感じに今回の問題に当てはめると「原理的には」解くことができます。しかし，*実際には解くことができません。*競技プログラミングをやる方ならお分かりかと思いますが，今回の制約におけるNが9 × 1018以下という部分が引っ掛かります。つまり，無駄な計算が多すぎて実行時間に間に合いません。さて，どのような工夫が可能でしょうか？ 私がこの問題を解くにあたって，まず足掛かりにしたのは「ある数Nは，Nの平方根より大きな素因数を多くても一つしか持たない」という事実です。残念ながらこの知識は当意即妙的に知らなかった状態からパッと思いつくのは難しいかなと(私は)思います。しかし，素数を扱うときに強力な武器になりえるので知らなかった人は憶えておくとよいかもしれません。よく考えると当たり前のことで，もしNの平方根より大きな素因数を2つもっていたとすると，その2数の積がすでにNを越えてしまうので，明らかに矛盾するからです。 この事実を使うと何が良いのでしょうか？それは，探索範囲が小さくできるからです。前述の事実から次のことが言えます。 NがNの平方根以下の素因数しか持たないとき，もちろんNの平方根までの探索で，すべての素因数を見つけることができる。 NがNの平方根より大きな素因数を持つ時，Nの平方根までの探索で見つけた素数でNを割ることで，残りの素因数を見つけることができる。 以上より，さっきまではNまで探索していたのに対して，Nの平方根までの探索でよいことを示すことができました。より具体的な方法を挙げると，Nの平方根まで「Nを割ることができる数」を見つけたらその都度見つけた数で限界まで割っていきます。探索がNの平方根まで終わったら，これまで割られてきたNを確認します。もしこの数が1になっていなければ，それは素数ということが確定しています。 この方法で問題を解くことができるでしょうか？残念ながら，おそらくまだ間に合いません。それはNの平方根が最大で109のオーダーに達するからです。 このアイデアは無駄だったのでしょうか？いや，まだあきらめるのは早いです。制約を見直してみましょう。今回はNは(重複を許して)3つの素因数を持ちます。先ほどの考え方を応用すると，Nの三乗根までの探索で少なくとも一つの素因数を見つけることが可能ということがいえます。これは，もしそれ以上の素因数を3つ以上持っていると先ほど示したものと同様の矛盾が生じるからです。 この時，探索範囲は最大で106のオーダーまで減少します。AtCoderでは， およそループを108くらいまで回せる そうなので，よほど定数倍を悪化させるような処理を書かなければおそらく通るでしょう。 基本的にはこのアイデアで通ると思います。が，私の実装ではまだ注意点があります。それは，三乗根までの探索ですべての素因数が確定するパターンと確定しないパターンに分かれるからです。 問題で言うところの素因数p(つまり，Nに二つ含まれているもの)を見つけることができれば，残りの素因数はNをpで割ることで見つけることができますが，もしqしか見つけられなかった場合，Nをqで割ることにより得られる数はp2となり，これをpに「ほぐす」作業が必要となります。私はこの処理を 二分探索 にて実装しました。 以下私のACコードです。 #include \u0026lt;stdio.h\u0026gt; int disassembly(long long int *a, long long int *b, long long int *n, int *map) { // 素因数がすべてまたは2乗じゃないほうだけ見つかる int flag; for(int i = 2; 3000000 \u0026gt; i; i++) { if(map[i] != 0) { if(*n % map[i] == 0) { *n /= map[i]; if(*n % map[i] == 0) { // このケースは確定 *a = map[i]; *n /= map[i]; *b = *n; flag = 1; break; } else { // このケースはまだわからない *b = map[i]; flag = 0; break; } } } } if(flag == 1) { return 0; } else { return -1; } } void Sqrt(long long int *a, long long int *n) { long long int left, center, right; left = 0; if(*n \u0026gt; 3000000000) { right = 3000000000; } else { right = *n; } for(; right - left \u0026gt; 10;) { center = (right + left) / 2; if(center * center \u0026gt; *n) { right = center; } else { left = center; } } for(; *n != left * left; left++) {} *a = left; } int main(void) { int t; scanf(\u0026#34;%i\u0026#34;, \u0026amp;t); int map[3000000]; // エラトステネス for(int i = 0; 3000000 \u0026gt; i; i++) { map[i] = i; } for(int i = 2; 1734 \u0026gt; i; i++) { for(int j = 2 * i; 3000000 \u0026gt; j; j += j) { map[j] = 0; } } for(int i = 0; t \u0026gt; i; i++) { long long int n; scanf(\u0026#34;%lli\u0026#34;, \u0026amp;n); long long int a, b; // 素因数 if(disassembly(\u0026amp;a, \u0026amp;b, \u0026amp;n, map) == 0) { printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } else { Sqrt(\u0026amp;a, \u0026amp;n); printf(\u0026#34;%lli %lli\\n\u0026#34;, a, b); } } return 0; } クソ長コードですまんかった。ポイントとしては，まず素数のリストを事前に エラトステネスの篩 を用いて事前計算しておくことで多少の軽量化を図っています。あとは二分探索でオーバーフローしないようにしています。いずれも制約ありきなので一般的に使えるコードではないです。 余談ですが，最近こんな風にvoidを返す関数にポインターの引数を与えることで，面倒くさい処理を外部委託するのにハマっています。それにしてもint *aみたいなやつを与えたときに*aって書くの面倒くさいですね。 C - Count Connected Components 問題文は以下の通りです。 無理でした。はい。 この問題に出てくる「グラフ」というのは，よくある「y = xのグラフ」のようなものではなくて，離散数学における「頂点と線をいくつか組み合わせた図形」のようなものらしいです。 例えば，以下のようなものがグラフです。(出典: AtCoder Beginners Contest284問題ページ より) この問題の題意は多分「辺と頂点の情報が与えられるので，独立しているパーツの数を答えなさい」です。しかし，グラフの定義やそこから導かれる性質がよくわかっていなかったため，有効な解法がよくわかりませんでした。先にある程度グラフについて知らないと厳しそうです。 グラフ，完全に理解した。\rということで，今後の課題ということにさせてください。 終わりに 今回の参加記録は以上です。ここまで読んでいただきありがとうございました。 余談ですが， AtCoder Problems にて今回のC問題のdifficultyを確認してきたのですが，なんと灰色の真ん中くらいでした。...うせやろ？ どうやらグラフの探索は簡単めの典型のようです。次出たときには解けるようになりたいといいたいところですが，グラフを勉強するってどうすればいいんでしょうか...解説によると幅優先探索とかで解けるらしいです。 なんだよそれ あと，最近はAtCoder Problems上の Boot camp for Beginners を少しずつ進めています。ついでにLongest Streak(ACを出した日の継続日)を伸ばそうと頑張っています。もしやっていない人がいたらおすすめです。 それでは次の記事でお会いしましょう。皆様にとって2023年がいい年になりますように！"
  },
  {
    url: "/post/abc283/",
    title: "ABC283参加記録！",
    date: "2022-12-26T00:00:00+09:00",
    body: "ABC283参加記録！ ABC283参加してきた！ こんにちは。最近近所のスーパーが扱っている冷凍パスタのメーカーが変わって一瞬焦った In です。(でもちゃんとおいしかったのでセーフ) アドベントカレンダー を執筆していた影響で遅れてしまいましたが，今週もちゃんと ABC に参加してきましたので，その参加記録を生やしておきます。 今週の成績発表のコーナー まずは今週の成績です。前回 爆死 したのが記憶に新しいですが，今回はこんな感じでした。 大体16分でCまで通して，そのあとD問題に敗北しました。全体で3完です。 このためだけに10分くらいで作った雑コラ。\rなお，今回のコンテストによるレート変動は以下の通りでした。 茶色まで折り返し地点といった感じでなかなかいいんじゃないでしょうか？今回は結構早解きに成功したので，3完ですがそこそこの順位になりました。ペナルティも食らってないし 各問題と解法 いつも通り自分が解いた問題の説明を載せていきたいと思います。まずはA問題です。 A - Power 問題文は以下の通りでした。 AのB乗を出力するだけのシンプルな問題です。 ご存じの方も多いかもしれませんが一応書いておきますと，ABというのはBが自然数の場合は素朴に定義されており， AB=A×A×\u0026hellip;×A (AがB個掛け算されている) というものです。 この問題の制約下では，ABの最小値はA=B=1の時1で，最大値はA=B=9の時387420489となります。これはintの範囲内に収まります。また，計算回数も9回程度に収まることが分かるので，定義通り計算して出力したらOKであることが分かります。以下にAC通ったコードを載せます。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;a, \u0026amp;b); int ans = 1; for(int i = 0; b \u0026gt; i; i++) { ans *= a; } printf(\u0026#34;%i\u0026#34;, ans); return 0; } このA問題はここ最近の中では簡単な問題だと思います。というかほとんどの言語が組み込みで冪乗計算の機能を備えているので，簡単に解けた人が多いんじゃないかと思います。 B - First Query Problem 問題文は以下の通りでした。 この問題はAtCoderによくあるタイプのクエリを処理する奴ですね。この手の問題は工夫したら真面目にクエリを処理しなくてもいい場合があります。したがって，まずは条件をよく見ることが大切です。 問題文を見ると，クエリの件数の制約や，行う必要のある操作の制約がかなり緩いことが分かります。まず第一引数が1であるようなクエリは，受け取った数列を配列などに保持するだけでO(1)で行うことができます。また，第一引数が2であるようなクエリに対しても同様です。一つしか値を操作しないので軽いですね。操作回数も105が上限となっており，愚直に処理しても十分間に合いそうです。 もしかしたら何らかの最適化があるのかもしれませんが，私は書いてある通りに実装して通りました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, q; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%i\u0026#34;, \u0026amp;q); int temp; //クエリ種類 int k; // インデックス int num; // すり替え数字 for(int i = 0; q \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;temp); scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); if(temp == 1) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;num); a[k - 1] = num; } else { printf(\u0026#34;%i\\n\u0026#34;, a[k - 1]); } } return 0; } クエリの種類によって与えられる引数の数が変わるのに注意です。私の実装ではシンプルにif文で分岐してあります。あと完全に余談なのですが，うえのコードでは実行時で確定していない変数を用いて配列を宣言するというC言語(C99以降?)の機能を使っているのですが，便利だけど罪悪感があります(笑) C - Cash Register 問題文は以下の通りでした。 与えられた数字をレジの機械で打ち込むときに必要なストローク数を調べるという問題でした。ほとんどの人がまずは制約に目が行くのではないでしょうか？制約は整数が10100000らしいです。デカ過ぎんだろ... デカさのイメージ図\rということで、明らかに「非常に簡単な処理」でどうにかなる、もしくは規則性などに注目して簡略化する必要があることが推察できます。そこで、問題文から具体的に考えてみます。 詳細は省きますが、具体例をいくつか考えることで「数字のキーを押す」ということと「現在表示されている数字の末尾に押した数字を追加する」ということが(一回目の入力を除いて)完全に一対一に対応していることに気づきます。すなわち、「0が二つ並んでいる」という状態を除くと、追加される数字に関係なく「キーを押す回数」=「数字の桁数」ということがわかります。 したがって、入力を文字列として受け取り、前述した「0が二つ並んでいる」状況のときのみを別処理になるようにして、あとは桁数をカウントするだけで良いです。 文字列として扱う理由は値が大きすぎてC言語組み込みのあらゆる整数型に収まらないからというのと、単純に各桁の数値を確認するだけなら配列としてアクセスしたほうが有利だからです。例えば整数型として格納できたとすると、各桁を取り出すためには割り算や剰余演算くらいしか手がないです。剰余を取る操作などは明らかに配列へのアクセスより遅く、今回の条件ではあまり意味がありません。以下はACコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[100002] = {0}; scanf(\u0026#34;%s\u0026#34;, s); int ans = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;0\u0026#39;) { ans++; i++; } else { ans++; } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } まず配列を100002以上で宣言します。これは、10100000=10...0(0が100000個並んでいる)で100001ブロック消費して、さらに文字列として処理しているので終端文字\\0の分が必要だからです。 前述の連続した0の処理は、二つ並んだものを見つけたら配列の参照カウントをインクリメントする処理に分岐させるようにしています。これで一回で二文字打ったということと等価になります。 見ての通り計算量的には各桁を見て回るだけなのでO(1)の処理を桁数だけ行うことになります。与えられた数字の桁数は最大で100001なので、余裕で間に合います。 D - Scope 問題文は以下の通りでした。 問題文が長くて問われていることを理解するだけでも結構大変な問題ですね。最終的にコンテスト後にACすることができたので，思考の過程を載せておきたいと思います。 問題文が複雑なので，まず問われていることを整理しました。この問題で問われていることは，細部を無視するとざっとこんな感じです。 (、)、「英小文字」のみからなる「ある条件」を満たす良い文字列が与えられる。 文字列の先頭からある操作をしていく。この時、文字列の最後まで操作を行うことができるかどうかを判定する。 (以下の議論では上の条件でぼかした「ある条件」と「ある操作」については説明しません。ご了承ください。)具体例を見ながらどういう判定法をするといいのかを考えました。例えば，具体例としてコンテストのページに乗っている入力例を以下に提示します。 この例などを見ながら考えると，良い文字列を)から遡って構成するには，(と)の数を釣り合わせればいいことに気が付くと思います。 例えば上記の入力例をとって説明しましょう。まず最初に出会う)は4文字目です。そこから遡って見返していくと，ほかの)に出会う前に(と出会うことが分かります。この場合，(と)の数が等しい最小の範囲を見つけることができました。 次に出会う)は最後の文字です。ここからさかのぼってみていくと，(に出会う前に)と出会ってしまうことが分かります。したがって，その他の)に出会わなければ2つの(が見つかった場所までが条件を満たす範囲になるはずです。もしこれが本当に正しいのか気になる人は，ほかの良い文字列のパターンなどに適用して確認してみてください。 このような操作を思いつくのは結構大変かもしれません。(実際，私はコンテスト中は間違った方針で進めてしまっていました。)個人的には，まずは「良い数列」の様々なパターンなどを書き出してみて，実際に自分がこの判定をするときにどのような部分に着目するかなどを考えるといいかもしれません。厳密に正しいという証明を出すのは難しくても，発見的手法が威力を発揮する場面は多いと思います。 それでは見つけ出した方法を愚直に実装してみましょう。私は()の数をカウントするのではなく，一番深いネストの()を終えたら()を違う文字で置き換えてしまうという方法をとりました。この操作によって，常に最初に見つかった(で止めればよくなります。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[300001] = {0}; scanf(\u0026#34;%s\u0026#34;, s); char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { s[i] = 0; for(int j = 0; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { s[i - j] = 0; break; } else if(s[i - j] == 0){ continue; } else { ascii[s[i - j]] = 0; } } } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } こんな感じの実装になりました。英小文字カウンターは， asciiコード表 でa~zが97~122に割り当てられているのを利用して，そのまま配列にアクセスするキーとして利用しています。途中でブレークすることなく最後までループを回せたらそれはYesの文字列だったという風に判定しています。 ...はい，このコード実はTLEを食らいました。 あれだけ自信満々に解説しておいてなんですが，これでは通らないようです。今の方針を維持したままもう少し工夫できるところがないか考えてみましょう。 具体例を見ながら条件をよく考察すると，上記のコードでは必要ない処理をかなり含んでいることが分かります。まずは以下の例を見てください。 文字列(((a(bcd)cde))ef)を考える。 まずabcdと書かれたボールが箱に入れられる。(箱の中: abcd) )に出会って，bcdが取り出される。(箱の中: a) cdeと書かれたボールが箱に入れられる。(箱の中: acde) abcdeが取り出される。(箱の中: なし) abcdeが取り出される。(二回目)(箱の中: なし) ボールefが箱に入れられる。(箱の中: ef) abcdefが取り出される。(箱の中: なし) 高橋君が操作を終えることができると分かる 注目していただきたいのは，ボールを取り出すフェーズです。よく見ると一度取り出した部分は，その後考える必要がないことが分かります。直観に反すると思うので，もう少し定性的に考えてみます。現在考えている階層より深いネストの()の中にある小文字は，以下の2パターンに分岐します。((abc)abe)を見ながら考えてみるといいと思います。 現在の階層にあるものとと同じ小文字 -\u0026gt; 「現在の階層」の)に出会えば，より深い部分に行く前にボールは取り出される。(上の例のabが該当する) 現在の階層に無い小文字 -\u0026gt; 「現在の階層」に至る前に取り出され，それ以降箱に入れられること自体がない。(上の例でcが該当する) 以上から，例えば((abc)abe)は，一回目のボール取り出しをした後は( abe)として扱っても良いということになります。 これを繰り返すことで，一回見た部分を今後見ないという改善策が見つかります。これを実装しましょう。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { char *s = (char *)calloc(300001, sizeof(char)); scanf(\u0026#34;%s\u0026#34;, s); int len = 0; for(; s[len] != \u0026#39;\\0\u0026#39;; len++) {} char ascii[123] = {0}; // アルファベット小文字はa-\u0026gt;97からz-\u0026gt;122だからそれぞれのインデックスに対応させる。1がたってたら使用済み char *s1 = NULL; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if(s[i] == \u0026#39;(\u0026#39;) { continue; } else if(s[i] == \u0026#39;)\u0026#39;) { int j; for(j = 1; ; j++) { if(s[i - j] == \u0026#39;(\u0026#39;) { break; } else { ascii[s[i - j]] = 0; } } s1 = (char *)calloc(len - j, sizeof(char)); // 新しい配列の宣言+代入 for(int k = 0; i - j \u0026gt; k; k++) { s1[k] = s[k]; } for(int k = i + 1, k1 = i - j; len \u0026gt; k; k++, k1++) { s1[k1] = s[k]; } len = len - j - 1; i = i - j - 1; free(s); s = s1; s1 = NULL; } else { if(ascii[s[i]] == 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } else { ascii[s[i]] = 1; } } } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } これでAC通りました。うれしい。 かなりごちゃごちゃしてしまいましたが，このコードの要点は， 最もネストの深い()を見つけて，ボール解放を行う。 新しく配列を宣言して，その部分のみを除いた文字列を作る。 これを繰り返しているだけです。C言語以外なら多分もっと簡潔に書けると思います。 ちなみにこれは全然最適な方法ではないらしく，今回のコンテストでC言語を用いてD問題を通した中で最も実行時間がかかっていました。余裕があればほかの人のコードも解析しようかな。 終わりに 今回の記事は書くのに過去一番時間がかかりました。ひとえにD問題が強敵だったからです。とんでもねえな 実はいまだにコンテスト中にD問題を通したことがありません。そろそろ通させてくださいマジで。ちなみにレーティングが今回で199まで上がったので，茶色までの折り返しに到達しました。何とか茶色に到達できるように今後も頑張っていけたらなと思います。 完全に私事ですが，このくらいの規模の記事になると流石にタグ含めすべてを手打ちするの結構大変になってきました。もうちょっと何とかしたいです。 それではここまで読んでいただきありがとうございました。よいお年を。"
  },
  {
    url: "/post/uec-advent2022/",
    title: "あなたの知らない(知ってるかもしれない)SCPの世界 [UEC Advent Calendar 2022] 24日目",
    date: "2022-12-22T00:00:00+09:00",
    body: "あなたの知らない(知ってるかもしれない)SCPの世界 [UEC Advent Calendar 2022] 24日目 はじめに あなたは誰？ 始めまして。基礎科学実験Aを落としそうな22生の In と申します。 アドベントカレンダーの募集をtwitterで見て、楽しそうだなと思ったので初参加です。いろいろと至らない点があるかもしれませんが、ある程度温かい目で見守っていただけるとありがたいです。 え？この記事、CSS適用されてませんよだって？ほならね？(以下略) (手打ちの温かみのあるサイトなので許して) この記事は何？ UEC外からこの記事を見に来る人がそんなにいるとは思えませんが，この記事は UEC Advent Calendar 2022 その2 の24日目の記事です。( その1 もあります。)ほかにもたくさん面白い記事があるので，気になる人はぜひ見てみてください。 23日の記事は，かわいいねさんの「 メンタルの話 」でした。自分の弱い部分(？)と向き合って、しっかりと言語化することができるのがすごいと思います。 World's Smallest Violin とかいかがですか...？(隙あらばAJR推し) 25日はとりゑもんさんの「僕の友達の競馬予想と競馬を始めて1年を振り返りたいと思います」です。電気通信大学は(というか調布は)確か近くに競馬場があったので、競馬を嗜んでいる方も多いかと思います。楽しみですね。私ですか？私は毎年有馬記念のCMを聞いては季節を感じているだけの人です() 明日の記事も楽しみですね。 本題 で、今日は何についての記事なんだい？ この記事で私が紹介するのは、 SCP Foundation です。( ファイル転送するやつ ではありません) SCPを知らない人は、この記事を通してSCPを知ってもらう、すでに知っている人は、私の一押しをシェア出来たらいいなと思います。 最近はyoutube向けに動画を投稿する人が増えてきたので、詳しくはなくてもチラ見、小耳にはさむなどはある人が多いかもしれません。実際scp関連の動画は結構再生数があるものもあり、コンテンツやコミュニティーは年々肥大化しているように感じます(主観なのでデータなんかねえよ (画像掲載めちゃくちゃ雑です。すみません。)さらっと人気どころを挙げるとこんなところでしょうか。まだあるかもしれませんが私が知らないので終わりです。興味ない人もサムネくらい見たことある人が多いんじゃないでしょうか。ちなみにどのチャンネルも好きですが、私が一番見るのは scp情報局 です。 SCP Foundationとは？ この記事の目標の一つが「SCPを知らなかった人に興味を持ってもらう」なので、今一度SCPとはなんなのかさらっとおさらいしておきます。 ざっくりとした説明なので、もしもっとちゃんと知りたい人は ここ とか 公式 あたりを参照してもらうといいです。 SCPとは、創作及び創作投稿サイトの総称です。その起源は4chanで行われていた、貼られたホラー画像に対してキャプションをつける遊びで、現在も(画像などのライセンス管理は厳しくなっていますが、)そのようなスタイルです。(したがって、今でもたまにホラー画像が使われることがあり、知らずに開いたら普通に怖いです。) SCPの一番の特徴は、SCiPおよびSCP財団というサイト共通の土台のもとで作品が作られることです。SCiPとはこの世の常識に反するような事象、物体のことで、SCP財団はこれらの異常から世界を保護するという使命の元活動しています。(異常物品の例: 無限に水が出てくる水筒 、 姿を見ると猛スピードで殺しに来る化け物 、 RPG世界のようにされてしまった空間 など) SCPとはSecure Contain Protectの略称で、(ほかにもSpecial Containment Proceduresだったりしますが、こまけぇこたぁいいんだよ)これはSCP財団の理念を表しており、異常物品を確保、収容し、一般人の目に触れぬように保護します。財団はあくまでSCiPという世界の不条理を取り除くことを第一として動きます。すなわち、世界の正常性さえ保たれていればいいという団体です。 財団はふつう超技術を持っており、今の文明の2歩くらい先に行ったオーパーツみたいな装備でSCiPの確保を行います。しかし、前述の通り世界の正常性さえ保たれていたらいいというスタンスです。例えば非異常性の何かによって地球がやばくなったりしたとき、財団は動きませんこの性質はよくSCP記事の主題に挙がったりするような奥の深いテーマだといえるでしょう。 また、特筆すべきなのはSCP記事の体裁です。以下にある記事の画像を載せます。 ソース: http://www.scp-wiki.net/scp-1009 ライセンス: CC BY-SA 3.0 タイトル: tree2-small.png 著作権者: Sophia Light 公開年: 2011 上の画像を見ていただければわかるように、SCPの記事は基本的にすべて報告書の体裁をとっており、財団がマークした異常物品に対する情報が機械的に記述されています。SCPの醍醐味はこの語り口にもあり、機械的な記述の中で作品の雰囲気が作り上げられます。基本的には決まった流れで作成されるので、読み方さえわかると初心者でも楽しみやすいかなとも思います。(時々format-screwという変則記事もありますが、多くはないです。 これ とか) 報告書の中で出てくるセクションについて、軽くまとめてみました。 アイテム番号: これは、財団がオブジェクト(SCiP)を管理するときに使用している番号という設定のものです。同じ番号を共有するアイテムはありません。メタ的には、この番号は早い者勝ちなのでキリ番など人気のある番号はコンテストの景品として与えられる場合があります。なお、この番号とは別に「メタネーム」というものも持っています。これはいわば「作品名」です。当然財団世界ではなじみのない呼び方なので、記事内に出てくることはないです。 オブジェクトクラス: 一言でいうと、アイテムの脅威度です。ざっくりKeter-\u0026gt;Euclid-\u0026gt;safeの順番でヤバいと考えてもらえればいいです。ただ、このクラスは様々な要素が複合して決定されているので、初心者はなんでこのアイテムにこのクラスがつけられているんだろうとかを考えると楽しいかもしれません。 特別収容プロトコル: これは財団が現段階で確立しているアイテムの取り扱いに関するベストプラクティスです。オブジェクトクラスが低いアイテムに関しては基本的に収容方法が確立されているものも多く、実質的には管理マニュアルという意味になります。しかしketerクラスなどになると、実質的な抑え込みをあきらめて、まだ「マシ」な方法を提示しているだけの場合もあります。ちなみに、このパートがオブジェクトクラスの下に来ている理由は、緊急時に取り扱い方法がすぐわかるようにできるだけ上に書くべきというものらしいです。ネタが細かいですね。 説明: アイテムの説明です。多くの記事はこの部分に一番主眼が置かれています。多くは発見状況や、どのような異常性があるのかなどの説明、現在に至るまでに起こったインシデントなどが書かれます。 大体このくらいの知識でも楽しく読めると思います。再掲になりますが、もし興味を持った方がいましたら、セクション先頭で貼ったようなリンク先などものぞきに行ってみることをお勧めします。私のものよりもより詳細で正確な説明があります。 オレオレSCP紹介！(初心者向け) まずはSCPについて知ってもらえたと思います。次に、私の一押しSCPを「ここすきポイント」とともに紹介していこうと思います。まずは初心者に知ってほしい(または，初心者でも読みやすいと思われるやつ)作品を紹介します。 SCP-040-JP (通称: ねこですよろしくおねがいします) 栄えある先頭に選ばれたのはscp-040-jpです。本家記事を見に行く人向けの注意: この記事は詳細を展開するとちょっとびっくりするような画像が使われていますので，折り畳みを開けるときはそういうつもりで開けましょう このscpは，一言でいうと「中を覗き込んでしまうと，以降暗闇の中に幻覚が見えるようになり精神が死ぬ」scpです。この記事は非常に有名で， scp殿堂入りコレクション にも入っています。皆さんはyoutubeなどのコメント欄で「ねこでした」とか，「ねこはいます」とかみたことあるんじゃないでしょうか？それの元ネタです。 ちなみに，すでに知っている人向けなんですけど こんなジョーク記事 も存在します。 ここすきポイント この作品のここすきポイントは，やはりその圧倒的な知名度です。このscpを知ってるだけで学校で友達100人は固い(適当) SCP-173 (通称: いなみちゃん) 仮にもscpを紹介する記事なら絶対に外すことはできないと思ってランクインです。このscpは事実上の「最初のscp」です。すなわち，掲示板で一番最初に考えられたscpということです。^要出典^ならなんで173番なんだって？知らん このscpは，一言で説明するなら「目を離したら襲ってくるやべー奴」です。実際，特別収容プロトコルにも掃除の際は3人以上で入室するように規定されています。詳細は記事を見てみてください！(短いので) ここすきポイント この記事のここすきポイントはアイテムのシンプルさです。じつは，最近の記事になるほど作者が力を入れ過ぎて難解になるという傾向があります。しかし，この記事は最初期の作品だけあってすごく設定がシンプルで，ミステリアスな雰囲気がscpって感じがしてとても好きです。ちなみに世界的にもかなり愛されているみたいで，各国支部の173番ナンバーを決めるためにコンテストとかやってた気がします。(初めての方は困惑するかもしれませんが，scp-173-○○(国のコード)とscp-173は別の記事です。実際上で紹介した040-jpは日本支部の記事で，本部の040とは違うものです。) SCP-8900-EX (通称: 青い，青い空(メタネーム)) お次に紹介するのはscp-8900-exです。この記事の末尾についているexというのは，オブジェクトクラスがexplainedに設定されているものにしかつかない特別なものです。本来このような特殊クラスを紹介するのは，初心者向けかといわれると「ｳｰﾝ」っていう感じですが，日本での知名度が非常に高いため取り上げました。 オブジェクトクラスExplainedとは，次のいずれかの条件を満たすオブジェクトにに付けられることが多いです。 かつて財団しかもっていなかった超技術だったが，世界のレベルがその技術に追いついたため「異常」ではなくなった アイテムが原因のれっきとした異常であったが，財団がその異常を抑え込むことができず，遂にはそれが新しい「常識」となるまで広がってしまった このアイテムは後者の条件を満たしています。あまりネタバレをしたくないので気になる方は見に行ってみてください！ ここすきポイント この記事のここすきポイントは，まず現実との親和性の高さです。実はこのオブジェクトは普段皆さんも非常に親しんでいるもので，この記事を初めて読んだときは「こんなの思いつくなんて天才か？」って思いました。 また，作品中のO5の言葉(O5っていうのは財団の偉い人です。)は，scp財団の理念をよくあらわしている名文です。たまにコメント欄とかで見かける気がします。 SCP紹介(無差別級) ここからは，書くのしんどくなってきたので読んでいる人も知っている人がある程度いると思うので，個人的に好きな記事のみをいくつか紹介していきます。できるだけマイナーなものとかを紹介していけたらと思います(私は英語読めないので，未翻訳記事とかは無理ですが)ちなみに選定基準はすべて私の好みなので，結構読みづらいものとかも入ってたりします。ご了承ください SCP-023-JP (影の鉄道路線) このscpは，鉄道駅に突如現れるヤバい路線です。誰も監視していないときに，まるで元からそこにあったかのように突如その路線への入り口が生成されます。そこに走っている電車に乗ると，当然えらい目にあいます(ほとんど帰還した例がないそうです。) ここすきポイント scpならではのこの意味不明さがとっても好きです。記事中に出てくる当然のように役に立たないgpsとかもいい味出してます。あと，このscpの魅力は実験記録が面白いことです。作品には4回の実験記録が載っており，なかなかヤバい様子が伝わってきます。中でも最後の実験記録は突っ込みどころ満載で好きです。 SCP-3300 (The Rain) このscpは日本ではそんなに有名ではないかもしれません。モンタナ州クリアウォーターの町で年に一回起こる「元の住民が消失して，新しい住民に置き換わる」という超常現象です。 ここすきポイント この記事のいいところは，なんといってもその圧倒的な雰囲気です。まず名前がいい！うん！シンプルでとってもいいです。そして舞台がモンタナ州クリアウォーターという何とも「リアルだけど日本人には想像がつかない隔世感」がいいです。何より，機械的な報告書の語り口と補遺に残されているかつてのクリアウォーターの住人の日誌との差異がまたいい感じです。うん。いいよね。正直全然記事紹介できてないような気がするけどヨシッ！ Tale: マリアナ海溝から回収された文書 お次はtaleです。taleとは，scp関連の小説のようなもので，多くはアイテムや財団職員の裏話的なものだったりします。つまり正規のアイテムではないです。(遂にscpですらなくなったのか) このtaleは、文字通りマリアナ海溝から回収された文章という設定になっています。内容は、数々の異常物品が財団のコントロール下から離れ、世界が危機に瀕している様子を何も知らない一般人がつづっているというものです。 ここすきポイント まず財団外部の人間の視点で書かれているという点です。異常な物品を知らない人々がどんなふうに感じるのかを映し出しているのがすごいと思います。そして、途中に出てくるある財団職員の会話が底知れない不気味さというか、常識が通じない感じというかがすごく好きです。 「なぜできないと？前にもやったんだぞ」←ここすき 「どうか、彼らが私を洗い流さないように。彼らが我々を隠さないように。もっといろいろなものを見つけてくれ、何かを残そうとした人たちがいることを私は知っている。世界を無駄死にさせないでくれ。我々を忘れないでくれ。(Remember us.)」←ここすき よもやま話 あれ？この文章で世界滅んでね？と思った方もいるかもしれません。しかし、こうやって財団のデーターベースの中に保存されているということはいまだ世界は存続しているようです。すなわち、財団は世界を修復するほどの何かを持っているという示唆になっています。実際、財団の保有する異常物品の中にはそのようなチートアイテムとしか言えないようなものがいくつか存在します。例えば SCP-2000 は、機械仕掛けの神というメタネームで、( 機械仕掛けの神 というのは、古代ギリシアの演劇において物語を収束させる何でもありな存在を指す言葉からきているようです。)世界がやばくなった時にrebootすることができるというものです。しかしメタ的にはscp-2000よりもこの記事のほうが先に投稿されており、事実上の元ネタという説が有力です。いかにこのtaleがscpコミュニティに影響を与えているかがよくわかります。 また、このtaleに登場するscpも実際に記事として存在するものがたくさんあります。実はメタ的には各報告書はパラレルワールドとして書かれることが多いのですが、(すなわち、作者の数だけ財団世界があり、それぞれで矛盾した設定をはらんでいても基本的にはOK)この記事はクロスリンクはしてないものの、様々な他記事と密接につながりがあって楽しいですね。 SCP-1986 (架空図書館) この作品は、アルゼンチン国立図書館の地下にあるトンネルのような空間です。それは無限に奥に続いており、(実際に無限かはわからないが、財団の探索では「最後」は見つかっていない)壁には無数の本がずらっと並んでいます。その内容は非常に多岐にわたり、場合によっては未知の言語で書かれていることもあります。 ここすきポイント なんといってもこの独特な雰囲気がたまらないです。無限のトンネルにある無限の本、そこには文字によって表現可能な一切を含んでいる。。。無限への憧れを感じます。 また、探索記録にある多彩な本も魅力の一つです。この記事のfootnoteには、「ある研究者は、認識できる本を求めてトンネルを探すことは、有理数を探して実数直線を横断するようなものであると喚起する比較を打ち出してきました。」とあります。(もうこれすき)すなわち、非常に厖大な本から見つけ出した貴重なサンプルというわけです。その内容も「そうはならんやろ」みたいなものばかりで面白いです。 この作品には元ネタがあります。それは、 J.L.ボルヘス というアルゼンチンの作家の作品「伝奇集」に収録されている「バベルの図書館」という作品です。以下にこの作品からの引用を書きます。 …これらの例示のおかげで、ある天才的な司書が図書館の基本的な法則を発見した。この思想家のいうには、いかに多種多様であっても、すべての本は行間、ピリオド、コンマ、アルファベットの二十五字という、おなじ要素からなっていた。また彼は、すべての旅行者が確認するに至ったある事実を指摘した。広大な図書館に、おなじ本は二冊ない。彼はこの反論の余地のない前提から、図書館は全体的なもので、その書棚は二十数個の記号のあらゆる可能な組み合わせ―その数はきわめて厖大であるが無限ではない―を、換言すれば、あらゆる言語で表現可能なもののいっさいをふくんでいると推論した。いっさいとは、未来の詳細な歴史、熾天使らの自伝、図書館の信頼すべきカタログ、何千何万もの虚偽のカタログ、これらのカタログの虚偽性の証明、真実のカタログの虚偽性の証明、バシリデスのグノーシス派の福音書、この福音書の注解、この福音書の注解の注解、あなたの死の真実の記述、それぞれの本のあらゆる言語への翻訳、それぞれの本のあらゆる本のなかへの挿入、などである…\" 岩波文庫 伝奇集, J.L.ボルヘス\rこの特徴、非常に架空図書館と似ていませんか？実はバベルの図書館の中に出てくる図書館は、六角形のパーツが無限に重なってできたような構造をしており、いろいろなところで類似点が見えると思います。そうです。このscpのスタンスは、ボルヘスが架空図書館を発見しており、そこから着想を得てバベルの図書館を書いたというものになっております。この嘘か本当かわからないくらいの現実世界とのリンクがとってもいいです。。 ちなみに原作のほうもめちゃくちゃ面白かったです。電通大図書館にも置いてあるので、興味があったら見てみてください(12/6のタイムスタンプは私です笑) SCPワールドの歩き方(の勧め) さて、scp紹介もまだまだしょうかいしたいものがありますが、 そのあたりは次の機会に譲るとして、俺的scpの楽しみ方を紹介します。 いやほら、scpって読むのも追いかけるのも大変じゃん？ はい、まず大前提として、原文をそのまま読むのは結構大変です。当たり前っちゃ当たり前なんですが、scpのフォーマットに従って書いた文って、結構かみ砕きながら読まないと理解が難しい場合も多いと思います。特に「説明」セクションの前に「特別収容プロトコル」があるので、(基本的にプロトコルはマニュアルなので、全体像をつかんでからじゃないとなんでそんなことするのかわかりにくい場合が多いです)前から通しで読んで一回ですべて内容を読み取るのは結構大変だと思います。特殊な言い回しも多いですしお寿司。 そこで、あんまり大変じゃない楽しみ方をいくつか紹介します。私みたいな人向けです。実際私はこんな生意気に解説みたいな書いてますが、原文をすべて読んだ記事はそんなに多くないです。(この辺は人にもよりますが、、、) アニヲタwikiを読む 個人的には アニヲタwiki のscp記事が非常に素晴らしいと思っています。口語調で非常に簡潔にまとまっており、それでいて細かい説明もたくさんあります。scpに関する裏話や考察なども非常に質が高いと思います。また、更新が非常に速い(ものもある)ことがいいです。時折読んだだけだと全然意味が理解できないscpとかに出会うことがあります。そんな時は基本的にまずアニヲタwikiから見てます。ということで最推しです。 youtube/niconicoの紹介動画 youtubeやniconicoではたくさんの人が開設動画をあげてくれています。scpはかなり緩いライセンスで公開されることが多いので、第三者によるコンテンツ作成も活発です。ただ、ジャンルが偏りがちだったり、解説の質がまちまちだったりという点はありますが、お気に入りの人を見つけると楽しいです。 原文読み上げ scp作品はその性質上、音声コンテンツとして提供されている場合も多いです。上で紹介したような解説ではなく、完全に原文をAquesTalkなどで読み上げするというようなものです。 この方法のおすすめポイントは報告書風の文章と合成音声が非常にマッチしているという点です。個人差はあると思いますが、私は好きです。また、自動再生で適当に流すだけでいろいろなscpと出会えるのもいいところだと思います。 SCP情報局 さんは大量のコンテンツをyoutube/niconicoにアップロードしてくれているので、私はよく聞き流しています。あと、解説の茶番とかが嫌いな人にもいいかもしれません。(コメント欄でそういう意見見たことあります) 気に入ったscpを見つけたら 上で書いたような方法で、お気に入りのscpをみつけたら、次は本家に行って読んでみることをお勧めします。きっとまた違う印象とか感じるんじゃないでしょうか？(適当)あと、記事内でクロスリンクされている先を見に行ってみるのも面白いと思います。 長い。三行で。 アニヲタwikiと読み上げがおすすめ 気に入ったのがあったら本家 ただ、楽しみ方は人による\\ 終わりに 内容は以上で終了です！めっちゃ長い記事になってしまいましたが、読んでくれた人もそうでない人もこのページに来ていただきありがとうございます。 あまり考えずに勢いで書いてしまったので、結構読みづらい記事になってしまったかもしれません。というかそもそもこんな長い文章めったに書かないのでそりゃそうかもしれません。もし誤字脱字や内容に関する訂正依頼、記事への感想や文句などがあればそれらは twitter のほうにお願いします。githubわからない人類なので、githubでなんかしていただいても反応できない可能性が高いからです。 初めてのアドベントカレンダーですが、ほかの参加者の記事などを読めて楽しいなと思いました。また来年も続くといいですね！ この記事を通してscpを楽しむ人が増えてくれたら私は嬉しいです。それではありがとうございました！メリークリスマス！"
  },
  {
    url: "/post/abc282/",
    title: "ABC282参加記録",
    date: "2022-12-18T00:00:00+09:00",
    body: "ABC282参加記録 \r今週もABC参加してきた こんにちは，冷凍うどんを食べようとしたら鍋の口が小っちゃくて入らなかった In です。 毎週ABCに参加し続けて，今回の ABC282 で5回目になりました。今週も結果報告と自分の忘備録を兼ねて記事を残しておきます。 結果報告のコーナー まずはいつも通り結果報告からです。今回の提出状況はこのような感じでした。 まずB問題で問題文の読み間違えが発生して無駄に悩んだ挙句，C問題で3WAを出して爆死しました。はい。結果的にはABCの三完でした。何とか途中で修正できてよかったです。ちなみにD以降は私にはもうちんぷんかんぷんでした。 今回のコンテストによるレーティング変動は，以下の通りでした。ジャン！ コラ～～～～！！！！！！！ ...ということで爆死でした。パフォーマンスは210で，今までで2番目に低い値を記録してしまいました。絶望感漂う中，記事を書いていきたいと思います。 もう終わりだよこの国 問題と解法 どんなふうに問題を解いたかを紹介します。 A問題 問題文は以下の通りでした。 与えられた整数Kの分だけ英大文字を出力する問題です。制約からZよりあとに関しては考えなくてもいいことが分かります。したがって，ASCIIコードを利用してprintf関数で標準出力に出力していけばオーケーです。 もう少し具体的に言うと， ASCIIコード表 によると，英大文字は65番にAから始まって，90番にZまで順番に割り当てられています。したがって，ループ毎に1ずつ増やしていけばオーケーです。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int k; scanf(\u0026#34;%i\u0026#34;, \u0026amp;k); for(int i = 0; k \u0026gt; i; i++) { printf(\u0026#34;%c\u0026#34;, 65 + i); } return 0; } 最近のABCは毎回ASCIIコード表を見ながらやってる気がします。次B問題です。 B問題 問題文は以下の通りです。 N人の人が，コンテストに出題される各問題を解けるかどうかのデータが渡されます。参加者から2人を選んで，コンテストの問題をすべて解けるペアを作るとするとき，作ることができるペアの数を調べる問題です。 この時，作ることができるペアとは，「同時に作ることができるペア」ではないことに注意する必要があります。私はこれを勝手に同時に作ることができるペアの数のことだと勘違いして，永遠に悩んでいました。 また，この問題にはもう一つ注意する必要のある点があります。それは，ペアには順序を考えないことです。具体的には，ある一人を選んで，その人が一緒に組むことで全問正解できるようなペアをすべて列挙していくコードで解こうとすると，気を付けないとA-BのペアとB-Aのペアを区別してカウントしてしまうということが起こります。私はこの方針で解きましたが，前述の問題は，二重forループの二重目のループ変数を，一重目のループ変数で初期化することで対処しました。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, m; // nが人，mが問題 scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;n, \u0026amp;m); char s[n][31]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[i][0]); } int ans = 0; char flag = 0; for(int i = 0; n \u0026gt; i; i++) { for(int j = i; n \u0026gt; j; j++) { if(i == j) { continue; //同じ番号同士は考えない } for(int k = 0; m \u0026gt; k; k++) { if(s[i][k] == \u0026#39;x\u0026#39; \u0026amp;\u0026amp; s[j][k] == \u0026#39;x\u0026#39;) { //ダメだった flag = 1; break; } } if(flag == 0) { ans++; // 可能ペア発見 } else { flag = 0; //戻す } } } printf(\u0026#34;%i\u0026#34;, ans); return 0; } 少し見にくいかもしれません。すみません。途中3重forループがありますが，最初の二つが人を選ぶところと対応しており，三つめが問題をすべて解けるかの判定になっています。 C問題 最後にC問題です。問題文は以下の通りです。 \u0026quot;に挟まれていない部分にのみ違う処理を施して，文字列を得る問題です。 正直，この問題はC問題の中では簡単なほうかなと思います。(簡単というのは，方針が思い浮かびやすいという意味です。)しかし，私はこの問題で大コケしてしまい，*順位が死にました。*結構ガチでショックです。 解法としては，文字列を配列で受け取り，\u0026quot;を発見したら，次の\u0026quot;までそのまま出力するようにするとオッケーです。この分岐の処理をいかに簡単にするかがキモだと思います。 まずは私がWAを出したクソコードを載せます。反面教師です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); for(int j = i + 1; s[j] != \u0026#39;\u0026#34;\u0026#39;; j++) { if(s[j] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[j]); } i++; } i++; printf(\u0026#34;%c\u0026#34;, s[i]); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } まずはクソコードその一です。言うまでもなくこのコードの抱える一番の問題点は，とにかくごちゃごちゃしている点です。このコードはprintf関数を5回も使っており，いかに事前にどうやって組むかを考えていなかったかがバレバレです。また，もう一つの重大な欠点は問題の要求と逆の処理をしていることです。問題文の読み違えには気を付けよう！(公開ブログで ゆうさく を貼れるほど度胸は無かった) お次に，これをもう少し修正したけどダメだったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); i++; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードは，問題ページにあるテストケースは無事に突破しました。しかし，いまだ重大な問題を抱えています。それは*極端な入力に対してバッファーオーバーランが起こりえます。*これはヤバい(確信) このコードは，最初に\u0026quot;が来たかどうかを判定して，来ていたら次の\u0026quot;までそのまま出力し続けるようにしてあります。これだけ聞くとまともそうですが，一番ダメなのはインクリメントを管理しきれていない点です。ループの途中に分岐点を作っていたりする関係上，コード中のあちこちでインクリメントが発生するせいでバグを追いきれませんでした。 例えば入力が\u0026quot;\u0026quot;\u0026quot;\u0026quot;だったりすると，余分なインクリメントが発生してバッファの外側に突き抜けます。そして次の\u0026quot;が見つかるまで止まることはありません。うーんこの 最後にAC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); char s[n]; scanf(\u0026#34;%s\u0026#34;, \u0026amp;s[0]); for(int i = 0; n \u0026gt; i; i++) { if(s[i] == \u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%c\u0026#34;, s[i]); i++; for(; s[i] != \u0026#39;\u0026#34;\u0026#39;; i++) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;%c\u0026#34;, s[i]); continue; } if(s[i] == \u0026#39;,\u0026#39;) { printf(\u0026#34;%c\u0026#34;, \u0026#39;.\u0026#39;); } else { printf(\u0026#34;%c\u0026#34;, s[i]); } } return 0; } このコードはさっきのコードにcontinue処理を挟むことで(一時的なものですが)さっき挙げた不正なインクリメントを防止しています。 教訓: インクリメントはわかりやすい場所で管理しよう。continueやbreakをちゃんと使おう。 完走した感想 今回のコンテストはかなり残念な感じになってしまいました。しかしとりあえずC問題まででも解けて良かったです。結構実装の技術的な点でコケることが多いなと感じているので，もっと問題数を解いてデバッグなどに慣れたいです。また，D問題以降は数学的知識や競プロ的な技術がかなり問われる問題かなと(一見)思いました。したがって，大学での数学の勉強などはしっかり頑張りたいです。(願望) 今回の結果はかなり来るものがあるけど，今日体調悪かったから多少はね？ ここまで読んでいただき，ありがとうございました。また次の記事でお会いしましょう。ちなみに一週間後のUECアドベントカレンダーに登録したはいいもののまだ一文字も書いていません(絶望)じゃあね。"
  },
  {
    url: "/post/abc281/",
    title: "ABC281に参加してきた。",
    date: "2022-12-10T00:00:00+09:00",
    body: "ABC281に参加してきた。 今週もABCに参加してきたよ こんにちは。あいも変わらず今週もABCに参加してきました。その結果報告の記事です。 今回の戦績発表 まずは今回の戦績です。以下は今回の私の提出です。 今回は珍しくWAを出さずにコンテストを終えることができました。D問題は解けなかったので，実質コンテスト参加時間は30分でした笑 ちなみにレーティングは今回で+62でした。着々と上がっている感じが結構うれしいし，モチベーションになっているような気がします。 解法など 今回の記事も，自分がどうやって解いたかを残しておきます。 A問題 以下は問題文です。 今回のA問題は最近の中では簡単なほうかな？っていうのが率直な意見です。この問題はforなどのループ構造を書ければ回答できそうですね。具体的には，受け取った数字分のループを回して，その中で変数をデクリメントしながら出力すればオーケーですね。以下は私の提出です。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); for(int i = n; i \u0026gt;= 0; i--) { printf(\u0026#34;%i\\n\u0026#34;, i); } return 0; } c言語ではfor文でインデックス変数が利用できるので，比較的簡単に記述することができます。 B問題 まずは問題文です。 文字列の照合問題ですね。正直この手の問題は結構苦手とするところですが，，，今回は何とか解けました。 方針としては，まず与えられた文字列をscanf関数で文字列型として読み取って，ASCIIコードで照合していきました。具体的に言うと，まず「先頭の文字が一文字の英大文字」という条件は，受け取った文字列が入っている配列の一つ目の要素が，「数値として」65以上かつ90以下という条件により判別することができます。このようなことを繰り返して判別していきます。以下はACが通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[11] = {0}; //全部ゼロで初期化する scanf(\u0026#34;%s\u0026#34;, s); if(!(s[0] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[0])) { // 頭大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[1] == 48) { printf(\u0026#34;No\\n\u0026#34;); return 0; } for(int i = 1; 7 \u0026lt; i; i++) { if(!(s[i] \u0026gt;= 48 \u0026amp;\u0026amp; 57 \u0026gt;= s[i])) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } if(!(s[7] \u0026gt;= 65 \u0026amp;\u0026amp; 90 \u0026gt;= s[7])) { // ラスト大文字チェック printf(\u0026#34;No\\n\u0026#34;); return 0; } if(s[8] != 0) { // きっちり8文字かチェック printf(\u0026#34;No\\n\u0026#34;); return 0; } printf(\u0026#34;Yes\\n\u0026#34;); return 0; } コメントで「きっちり8文字かチェック」と書かれている部分について少しだけ補足します。今回の問題の制約では，ASCIIコードにおいて十進数表示で0になるような文字が入力されることがないので，この条件により確実に仕分けることができます。しかし，一般的な場合に関してはそうとは限らないので，注意が必要です。(今回0という条件にしたのはたまたま配列を0で初期化しようと思ったからというだけで特に深い理由はありません。) C言語でこういう文字列処理をするのはかなり面倒くさいですね。。。もっといい方法があるのかもしれませんが。 C問題 以下問題文です。 循環するプレイリストにおいて，与えられた時間が経過したときに何曲目が流れているかを考える問題ですね。 この問題を考える上でまず大切なのが，プレイリストの総再生時間よりも再生時間が大きくなるようなパターンが存在することです。この時，プレイリストの総再生時間分だけ経過したら一番最初の状態に戻るので，再生時間を総再生時間で割った余りを考えることで問題を簡単にすることができます。(なお，総再生時間が再生時間よりも大きいような場合には，再生時間がそのまま余りとなります。したがって，とりあえず剰余を考えるという方法でも大丈夫です。) この後，その余りを，一つ一つの楽曲再生時間の和が超えたタイミングが答えの曲の位置になります。これはほぼ自明ですね。 以下は提出コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; long long int t; long long int sum = 0; // 全曲の総再生時間 scanf(\u0026#34;%i %lli\u0026#34;, \u0026amp;n, \u0026amp;t); int a[n]; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;a[i]); sum = sum + a[i]; } if(t \u0026gt; sum) { t = t % sum; } sum = 0; //sumリセット int num; for(int i = 0; ;i++) { sum = sum + a[i]; if(sum \u0026gt; t) { num = i + 1; sum = sum - a[i]; break; } } printf(\u0026#34;%i %lli\\n\u0026#34;, num, t - sum); return 0; } やっていることはほとんど上で書いたことそのままです。ただし，for文のインデックス変数が(というより配列の要素が)0からスタートする一方，曲の順番は1からスタートするので気を付けましょう。 D問題 D問題は，解けなかったよ。。。(n回目) とりあえず問題の紹介だけはします。以下問題文です。 つまりは，Aの元から任意にK個を選んできて，それらを足したものの集合を考えるときに，与えたDの倍数であるようなもので最大のものを探すというものです。 この問題の恐ろしいところは，Aの元から任意にK個を選ぶ組み合わせの数が非常に大きくなることがあるという点です。この問題において最悪ケースを考えると， Aの要素が100個 Kが50(詳細は省きます) となるときです。この時の組み合わせの数はなんと100,891,344,545,564,193,334,812,497,256になります。どう考えても愚直にやるのは無理です。 しかし現在の私ではこの問題に対する有効な解法はわかりませんでした。なのでC問題を解き終わってからコンテスト終了まで机の前でｳﾝｳﾝうなってました。う～ん，アホ！w なお，コンテスト終了後に公開される 解説 によると，この問題は動的計画法なるもので解くことができるらしいです。知らんが？ というわけでボロボロでした。精進します。 終わりに 今回の参加記は以上です。だんだんレートが上がっているとは言えども，専門的なアルゴリズムの知識なんてないのでこういう問題にぼこぼこにされる日々です。しかし，思ってる以上に競プロを通じて数学などに触れることは新鮮で楽しいと思っています。今のところは。ということでこれからも頑張っていけたらなと思います。 DPなんかねえよ(K重forループをおもむろに書き始める) というわけで，ここまで読んでいただきありがとうございました。また次の記事でお会いしましょう。"
  },
  {
    url: "/post/abc280/",
    title: "ABC280に参加してきました！",
    date: "2022-12-04T00:00:00+09:00",
    body: "ABC280に参加してきました！ 今回もABCに参加してきました。 どうもこんにちは。大学の課題が結構やばいことになっているInです。今回も ABC に参加してきましたので，その参加記事になっております。別に競技プログラミングのためだけにこのブログ(?)を開設したわけじゃないのに，現状では競技プログラミングの記事しかないことを憂いております。(やる気やらなんやらの問題で筆が進まないんですよね) 閑話休題。それでは今週の参加感想記事です。 結果発表のコーナー 今週の提出結果です。 なんと今回は運よくCまで解くことができました。(ドンドンパフパフ) 今回の成績は，4888/8672で，パフォーマンス375でした。そこそこよろしいんじゃないでしょうか？(そこ，灰パフォでイキるなとか言わない！)レーティング変動は今回プラス34で現在104です。入茶が楽しみです。 解法やらなんやらの振り返り 今週もいつものごとく問題をどのように解いたのかを忘備録として記録しておきます。まずはA問題です。 *Oh...*今週のA問題はなんだか見た目がいかついですね。正直A問題でつまずいて死ぬパターンかと思いました。 さて，見た目はいかついですが，この問題はよく見てみるとそんなに難しいことを言っていないことが分かります。 要するに#.##...#←こんな感じの文字列(文字列一つにつきW個の文字)がH回入力されるので，#の数を数えてくださいねということです。 先週の文字列祭り に比べたらだいぶんましですね。方針としては，HもWも少ないのが制約からわかるので，シンプルに文字列として標準入力から読み取って，一文字づつ見ていく感じで処理しました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int h, w; scanf(\u0026#34;%i %i\u0026#34;, \u0026amp;h, \u0026amp;w); char word[11]; int count = 0; for(int i = 0; h \u0026gt; i; i++) { scanf(\u0026#34;%s\u0026#34;, word); for(int j = 0; w \u0026gt; j; j++) { if(word[j] == \u0026#39;#\u0026#39;) { count++; } else if(word[j] == \u0026#39;0\u0026#39;) { break; } } } printf(\u0026#34;%i\\n\u0026#34;, count); return 0; } そこそこシンプルに書くことができました。ある程度標準入出力の使い方には慣れてきたんじゃないかなと思います。 さて，次はB問題です。以下問題文です。 記号と数字がわちゃわちゃしていて結構ウッってなる人多いかもしれません。僕もそうでした。 しかし，一回紙に書くとかなりシンプルに整理されることが分かります。 実際，Sk+1=Sk+Ak+1が成立しますから，逆に見るとAk=Sk-Sk-1(ただしS0=0) という関係式が成り立つことが分かります。したがって，二つのSから一つのAを錬成しながら出力していく方針で解けます。いやー数学って偉大ですね。以下通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%i\u0026#34;, \u0026amp;n); int s1, s2; s1 = 0; for(int i = 0; n \u0026gt; i; i++) { scanf(\u0026#34;%i\u0026#34;, \u0026amp;s2); printf(\u0026#34;%i \u0026#34;, s2 - s1); s1 = s2; } return 0; } なんとA問題よりも短くなってしまいました。個人的には実装含めての難易度だと今回Bのほうが簡単だと思いました。 あと余談なんですが，誰が読んでも誤解を与えないという点では競プロのような問題文の書き方は適切だとは思いますが，記号を大量に使用するのは可読性っていう点だとどうなのかなってちょっと思ったりします。まあ例がついているので支障はそんなにないですが。 次はC問題です。以下問題文です。 英小文字のみからなる文字列を比較する問題のようです。文字列TはSにもう一つだけ文字を追加して作られているもののようですね。今回のC問題はなんかやたらとシンプルで助かりました。 方針としては，まず二つの配列を用意して文字列として読み取り，次にSとTを頭から見ていって，初めて一致しなくなった場所が答えという感じで行きました。配列としてみるときはインデックスが一つずれるので注意です。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char s[500001]; char t[500002]; scanf(\u0026#34;%s\u0026#34;, s); scanf(\u0026#34;%s\u0026#34;, t); for(int i = 0; ; i++) { if(s[i] != t[i]) { printf(\u0026#34;%i\\n\u0026#34;, i + 1); break; } } return 0; } こんな感じで実装しました。手元のマシンだとstaticではない配列の宣言で要素500000とかあまりやらないので結構ジャッジサーバーは融通効くなって印象です。 ちなみに余談ですが，この問題多くの人が引っ掛かったポイントがあったようで，(自分も1WA食らいました。)それは，「Sの最後に付け足すパターン」の見落としです。このミスは初心者から上位勢までみんな食らっててちょっと面白かったです。おそらく多くの人が引っ掛かった理由は，普通は\\0(終端文字)が出現したら読み取りのループをブレークするのですが，この問題に関しては必ずTがSから構成される文字列であることが保証されているので，そんな気遣いをしなくてもOKだったっていう感じだと思われます。 D問題は，，解けなかったよ 今回Cの提出まで結構スムーズに行けたので，「お！ワンチャンあるか？」と思っていましたが，D問題結局解けませんでした。。。 Dの問題文は以下の通りでした。 この問題，見た目は結構シンプルなんですが，かなり厄介で手を動かすだけだと無理でした。 というのも，直接階乗を計算するのが無理なんですよね。 Cでの整数型の最大値unsigned long long intの最大が，18446744073709551615となっており，20桁まで入るんですが，実は20!の時点で18桁の整数になります。 階乗はおそロシア。なので，ほかの部分に注目して行かなくてはいけないんですけど，効率的な方法を見つけられなかったのと，実装力の低さのせいでスパゲッティコードを錬成してタイムアップしました。ただ，数学的に解を見つけられそうなので解けたら別記事として投稿したいなとは思っています。 終わりに ABCを始めてから3週間ほどたちますが，少しは成長したのかなと思います。課題で忙しい時もありますが，ドンドン AtCoder Beginer's Selection や 競プロ典型90問 などにも取り組んでいけたらいいなと思います。(アルゴ式も)目指せ茶コーダー！ 余談ですが，このサイトに投稿されている記事は，markdownからの変換とかではなくすべてhtmlを手打ちしているので，手書きhtmlかなり慣れてきたような気もします。いいことなのかは知らん。 今回も読んでいただきありがとうございました。次の記事で会いましょう。 P.S. UEC Advent Calendar1 と UEC Advent Calendar2 が開催中ですので，興味があったら皆さんも読みましょう。(私も24日に寄稿(?)予定です。)"
  },
  {
    url: "/post/abc279/",
    title: "ABC279参加してきた！",
    date: "2022-11-27T00:00:00+09:00",
    body: "ABC279参加してきた！ はじめに 今回 ABC279 に参加してきましたので，その記録です。 今回の成績 まずは今回の成績からです。以下画像です。 AとBしか，解けませんでした！！！！(キース団長並感) いや，文字列扱う問題多くないですか？？？？？？私は文字列を操作する練習を全然してなかったのでB問題で死ぬほど苦労しました... 今回はあまり語るようなことがないので，サクッと解法紹介と今回の反省のパートに行きたいと思います。 解法 (注意: 筆者はc言語使ってます。)まずはA問題からです。以下問題文です。 これは文字列を扱う練習みたいな問題ですね。「下に尖った部分」というのはvは1箇所，wは2箇所なので，文字列を最初から見ていって，「vの個数」× 1と「wの個数」× 2を足したものをprintf関数で標準出力で出したらオッケーですね。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char a[100]; scanf(\u0026#34;%s\u0026#34;, a); int score = 0; int i = 0; while(a[i] != \u0026#39;\\0\u0026#39;) { if(a[i] == \u0026#39;v\u0026#39;) { score = score + 1; } else if(a[i] == \u0026#39;w\u0026#39;) { score = score + 2; } i++; } printf(\u0026#34;%i\\n\u0026#34;, score); return 0; } 関係ない話ですが，問題の名前が「wwwvvvvvv」だったり問題文に平気で「尖っている部分」とか書いてあるのが地味にじわじわ来る問題ですね。 お次はB問題です。以下問題です。 この問題は全探索で解きました。簡単に流れを説明すると，まず最初に文字列Tの最初の文字を文字列Sの先頭から探します。見つかったら一文字ずつ後続も一致しているか確認して，もしTが'\\0'(終端文字)になるまでずっと一致していたら，Sは条件を満たしていたということが分かるので，適当にフラグを立ててループを抜けます。ここで後続に一致しないものが存在した場合は，また先頭文字が一致するか順に確認していきます。このサイクルをSが終端文字になるまで続けてもフラグがたたなかった場合は，条件を満たさないということが分かります。以下AC通ったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char S[101]; char T[101]; //比較する方 scanf(\u0026#34;%s\u0026#34;, S); scanf(\u0026#34;%s\u0026#34;, T); int flag = 0; for(int i = 0; S[i] != \u0026#39;\\0\u0026#39;; i++) { if(T[0] == S[i]) { int k = i; int j = 0; for(; S[k] == T[j] \u0026amp;\u0026amp; T[j] != \u0026#39;\\0\u0026#39;;) { k++; j++; } if(T[j] == \u0026#39;\\0\u0026#39;) { flag = 1; } } } if(flag == 1) { printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } return 0; } *この問題を通すのに本当に苦労しました。。。*実はこの問題を通すだけで今回1時間8分，WAを6回も出したことで私の順位がボロボロになりました。泣きそうです。 この問題では文字列を扱うときは必然と'\\0'の検出が必要になるのですが，それを「whileの条件式で簡単にかけるやろw」とか思ってたらマジで痛い目見ました。とにかくループ用の変数がわちゃわちゃしてしまって，ループを抜けるときの条件式がぐちゃぐちゃになってしまったのが痛すぎました。。。泣きそうです(2回目) もうwhileなんて使わない(知らんけど) ちなみに，この問題でつまずいた理由はおそらく配列の余った要素がすべて0であることを見逃していたことだと思います。アホですか？ ラスト，ACは取れなかったもののC問題を紹介しておきます。以下問題です。 この問題は正直知識不足でした。せっかくですので私の行おうとした解法を説明します。 与えられた図形SとTが「列の並べ替え」によって一致すればよいということですので，受け取ったデータをリアルタイムに処理することはできなさそうです。したがって，いったん配列に保持することにしました。この問題では行番号と列番号の情報が重要ですので，二次元配列を用意して代入しました。そして，「並べ替え」によって同じものが作れるということは，「Sのある列」を持ってくると，常に必ず一つ以上「Tのある列」が一致しているという言い換えが可能です。これなら全探索により実装可能だと判断したので，この方針で行きました。実はこの探索方法，ほとんどB問題と同じです。一番ACに近かったコードです。 #include \u0026lt;stdio.h\u0026gt; int main(void) { int H, W; //Hは行数，Wは列数 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;H, \u0026amp;W); char buffer; int flag = 0; int delflag = 0; int ans = 0; char S[H][W]; char T[H][W]; for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); S[i][j] = buffer; } } for(int i = 0; H \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;buffer); T[i][j] = buffer; } } for(int i = 0; W \u0026gt; i; i++) { for(int j = 0; W \u0026gt; j; j++) { if(S[0][i] == T[0][j]) { for(int k = 0; H \u0026gt; k; k++) { if(S[k][i] != T[k][j]) { flag = 1; break; } } if(flag != 1) { for(int l = 0; H \u0026gt; l; l++) { T[l][j] = 0; } delflag = 1; break; } flag = 0; } } if(delflag != 1) { printf(\u0026#34;No\\n\u0026#34;); return 0; } } for(int i = 0; W \u0026gt; i; i++) { if(T[0][i] != 0) { ans = 1; break; } } if(ans == 1) { printf(\u0026#34;No\\n\u0026#34;); } else { printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } このコードで最終的にTLEが2ケースでした。考え方自体は正解を出せるコードみたいです。 公式解説 では，私のとった手順と似たようなものでしたが，最後の同じ列が存在するかの判定を「文字列のソート」にて実現していました。私は文字列の扱いに関してほとんど何もわかっていなかったので，選択肢にすらあがらなかったです。次頑張ります。 余談ですが，終了後に私のコードを見た並走者が，あまりのforループの深さにびっくりしていました。こんな頭の悪い全探索しか書けないの正直ね。。 *True Programer* only use for statement and if statement.(逆張り) 終わりに 正直にいうと，今回の結果は非常に悔しかったです。もっとほかの問題に時間をかけられると思っていたし，レーティングもあまり気にしていないとはいえ重要な指標の一つでしょう。「この悔しさをバネに～」みたいな文言めちゃくちゃ嫌いなんですが，今はそんな気分です。来週のABCに向けてできるだけ準備したいと思います。 今回解けなかったC問題はもう少し取り組んでみようと思います。もし解けたら追記します。 長文読んでいただきありがとうございました。"
  },
  {
    url: "/post/abc278/",
    title: "ABC278に参加してみた！",
    date: "2022-11-19T00:00:00+09:00",
    body: "ABC278に参加してみた！ こんにちは。 In です。この度初めて競技プログラミング，もといAtCoderに参加してみたので，その記録もかねてこの記事に残しておきます。注意: 筆者はプログラミング初心者なので競プロ的には特に参考になる点はありません。 競プロって何？ 競技プログラミングでは、参加者全員に同一の課題が出題され、より早く与えられた要求を満足するプログラムを正確に記述することを競う。コンピュータサイエンスや数学の知識を必要とする問題が多く、新卒学生の採用活動などに使われることもある[7][8]。多くのコンテストでオンラインジャッジが採用されている。また、競技プログラミングに参加する人を「競技プログラマ」または「競プロer」と呼ぶことがある。近年、プログラミング教育において、競争型学習が注目されている。特に、一定の時間内にプログラミング問題を解く競技系のコンテストは、授業中の演習形式として期待される。しかしこれらは高度であり入門的な授業にコンテストを取り入れるには、初心者向けに視野を広げる適応を考える必要がある。 Wikipedia, 競技プログラミング\rだそうです。(適当)まぁ要するに与えられた問題をプログラムで解くんですね。私が参加したのは AtCoder というサイトで行われているものです。正直私はあまり詳しくないです。 初めて参加しての感想 今回あまり下調べせずに適当に参加してみたんですけど，はっきり言ってボロボロでした。。。でも楽しかったです。まず結果から載せます。以下が今回の提出状況でした。 A問題で躓きすぎだろ！！！！！ はい。ということで，AとBだけ通すことができまして，得点は3200点中200点取れました。こんなにAがボロボロだったのにも少し訳がありまして，今回私は何の下調べもせずに参加してしまったせいで，標準入力を受け取る方法をずっと模索してたんですよね。前半の何回かのWAはそれにやられました。ちなみに，B問題はコンテスト終了8秒前に提出完了したので，ほんとに奇跡的に通すことができたって感じでした。 自分なりの解法(覚書) AとBしか通せない雑魚が何をいっちょ前にと思うかもしれませんが，せっかく考えたプログラムですので，どんな感じでやったのかを残しておこうと思います。使用言語はcで，コンパイラはClang10.0.0を使用しました。 まずはA問題です。以下が問題文です。 この問題は，配列を用意して数列を入れていき，操作の回数番目のところから出力して，0で水増しするような感じで解きました。以下コードです。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int input = 0; int length = 0; int operation_times = 0; char sequence[100]; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;length, \u0026amp;operation_times); for(int i = 0; length \u0026gt; i; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); sequence[i] = input; } for(int i = operation_times; length \u0026gt; i; i++){ printf(\u0026#34;%d \u0026#34;, sequence[i]); } if (operation_times \u0026lt; length){ for(int i = 0; operation_times \u0026gt; i; i++){ printf(\u0026#34;0 \u0026#34;); } } else { for(int i = 0; length \u0026gt; i; i++){ printf(\u0026#34;0 \u0026#34;); } } return 0; } この問題で，最初操作の回数が数列の長さを上回るパターンを見落としていて見事にWAを食らいました。あと，前にも書きましたが標準入力の取り扱いが分からないせいで1時間くらいかかりました。 次B問題です。 この問題は，きちんと考えるのが大変だったので取り合えず全探索をしようという方針で行きました。「見間違えやすい時刻」を評価するために，〇〇時△△分を十の位，一の位に分解してから初めて「時間として許容できる組み合わせ」に到達したらループを抜けるようにしました。なお，日付をまたいでも(24時以降)いいように，24で割った余りを利用しています。以下コードです。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void){ int hour = 0; int min = 0; int hour_tens = 0; int hour_ones = 0; int min_tens = 0; int min_ones = 0; int hour_remain = 0; int min_remain = 0; int flag = 0; int breakflag = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;hour, \u0026amp;min); for(int i = hour; 48 \u0026gt; i; i++){ hour_remain = i % 24; hour_tens = hour_remain / 10; hour_ones = hour_remain % 10; if(flag == 1){ min = 0; } for(int j = min; 60 \u0026gt; j; j++){ min_tens = j / 10; min_ones = j % 10; if(24 \u0026gt; hour_tens * 10 + min_tens \u0026amp;\u0026amp; 60 \u0026gt; hour_ones * 10 + min_ones){ printf(\u0026#34;%d %d\u0026#34;, hour_tens * 10 + hour_ones, min_tens * 10 + min_ones); breakflag = 1; break; } } flag = 1; if(breakflag == 1){ break; } } return 0; } 絶対こんなに変数いらなかっただろ ということでこれでAC通りました。もっと数学的に考察したら簡単に解けたかも？(面倒くさいからやらない) 終わりに 初めてのコンテスト参加でしたが，全体的に見て楽しかったです。これからもコンテストは出ていこうかなと思っています。やる気のある時にまたこうやって記事も書いてみたいなと思います。それでは読んでいただき，ありがとうございました。この記事に関して何かございましたら私の Twitter までどうぞ。"
  },
  {
    url: "/about/",
    title: "About",
    date: "0001-01-01T00:00:00Z",
    body: "About About Me 電気通信大学に在学中。 最近は競技プログラミングをよくやっています。 ハンドルネームはInかInTheBloomを使っていることが多いです。 サイトの方針 google analyticsなどのアクセス解析は利用していません。 削除、修正依頼は次に示す連絡先までお願いします。 連絡先 Twitter(X) gmail (nato.rider.smm2 [at] gmail.com) など 最後に 当サイトは github pages 、 hugo 、 simplog のおかげで作成できました。ありがとう！"
  },
];

function search(query) {
  const result = searchData(query);
  const html = createHtml(result);
  showResult(html);
  showResultCount(result.length, data.length);
}

function searchData(query) {
  
  
  const result = [];

  query = query.trim();
  if (query.length < 1) {
    return result;
  }
  const re = new RegExp(query, 'i');
  for (let i = 0; i < data.length; ++i) {
    const pos = data[i].body.search(re);
    if (pos != -1) {
      result.push([i, pos, pos + query.length]);
    }
  }
  return result;
}

function createHtml(result) {
  const htmls = [];
  for (let i = 0; i < result.length; ++i) {
    const dataIndex = result[i][0];
    const startPos = result[i][1];
    const endPos = result[i][2];
    const url = data[dataIndex].url;
    const title = data[dataIndex].title;
    const body = data[dataIndex].body;
    htmls.push(createEntry(url, title, body, startPos, endPos));
  }
  return htmls.join('');
}

function createEntry(url, title, body, startPos, endPos) {
  return '<div class="item">' +
      '<a class="item_title" href="' + url + '">' + title + '</a>' +
      '<div class="item_excerpt">' + excerpt(body, startPos, endPos) + '</div>' +
      '</div>';
}

function excerpt(body, startPos, endPos) {
  return [
    body.substring(startPos - 30, startPos),
    '<b>', body.substring(startPos, endPos), '</b>',
    body.substring(endPos, endPos + 200)
  ].join('');
}

function showResult(html) {
  const el = document.getElementById('result');
  el.innerHTML = html;
}

function showResultCount(count, total) {
  const el = document.getElementById('resultCount');
  el.innerHTML = '<b>' + count + '</b> 件見つかりました（' + total + '件中）';
}
</script>

</body>







<hr class="block-separater">










<div class="content-footer-item neighbor">
	
	
</div>
















<script src="/js/single.js"></script>





	</div><div id="content-footer" class="sub">
  
  <div class="credit">
    Power by <a href="https://gohugo.io">Hugo</a> /
    Theme <a href="https://github.com/michimani/simplog/">simplog</a> by <a href="https://github.com/michimani/">michimani</a>
  </div>
</div></body>

</html>